#!/usr/bin/env ts-node import * as pulumi from '@pulumi/pulumi'; import { LocalWorkspace, Stack } from '@pulumi/pulumi/automation'; import * as fs from 'fs'; import * as path from 'path'; interface ComplianceCheckOptions { stack?: string; standards?: string[]; outputFormat?: 'json' | 'markdown' | 'html'; strict?: boolean; } interface ComplianceReport { stack: string; timestamp: string; standards: string[]; compliant: boolean; score: number; checks: ComplianceCheck[]; recommendations: string[]; } interface ComplianceCheck { id: string; name: string; category: string; severity: 'critical' | 'high' | 'medium' | 'low'; status: 'pass' | 'fail' | 'warning'; message: string; resource?: string; remediation?: string; } const COMPLIANCE_STANDARDS = { SOC2: [ 'encryption-at-rest', 'encryption-in-transit', 'audit-logging', 'backup-enabled', 'monitoring-enabled', 'access-controls', 'network-segmentation' ], GDPR: [ 'data-encryption', 'data-retention', 'audit-trail', 'access-logging', 'data-location', 'consent-management' ], HIPAA: [ 'phi-encryption', 'access-controls', 'audit-logging', 'backup-retention', 'disaster-recovery', 'data-integrity' ], ISO27001: [ 'cryptographic-controls', 'event-logging', 'backup-strategy', 'monitoring', 'incident-response', 'access-management' ], PCI_DSS: [ 'network-security', 'data-protection', 'vulnerability-management', 'access-control', 'monitoring-testing', 'security-policies' ] }; async function main() { const args = process.argv.slice(2); const options = parseArguments(args); console.log(' Starting compliance check...'); try { const stackName = options.stack || await getCurrentStack(); const standards = options.standards || ['SOC2', 'GDPR']; console.log(` Checking stack: ${stackName}`); console.log(` Standards: ${standards.join(', ')}`); const report = await checkCompliance(stackName, standards, options); // Generate output const output = generateReport(report, options.outputFormat || 'markdown'); // Save report to file const reportPath = path.join(process.cwd(), `compliance-report-${Date.now()}.${options.outputFormat || 'md'}`); fs.writeFileSync(reportPath, output); console.log(`\n Report saved to: ${reportPath}`); // Display summary displaySummary(report); // Exit with error if not compliant and strict mode if (!report.compliant && options.strict) { console.error('\n Compliance check failed in strict mode'); process.exit(1); } process.exit(0); } catch (error) { console.error(' Compliance check failed:', error); process.exit(1); } } function parseArguments(args: string[]): ComplianceCheckOptions { const options: ComplianceCheckOptions = {}; for (let i = 0; i < args.length; i++) { switch (args[i]) { case '--stack': options.stack = args[++i]; break; case '--standards': options.standards = args[++i].split(','); break; case '--format': options.outputFormat = args[++i] as 'json' | 'markdown' | 'html'; break; case '--strict': options.strict = true; break; } } return options; } async function getCurrentStack(): Promise<string> { const workspace = await LocalWorkspace.create({ workDir: process.cwd(), }); const stack = await workspace.stack(); return stack.name; } async function checkCompliance( stackName: string, standards: string[], options: ComplianceCheckOptions ): Promise<ComplianceReport> { const workspace = await LocalWorkspace.create({ stackName, workDir: process.cwd(), }); const stack = await Stack.select(stackName, workspace); const exportedStack = await stack.exportStack(); const resources = exportedStack.deployment.resources || []; const checks: ComplianceCheck[] = []; const recommendations: string[] = []; // Run checks for each standard for (const standard of standards) { const standardChecks = await runStandardChecks(standard, resources); checks.push(...standardChecks); } // Calculate compliance score const passedChecks = checks.filter(c => c.status === 'pass').length; const totalChecks = checks.length; const score = totalChecks > 0 ? Math.round((passedChecks / totalChecks) * 100) : 0; // Determine if compliant const criticalFailures = checks.filter(c => c.status === 'fail' && c.severity === 'critical'); const compliant = criticalFailures.length === 0 && score >= 80; // Generate recommendations for (const check of checks.filter(c => c.status === 'fail')) { if (check.remediation) { recommendations.push(check.remediation); } } return { stack: stackName, timestamp: new Date().toISOString(), standards, compliant, score, checks, recommendations: [...new Set(recommendations)] // Remove duplicates }; } async function runStandardChecks(standard: string, resources: any[]): Promise<ComplianceCheck[]> { const checks: ComplianceCheck[] = []; const requirements = COMPLIANCE_STANDARDS[standard as keyof typeof COMPLIANCE_STANDARDS] || []; for (const requirement of requirements) { const check = await runCheck(requirement, resources, standard); checks.push(check); } return checks; } async function runCheck(requirement: string, resources: any[], standard: string): Promise<ComplianceCheck> { switch (requirement) { case 'encryption-at-rest': return checkEncryptionAtRest(resources, standard); case 'encryption-in-transit': return checkEncryptionInTransit(resources, standard); case 'audit-logging': return checkAuditLogging(resources, standard); case 'backup-enabled': return checkBackupEnabled(resources, standard); case 'monitoring-enabled': return checkMonitoringEnabled(resources, standard); case 'access-controls': return checkAccessControls(resources, standard); case 'network-segmentation': return checkNetworkSegmentation(resources, standard); default: return { id: requirement, name: requirement, category: standard, severity: 'medium', status: 'warning', message: `Check not implemented: ${requirement}`, }; } } function checkEncryptionAtRest(resources: any[], standard: string): ComplianceCheck { const unencryptedResources = resources.filter(r => { if (r.type.includes('s3') || r.type.includes('storage')) { return !r.outputs?.encryption || r.outputs.encryption === false; } if (r.type.includes('rds') || r.type.includes('database')) { return !r.outputs?.storageEncrypted || r.outputs.storageEncrypted === false; } return false; }); return { id: 'encryption-at-rest', name: 'Encryption at Rest', category: standard, severity: 'critical', status: unencryptedResources.length === 0 ? 'pass' : 'fail', message: unencryptedResources.length === 0 ? 'All storage resources are encrypted at rest' : `${unencryptedResources.length} resources found without encryption at rest`, resource: unencryptedResources.map(r => r.id).join(', '), remediation: 'Enable encryption for all storage and database resources' }; } function checkEncryptionInTransit(resources: any[], standard: string): ComplianceCheck { const unencryptedConnections = resources.filter(r => { if (r.type.includes('loadbalancer') || r.type.includes('alb')) { return !r.outputs?.protocol || r.outputs.protocol === 'HTTP'; } if (r.type.includes('redis') || r.type.includes('cache')) { return !r.outputs?.transitEncryptionEnabled; } return false; }); return { id: 'encryption-in-transit', name: 'Encryption in Transit', category: standard, severity: 'high', status: unencryptedConnections.length === 0 ? 'pass' : 'fail', message: unencryptedConnections.length === 0 ? 'All connections are encrypted in transit' : `${unencryptedConnections.length} unencrypted connections found`, resource: unencryptedConnections.map(r => r.id).join(', '), remediation: 'Enable TLS/SSL for all network connections' }; } function checkAuditLogging(resources: any[], standard: string): ComplianceCheck { const hasCloudTrail = resources.some(r => r.type.includes('cloudtrail')); const hasLogGroups = resources.filter(r => r.type.includes('loggroup')).length > 0; return { id: 'audit-logging', name: 'Audit Logging', category: standard, severity: 'critical', status: hasCloudTrail && hasLogGroups ? 'pass' : 'fail', message: hasCloudTrail && hasLogGroups ? 'Audit logging is properly configured' : 'Audit logging is not fully configured', remediation: 'Enable CloudTrail and ensure all services log to CloudWatch' }; } function checkBackupEnabled(resources: any[], standard: string): ComplianceCheck { const databases = resources.filter(r => r.type.includes('rds') || r.type.includes('database')); const withoutBackup = databases.filter(r => !r.outputs?.backupRetentionPeriod || r.outputs.backupRetentionPeriod === 0 ); return { id: 'backup-enabled', name: 'Backup Configuration', category: standard, severity: 'high', status: withoutBackup.length === 0 ? 'pass' : 'fail', message: withoutBackup.length === 0 ? 'All databases have backup enabled' : `${withoutBackup.length} databases without backup`, resource: withoutBackup.map(r => r.id).join(', '), remediation: 'Enable automated backups with appropriate retention period' }; } function checkMonitoringEnabled(resources: any[], standard: string): ComplianceCheck { const hasMonitoring = resources.some(r => r.type.includes('cloudwatch') || r.type.includes('monitoring') || r.type.includes('prometheus') ); return { id: 'monitoring-enabled', name: 'Monitoring Configuration', category: standard, severity: 'medium', status: hasMonitoring ? 'pass' : 'fail', message: hasMonitoring ? 'Monitoring is configured' : 'No monitoring resources found', remediation: 'Implement comprehensive monitoring with alerts' }; } function checkAccessControls(resources: any[], standard: string): ComplianceCheck { const hasIAMRoles = resources.filter(r => r.type.includes('role')).length > 0; const hasSecurityGroups = resources.filter(r => r.type.includes('securitygroup')).length > 0; return { id: 'access-controls', name: 'Access Control', category: standard, severity: 'critical', status: hasIAMRoles && hasSecurityGroups ? 'pass' : 'fail', message: hasIAMRoles && hasSecurityGroups ? 'Access controls are properly configured' : 'Access controls need improvement', remediation: 'Implement least privilege access with proper IAM roles and security groups' }; } function checkNetworkSegmentation(resources: any[], standard: string): ComplianceCheck { const subnets = resources.filter(r => r.type.includes('subnet')); const hasPrivateSubnets = subnets.some(r => r.outputs?.mapPublicIpOnLaunch === false); const hasPublicSubnets = subnets.some(r => r.outputs?.mapPublicIpOnLaunch === true); return { id: 'network-segmentation', name: 'Network Segmentation', category: standard, severity: 'high', status: hasPrivateSubnets && hasPublicSubnets ? 'pass' : 'warning', message: hasPrivateSubnets && hasPublicSubnets ? 'Network is properly segmented' : 'Network segmentation could be improved', remediation: 'Implement proper network segmentation with public and private subnets' }; } function generateReport(report: ComplianceReport, format: 'json' | 'markdown' | 'html'): string { switch (format) { case 'json': return JSON.stringify(report, null, 2); case 'html': return generateHTMLReport(report); case 'markdown': default: return generateMarkdownReport(report); } } function generateMarkdownReport(report: ComplianceReport): string { let markdown = '# Compliance Report\n\n'; markdown += `**Stack:** ${report.stack}\n`; markdown += `**Generated:** ${report.timestamp}\n`; markdown += `**Standards:** ${report.standards.join(', ')}\n`; markdown += `**Compliance Score:** ${report.score}%\n`; markdown += `**Status:** ${report.compliant ? ' Compliant' : ' Non-Compliant'}\n\n`; // Summary by severity const bySeverity = { critical: report.checks.filter(c => c.severity === 'critical'), high: report.checks.filter(c => c.severity === 'high'), medium: report.checks.filter(c => c.severity === 'medium'), low: report.checks.filter(c => c.severity === 'low') }; markdown += '## Summary\n\n'; markdown += `- Critical: ${bySeverity.critical.filter(c => c.status === 'fail').length}/${bySeverity.critical.length}\n`; markdown += `- High: ${bySeverity.high.filter(c => c.status === 'fail').length}/${bySeverity.high.length}\n`; markdown += `- Medium: ${bySeverity.medium.filter(c => c.status === 'fail').length}/${bySeverity.medium.length}\n`; markdown += `- Low: ${bySeverity.low.filter(c => c.status === 'fail').length}/${bySeverity.low.length}\n\n`; // Detailed checks markdown += '## Detailed Checks\n\n'; for (const check of report.checks) { const icon = check.status === 'pass' ? '' : check.status === 'fail' ? '' : ''; markdown += `### ${icon} ${check.name}\n`; markdown += `- **Category:** ${check.category}\n`; markdown += `- **Severity:** ${check.severity}\n`; markdown += `- **Status:** ${check.status}\n`; markdown += `- **Message:** ${check.message}\n`; if (check.resource) { markdown += `- **Resources:** ${check.resource}\n`; } if (check.remediation && check.status === 'fail') { markdown += `- **Remediation:** ${check.remediation}\n`; } markdown += '\n'; } // Recommendations if (report.recommendations.length > 0) { markdown += '## Recommendations\n\n'; for (const rec of report.recommendations) { markdown += `- ${rec}\n`; } } return markdown; } function generateHTMLReport(report: ComplianceReport): string { // HTML report generation similar to drift report return ''; } function displaySummary(report: ComplianceReport): void { console.log('\n' + '='.repeat(50)); console.log('COMPLIANCE CHECK SUMMARY'); console.log('='.repeat(50)); console.log(`Stack: ${report.stack}`); console.log(`Standards: ${report.standards.join(', ')}`); console.log(`Score: ${report.score}%`); console.log(`Status: ${report.compliant ? ' COMPLIANT' : ' NON-COMPLIANT'}`); const failed = report.checks.filter(c => c.status === 'fail'); if (failed.length > 0) { console.log(`\nFailed Checks (${failed.length}):`); for (const check of failed) { console.log(` - [${check.severity.toUpperCase()}] ${check.name}: ${check.message}`); } } if (report.recommendations.length > 0) { console.log(`\nTop Recommendations:`); for (const rec of report.recommendations.slice(0, 5)) { console.log(` - ${rec}`); } } console.log('='.repeat(50)); } // Run the script if (require.main === module) { main().catch(console.error); }