apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-config
  namespace: governance-system
data:
  config.yaml: |
    services:
      authz:
        url: http://governance-policy-engine:8080
    
    bundles:
      governance:
        service: authz
        resource: "/v1/bundles/governance"
        polling:
          min_delay_seconds: 10
          max_delay_seconds: 20
    
    decision_logs:
      console: true
      reporting:
        min_delay_seconds: 5
        max_delay_seconds: 10
    
    status:
      console: true
      reporting:
        min_delay_seconds: 5
        max_delay_seconds: 10
    
    server:
      encoding:
        gzip:
          min_length: 1024
      
    plugins:
      health:
        bundle_activation_timeout_seconds: 30
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
  namespace: governance-system
  labels:
    app: opa
    component: policy-engine
spec:
  replicas: 3
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
        component: policy-engine
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8181"
        prometheus.io/path: "/metrics"
    spec:
      containers:
      - name: opa
        image: openpolicyagent/opa:latest-envoy
        args:
          - "run"
          - "--server"
          - "--config-file=/config/config.yaml"
          - "--addr=0.0.0.0:8181"
          - "--diagnostic-addr=0.0.0.0:8282"
          - "--set=status.console=true"
          - "--set=decision_logs.console=true"
          - "/policies"
        ports:
        - containerPort: 8181
          name: http
          protocol: TCP
        - containerPort: 8282
          name: diagnostic
          protocol: TCP
        volumeMounts:
        - name: opa-config
          mountPath: /config
          readOnly: true
        - name: opa-policies
          mountPath: /policies
          readOnly: true
        livenessProbe:
          httpGet:
            path: /health
            port: 8181
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health?bundle=true
            port: 8181
          initialDelaySeconds: 15
          periodSeconds: 5
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 3
        resources:
          requests:
            cpu: 200m
            memory: 256Mi
          limits:
            cpu: 1000m
            memory: 1Gi
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
          capabilities:
            drop:
            - ALL
      volumes:
      - name: opa-config
        configMap:
          name: opa-config
      - name: opa-policies
        configMap:
          name: opa-policies
      securityContext:
        fsGroup: 1000
      serviceAccountName: opa
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - opa
              topologyKey: kubernetes.io/hostname
---
apiVersion: v1
kind: Service
metadata:
  name: opa
  namespace: governance-system
  labels:
    app: opa
    component: policy-engine
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8181"
    prometheus.io/path: "/metrics"
spec:
  selector:
    app: opa
  ports:
  - name: http
    port: 8181
    targetPort: 8181
    protocol: TCP
  - name: diagnostic
    port: 8282
    targetPort: 8282
    protocol: TCP
  type: ClusterIP
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: opa
  namespace: governance-system
  labels:
    app: opa
    component: policy-engine
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: opa-reader
  labels:
    app: opa
    component: policy-engine
rules:
- apiGroups: [""]
  resources: ["services", "endpoints", "pods"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["extensions", "apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["networking.k8s.io"]
  resources: ["networkpolicies"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: opa-reader
  labels:
    app: opa
    component: policy-engine
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: opa-reader
subjects:
- kind: ServiceAccount
  name: opa
  namespace: governance-system
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: opa-pdb
  namespace: governance-system
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: opa
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policies
  namespace: governance-system
data:
  security.rego: |
    package governance.security
    
    default allow = false
    
    # Allow if no critical vulnerabilities
    allow {
        input.vulnerabilities.critical == 0
    }
    
    # Require approval for high vulnerabilities
    require_approval {
        input.vulnerabilities.high > 5
    }
    
    # Block critical vulnerabilities
    deny {
        input.vulnerabilities.critical > 0
    }
  
  compliance.rego: |
    package governance.compliance
    
    default allow = false
    
    # GDPR compliance check
    gdpr_compliant {
        input.data_classification != "personal"
    }
    
    gdpr_compliant {
        input.data_classification == "personal"
        input.encryption_enabled == true
        input.access_controls == true
    }
    
    # SOC2 compliance check
    soc2_compliant {
        input.access_logs_enabled == true
        input.authentication_required == true
        input.data_encrypted == true
    }
    
    allow {
        gdpr_compliant
        soc2_compliant
    }
  
  quality.rego: |
    package governance.quality
    
    default allow = false
    
    # Code quality gates
    allow {
        input.test_coverage >= 80
        input.security_scan_passed == true
        input.code_review_approved == true
    }
    
    # Warning for lower coverage
    warn {
        input.test_coverage >= 70
        input.test_coverage < 80
    }
    
    # Block for insufficient quality
    deny {
        input.test_coverage < 70
    }
    
    deny {
        input.security_scan_passed == false
    }