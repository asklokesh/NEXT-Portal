import { Command } from 'commander'; import chalk from 'chalk'; import { table } from 'table'; import inquirer from 'inquirer'; import ora from 'ora'; import { createBackstageClient } from '@backstage-idp/sdk-typescript'; import { ConfigManager } from '../config/config-manager'; import { Logger } from '../utils/logger'; import { formatOutput } from '../utils/formatters'; const logger = Logger.getInstance(); const configManager = ConfigManager.getInstance(); export const pluginsCommand = new Command('plugins') .description('Manage plugins') .alias('plugin'); // List plugins pluginsCommand .command('list') .alias('ls') .description('List available plugins') .option('-s, --search <query>', 'search plugins') .option('-c, --category <category>', 'filter by category') .option('-l, --limit <limit>', 'limit number of results', '50') .option('--installed-only', 'show only installed plugins') .option('--format <format>', 'output format (table|json|yaml)', 'table') .action(async (options) => { const spinner = ora('Loading plugins...').start(); try { const config = configManager.getAll(); const client = createBackstageClient(config); const params = { search: options.search, category: options.category === 'all' ? undefined : options.category, limit: parseInt(options.limit) }; const response = await client.plugins.list(params); spinner.stop(); let plugins = response.items; // Filter for installed only if (options.installedOnly) { plugins = plugins.filter(p => p.status === 'installed'); } if (plugins.length === 0) { logger.info('No plugins found matching criteria'); return; } // Format output const outputFormat = options.format || config.format; if (outputFormat === 'table') { const tableData = [ ['Name', 'Version', 'Status', 'Category', 'Author', 'Description'] ]; plugins.forEach(plugin => { const status = plugin.status === 'installed' ? chalk.green(' installed') : plugin.status === 'deprecated' ? chalk.red(' deprecated') : chalk.gray('available'); tableData.push([ chalk.bold(plugin.name), plugin.version, status, plugin.category || '-', plugin.author || '-', plugin.description?.substring(0, 50) + (plugin.description?.length > 50 ? '...' : '') || '-' ]); }); console.log(table(tableData, { header: { alignment: 'center', content: `Plugins (${plugins.length} of ${response.total})` } })); if (response.hasMore) { logger.info(`Showing ${plugins.length} of ${response.total} plugins. Use --limit to show more.`); } } else { console.log(formatOutput(plugins, outputFormat)); } } catch (error) { spinner.stop(); logger.error('Failed to list plugins:', error.message); process.exit(1); } }); // Get plugin details pluginsCommand .command('show <pluginId>') .description('Show plugin details') .option('--format <format>', 'output format (table|json|yaml)', 'table') .action(async (pluginId, options) => { const spinner = ora(`Loading plugin ${pluginId}...`).start(); try { const config = configManager.getAll(); const client = createBackstageClient(config); const plugin = await client.plugins.get(pluginId); spinner.stop(); const outputFormat = options.format || config.format; if (outputFormat === 'table') { console.log(chalk.bold.blue(`Plugin: ${plugin.name}`)); console.log(''); const details = [ ['ID', plugin.id], ['Name', plugin.name], ['Version', plugin.version], ['Status', plugin.status === 'installed' ? chalk.green(' Installed') : plugin.status === 'deprecated' ? chalk.red(' Deprecated') : chalk.gray('Available')], ['Category', plugin.category || '-'], ['Author', plugin.author || '-'], ['Description', plugin.description || '-'], ['Install Date', plugin.installDate ? new Date(plugin.installDate).toLocaleDateString() : '-'] ]; if (plugin.dependencies && plugin.dependencies.length > 0) { details.push(['Dependencies', plugin.dependencies.join(', ')]); } console.log(table(details, { columnCount: 2, columns: { 0: { width: 15, alignment: 'right' }, 1: { width: 50, wrapWord: true } } })); if (plugin.config && Object.keys(plugin.config).length > 0) { console.log('\nConfiguration:'); console.log(formatOutput(plugin.config, 'yaml')); } if (plugin.metadata && Object.keys(plugin.metadata).length > 0) { console.log('\nMetadata:'); console.log(formatOutput(plugin.metadata, 'yaml')); } } else { console.log(formatOutput(plugin, outputFormat)); } } catch (error) { spinner.stop(); logger.error(`Failed to get plugin ${pluginId}:`, error.message); process.exit(1); } }); // Install plugin pluginsCommand .command('install <pluginId>') .description('Install a plugin') .option('-v, --version <version>', 'specific version to install') .option('-c, --config <config>', 'configuration as JSON string') .option('-f, --config-file <file>', 'configuration file path') .option('-y, --yes', 'skip confirmation prompts') .action(async (pluginId, options) => { try { const config = configManager.getAll(); const client = createBackstageClient(config); // Get plugin details first let plugin; try { plugin = await client.plugins.get(pluginId); } catch (error) { logger.error(`Plugin ${pluginId} not found`); process.exit(1); } // Check if already installed if (plugin.status === 'installed') { logger.warn(`Plugin ${pluginId} is already installed`); if (!options.yes) { const { confirm } = await inquirer.prompt([{ type: 'confirm', name: 'confirm', message: 'Do you want to reinstall it?', default: false }]); if (!confirm) { logger.info('Installation cancelled'); return; } } } // Parse configuration let pluginConfig = {}; if (options.config) { try { pluginConfig = JSON.parse(options.config); } catch (error) { logger.error('Invalid JSON configuration:', options.config); process.exit(1); } } else if (options.configFile) { const fs = require('fs'); const yaml = require('js-yaml'); try { const configContent = fs.readFileSync(options.configFile, 'utf8'); pluginConfig = options.configFile.endsWith('.json') ? JSON.parse(configContent) : yaml.load(configContent); } catch (error) { logger.error(`Failed to read configuration file ${options.configFile}:`, error.message); process.exit(1); } } // Confirm installation if (!options.yes) { console.log(chalk.bold(`Installing plugin: ${plugin.name}`)); console.log(`Version: ${options.version || plugin.version}`); console.log(`Category: ${plugin.category || 'Unknown'}`); console.log(`Author: ${plugin.author || 'Unknown'}`); if (plugin.dependencies && plugin.dependencies.length > 0) { console.log(`Dependencies: ${plugin.dependencies.join(', ')}`); } const { confirm } = await inquirer.prompt([{ type: 'confirm', name: 'confirm', message: 'Continue with installation?', default: true }]); if (!confirm) { logger.info('Installation cancelled'); return; } } // Install plugin const spinner = ora(`Installing plugin ${pluginId}...`).start(); const installRequest = { pluginId, version: options.version, config: Object.keys(pluginConfig).length > 0 ? pluginConfig : undefined }; const result = await client.plugins.install(installRequest); spinner.stop(); if (result.success) { logger.success(` Plugin ${pluginId} installed successfully`); if (result.installationId) { logger.info(`Installation ID: ${result.installationId}`); } } else { logger.error(`Failed to install plugin ${pluginId}`); process.exit(1); } } catch (error) { logger.error(`Failed to install plugin ${pluginId}:`, error.message); process.exit(1); } }); // Uninstall plugin pluginsCommand .command('uninstall <pluginId>') .alias('remove') .description('Uninstall a plugin') .option('-y, --yes', 'skip confirmation prompts') .action(async (pluginId, options) => { try { const config = configManager.getAll(); const client = createBackstageClient(config); // Check if plugin is installed let plugin; try { plugin = await client.plugins.get(pluginId); } catch (error) { logger.error(`Plugin ${pluginId} not found`); process.exit(1); } if (plugin.status !== 'installed') { logger.error(`Plugin ${pluginId} is not installed`); process.exit(1); } // Confirm uninstallation if (!options.yes) { console.log(chalk.bold.red(`Uninstalling plugin: ${plugin.name}`)); console.log(`This will remove the plugin and its configuration.`); const { confirm } = await inquirer.prompt([{ type: 'confirm', name: 'confirm', message: 'Are you sure you want to uninstall this plugin?', default: false }]); if (!confirm) { logger.info('Uninstallation cancelled'); return; } } // Uninstall plugin const spinner = ora(`Uninstalling plugin ${pluginId}...`).start(); await client.plugins.uninstall(pluginId); spinner.stop(); logger.success(` Plugin ${pluginId} uninstalled successfully`); } catch (error) { logger.error(`Failed to uninstall plugin ${pluginId}:`, error.message); process.exit(1); } }); // Search plugins pluginsCommand .command('search <query>') .description('Search for plugins') .option('-c, --category <category>', 'filter by category') .option('-l, --limit <limit>', 'limit number of results', '20') .option('--format <format>', 'output format (table|json|yaml)', 'table') .action(async (query, options) => { const spinner = ora(`Searching for "${query}"...`).start(); try { const config = configManager.getAll(); const client = createBackstageClient(config); const response = await client.plugins.search(query, options.category, { limit: parseInt(options.limit) }); spinner.stop(); if (response.items.length === 0) { logger.info(`No plugins found for query: ${query}`); return; } const outputFormat = options.format || config.format; if (outputFormat === 'table') { const tableData = [ ['Name', 'Version', 'Status', 'Category', 'Description'] ]; response.items.forEach(plugin => { const status = plugin.status === 'installed' ? chalk.green('') : plugin.status === 'deprecated' ? chalk.red('') : chalk.gray('-'); tableData.push([ chalk.bold(plugin.name), plugin.version, status, plugin.category || '-', plugin.description?.substring(0, 60) + (plugin.description?.length > 60 ? '...' : '') || '-' ]); }); console.log(table(tableData, { header: { alignment: 'center', content: `Search Results for "${query}" (${response.items.length} found)` } })); } else { console.log(formatOutput(response.items, outputFormat)); } } catch (error) { spinner.stop(); logger.error(`Search failed:`, error.message); process.exit(1); } });