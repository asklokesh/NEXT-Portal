# Infrastructure as Code and Deployment Automation # Terraform, Helm, ArgoCD, and CI/CD Pipeline Integration --- # ArgoCD Application for GitOps Deployment apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: saas-idp-global-infrastructure namespace: argocd labels: app: saas-idp component: gitops annotations: argocd.argoproj.io/sync-wave: "0" spec: project: saas-idp source: repoURL: https://github.com/your-org/saas-idp-infrastructure targetRevision: main path: k8s/overlays/production kustomize: namePrefix: prod- nameSuffix: -v1 images: - name: saas-idp-app newTag: latest patchesStrategicMerge: - |- apiVersion: apps/v1 kind: Deployment metadata: name: saas-idp-app spec: template: metadata: annotations: deployment.timestamp: "2024-01-01T00:00:00Z" destination: server: https://kubernetes.default.svc namespace: saas-idp-production syncPolicy: automated: prune: true selfHeal: true allowEmpty: false syncOptions: - CreateNamespace=true - PrunePropagationPolicy=foreground - PruneLast=true - ApplyOutOfSyncOnly=true retry: limit: 5 backoff: duration: 5s factor: 2 maxDuration: 3m revisionHistoryLimit: 10 ignoreDifferences: - group: apps kind: Deployment jsonPointers: - /spec/replicas - group: argoproj.io kind: Rollout jsonPointers: - /spec/replicas --- # Multi-Region ArgoCD ApplicationSet apiVersion: argoproj.io/v1alpha1 kind: ApplicationSet metadata: name: saas-idp-multi-region namespace: argocd labels: app: saas-idp component: multi-region-gitops spec: generators: - clusters: selector: matchLabels: environment: production platform: saas-idp - list: elements: - region: us-east-1 cluster: us-east-prod replicas: "50" resources: "large" db_endpoint: "postgres-primary-us-east" - region: eu-west-1 cluster: eu-west-prod replicas: "30" resources: "medium" db_endpoint: "postgres-replica-eu-west" - region: ap-southeast-1 cluster: ap-southeast-prod replicas: "20" resources: "medium" db_endpoint: "postgres-replica-ap-southeast" template: metadata: name: 'saas-idp-{{region}}' labels: region: '{{region}}' environment: production spec: project: saas-idp source: repoURL: https://github.com/your-org/saas-idp-infrastructure targetRevision: main path: k8s/overlays/{{region}} helm: valueFiles: - values-{{region}}.yaml parameters: - name: region value: '{{region}}' - name: replicas value: '{{replicas}}' - name: resources value: '{{resources}}' - name: database.endpoint value: '{{db_endpoint}}' destination: server: '{{server}}' namespace: saas-idp-production syncPolicy: automated: prune: true selfHeal: true syncOptions: - CreateNamespace=true retry: limit: 3 backoff: duration: 5s factor: 2 maxDuration: 1m --- # Helm Chart Values for Different Environments apiVersion: v1 kind: ConfigMap metadata: name: helm-values-global namespace: saas-idp-production labels: app: saas-idp component: helm-config data: values-production.yaml: | global: environment: production domain: saas-idp.com tls: enabled: true issuer: letsencrypt-prod monitoring: enabled: true prometheus: true grafana: true jaeger: true saas-idp: image: repository: saas-idp/app tag: "v1.0.0" pullPolicy: Always replicaCount: 10 resources: requests: memory: "512Mi" cpu: "250m" limits: memory: "2Gi" cpu: "1000m" autoscaling: enabled: true minReplicas: 10 maxReplicas: 1000 targetCPUUtilizationPercentage: 70 targetMemoryUtilizationPercentage: 80 service: type: ClusterIP port: 4400 annotations: prometheus.io/scrape: "true" prometheus.io/port: "9090" ingress: enabled: true className: nginx annotations: cert-manager.io/cluster-issuer: letsencrypt-prod nginx.ingress.kubernetes.io/ssl-redirect: "true" nginx.ingress.kubernetes.io/rate-limit: "1000" hosts: - host: api.saas-idp.com paths: - path: / pathType: Prefix tls: - secretName: saas-idp-tls hosts: - api.saas-idp.com postgresql: enabled: false # Using external managed database external: enabled: true host: postgres-primary-us-east port: 5432 database: saasidp existingSecret: postgres-credentials userKey: username passwordKey: password redis: enabled: false # Using Redis cluster external: enabled: true host: redis-cluster-service port: 6379 existingSecret: redis-credentials passwordKey: password monitoring: serviceMonitor: enabled: true interval: 30s path: /metrics labels: release: prometheus grafana: dashboards: enabled: true label: grafana_dashboard alerts: enabled: true rules: highErrorRate: 0.05 highLatency: 1000 lowAvailability: 99.9 values-us-east-1.yaml: | global: region: us-east-1 availability_zones: - us-east-1a - us-east-1b - us-east-1c saas-idp: replicaCount: 50 resources: requests: memory: "1Gi" cpu: "500m" limits: memory: "4Gi" cpu: "2000m" nodeSelector: topology.kubernetes.io/region: us-east-1 node-type: application tolerations: - key: "region" operator: "Equal" value: "us-east-1" effect: "NoSchedule" affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: topology.kubernetes.io/region operator: In values: - us-east-1 podAntiAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 100 podAffinityTerm: labelSelector: matchExpressions: - key: app operator: In values: - saas-idp topologyKey: kubernetes.io/hostname postgresql: external: host: postgres-primary-us-east.rds.amazonaws.com readonly_host: postgres-primary-us-east-ro.rds.amazonaws.com redis: external: host: redis-us-east.cache.amazonaws.com storage: class: gp3-encrypted size: 100Gi values-eu-west-1.yaml: | global: region: eu-west-1 availability_zones: - eu-west-1a - eu-west-1b - eu-west-1c saas-idp: replicaCount: 30 nodeSelector: topology.kubernetes.io/region: eu-west-1 node-type: application tolerations: - key: "region" operator: "Equal" value: "eu-west-1" effect: "NoSchedule" postgresql: external: host: postgres-replica-eu-west.rds.amazonaws.com readonly_host: postgres-replica-eu-west-ro.rds.amazonaws.com redis: external: host: redis-eu-west.cache.amazonaws.com ingress: hosts: - host: eu-api.saas-idp.com paths: - path: / pathType: Prefix values-ap-southeast-1.yaml: | global: region: ap-southeast-1 availability_zones: - ap-southeast-1a - ap-southeast-1b - ap-southeast-1c saas-idp: replicaCount: 20 nodeSelector: topology.kubernetes.io/region: ap-southeast-1 node-type: application tolerations: - key: "region" operator: "Equal" value: "ap-southeast-1" effect: "NoSchedule" postgresql: external: host: postgres-replica-ap-southeast.rds.amazonaws.com readonly_host: postgres-replica-ap-southeast-ro.rds.amazonaws.com redis: external: host: redis-ap-southeast.cache.amazonaws.com ingress: hosts: - host: ap-api.saas-idp.com paths: - path: / pathType: Prefix --- # Kustomization Configuration apiVersion: v1 kind: ConfigMap metadata: name: kustomization-config namespace: saas-idp-production labels: app: saas-idp component: kustomization data: kustomization.yaml: | apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization metadata: name: saas-idp-production annotations: config.kubernetes.io/local-config: "true" namespace: saas-idp-production namePrefix: prod- nameSuffix: -v1 commonLabels: app: saas-idp environment: production version: v1.0.0 commonAnnotations: managed-by: kustomize deployment-timestamp: "2024-01-01T00:00:00Z" resources: - global-infrastructure.yaml - cdn-edge-infrastructure.yaml - multi-region-database.yaml - auto-scaling-policies.yaml - global-load-balancing.yaml - global-monitoring-observability.yaml - performance-optimization.yaml - cost-optimization.yaml configMapGenerator: - name: app-config files: - app-config.yaml - database-config.yaml - cache-config.yaml options: disableNameSuffixHash: true secretGenerator: - name: app-secrets files: - jwt-secret.txt - database-password.txt - redis-password.txt type: Opaque options: disableNameSuffixHash: true images: - name: saas-idp/app newTag: v1.0.0 - name: saas-idp/cache-service newTag: v1.0.0 - name: saas-idp/query-optimizer newTag: v1.0.0 patchesStrategicMerge: - |- apiVersion: apps/v1 kind: Deployment metadata: name: saas-idp-app spec: template: spec: containers: - name: saas-idp env: - name: ENVIRONMENT value: "production" - name: LOG_LEVEL value: "info" - name: METRICS_ENABLED value: "true" patchesJson6902: - target: version: v1 kind: Service name: saas-idp-app patch: |- - op: add path: /metadata/annotations/service.beta.kubernetes.io~1aws-load-balancer-type value: nlb - op: add path: /metadata/annotations/service.beta.kubernetes.io~1aws-load-balancer-cross-zone-load-balancing-enabled value: "true" replicas: - name: saas-idp-app count: 50 - name: redis-cluster count: 6 - name: pgbouncer count: 5 overlays-production.yaml: | # Production overlay configuration apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization namespace: saas-idp-production resources: - ../../base patchesStrategicMerge: - production-patches.yaml configMapGenerator: - name: production-config literals: - DATABASE_POOL_SIZE=50 - REDIS_CLUSTER_NODES=6 - LOG_LEVEL=info - METRICS_ENABLED=true - PROFILING_ENABLED=false - DEBUG_MODE=false behavior: merge images: - name: saas-idp/app newTag: v1.0.0 replicas: - name: saas-idp-app count: 50 --- # Terraform Configuration as ConfigMap apiVersion: v1 kind: ConfigMap metadata: name: terraform-config namespace: saas-idp-production labels: app: saas-idp component: terraform data: main.tf: | # Terraform configuration for SaaS IDP Global Infrastructure terraform { required_version = ">= 1.0" required_providers { aws = { source = "hashicorp/aws" version = "~> 5.0" } kubernetes = { source = "hashicorp/kubernetes" version = "~> 2.20" } helm = { source = "hashicorp/helm" version = "~> 2.10" } kubectl = { source = "gavinbunney/kubectl" version = ">= 1.7.0" } } backend "s3" { bucket = "saas-idp-terraform-state" key = "global-infrastructure/terraform.tfstate" region = "us-east-1" encrypt = true dynamodb_table = "saas-idp-terraform-locks" assume_role { role_arn = "arn:aws:iam::ACCOUNT-ID:role/TerraformRole" } } } # Data sources data "aws_availability_zones" "available" { state = "available" } data "aws_caller_identity" "current" {} data "aws_region" "current" {} # Local values locals { name = "saas-idp" environment = "production" region = data.aws_region.current.name availability_zones = slice(data.aws_availability_zones.available.names, 0, 3) tags = { Environment = local.environment Project = local.name ManagedBy = "terraform" Repository = "saas-idp-infrastructure" } } # VPC Module module "vpc" { source = "terraform-aws-modules/vpc/aws" version = "~> 5.0" name = "${local.name}-vpc" cidr = var.vpc_cidr azs = local.availability_zones private_subnets = var.private_subnets public_subnets = var.public_subnets database_subnets = var.database_subnets enable_nat_gateway = true enable_vpn_gateway = false enable_dns_hostnames = true enable_dns_support = true enable_flow_log = true create_flow_log_cloudwatch_iam_role = true create_flow_log_cloudwatch_log_group = true tags = local.tags } # EKS Cluster module "eks" { source = "terraform-aws-modules/eks/aws" version = "~> 19.0" cluster_name = "${local.name}-cluster" cluster_version = var.kubernetes_version vpc_id = module.vpc.vpc_id subnet_ids = module.vpc.private_subnets cluster_endpoint_private_access = true cluster_endpoint_public_access = true cluster_endpoint_public_access_cidrs = var.cluster_endpoint_public_access_cidrs cluster_addons = { coredns = { most_recent = true } kube-proxy = { most_recent = true } vpc-cni = { most_recent = true } aws-ebs-csi-driver = { most_recent = true } } cluster_encryption_config = [ { provider_key_arn = aws_kms_key.eks.arn resources = ["secrets"] } ] # EKS Managed Node Groups eks_managed_node_groups = { application_nodes = { name = "application" instance_types = ["c5.large", "c5.xlarge", "c5.2xlarge"] capacity_type = "ON_DEMAND" min_size = 10 max_size = 500 desired_size = 20 labels = { Environment = local.environment NodeGroup = "application" WorkloadType = "application" } taints = [ { key = "workload-class" value = "application" effect = "NO_SCHEDULE" } ] update_config = { max_unavailable_percentage = 33 } } database_nodes = { name = "database" instance_types = ["r5.large", "r5.xlarge", "r5.2xlarge"] capacity_type = "ON_DEMAND" min_size = 5 max_size = 50 desired_size = 10 labels = { Environment = local.environment NodeGroup = "database" WorkloadType = "database" } taints = [ { key = "workload-class" value = "database" effect = "NO_SCHEDULE" } ] } monitoring_nodes = { name = "monitoring" instance_types = ["m5.large", "m5.xlarge"] capacity_type = "ON_DEMAND" min_size = 3 max_size = 20 desired_size = 5 labels = { Environment = local.environment NodeGroup = "monitoring" WorkloadType = "monitoring" } } } # Fargate Profiles fargate_profiles = { karpenter = { name = "karpenter" selectors = [ { namespace = "karpenter" } ] } system = { name = "system" selectors = [ { namespace = "kube-system" }, { namespace = "argocd" } ] } } tags = local.tags } # RDS PostgreSQL Primary module "rds_primary" { source = "terraform-aws-modules/rds/aws" version = "~> 6.0" identifier = "${local.name}-primary" engine = "postgres" engine_version = "15.4" family = "postgres15" major_engine_version = "15" instance_class = "db.r5.2xlarge" allocated_storage = 1000 max_allocated_storage = 10000 storage_type = "gp3" storage_encrypted = true kms_key_id = aws_kms_key.rds.arn db_name = "saasidp" username = var.db_username port = 5432 manage_master_user_password = true master_user_secret_kms_key_id = aws_kms_key.rds.arn multi_az = true publicly_accessible = false vpc_security_group_ids = [aws_security_group.rds.id] db_subnet_group_name = module.vpc.database_subnet_group backup_retention_period = 30 backup_window = "03:00-04:00" maintenance_window = "Sun:04:00-Sun:05:00" deletion_protection = true skip_final_snapshot = false final_snapshot_identifier = "${local.name}-primary-final-snapshot-${formatdate("YYYY-MM-DD-hhmm", timestamp())}" performance_insights_enabled = true performance_insights_kms_key_id = aws_kms_key.rds.arn performance_insights_retention_period = 7 monitoring_interval = 60 monitoring_role_arn = aws_iam_role.rds_monitoring.arn enabled_cloudwatch_logs_exports = ["postgresql", "upgrade"] tags = merge(local.tags, { Role = "primary" }) } # ElastiCache Redis Cluster module "redis_cluster" { source = "terraform-aws-modules/elasticache/aws" version = "~> 1.0" replication_group_id = "${local.name}-redis" description = "Redis cluster for SaaS IDP" node_type = "cache.r6g.large" port = 6379 parameter_group_name = aws_elasticache_parameter_group.redis.name num_cache_clusters = 3 automatic_failover_enabled = true multi_az_enabled = true subnet_group_name = module.vpc.elasticache_subnet_group_name security_group_ids = [aws_security_group.redis.id] at_rest_encryption_enabled = true transit_encryption_enabled = true auth_token_enabled = true auth_token = var.redis_auth_token kms_key_id = aws_kms_key.redis.arn log_delivery_configuration = [ { destination = aws_cloudwatch_log_group.redis_slow.name destination_type = "cloudwatch-logs" log_format = "text" log_type = "slow-log" } ] tags = local.tags } variables.tf: | # Terraform Variables variable "vpc_cidr" { description = "CIDR block for VPC" type = string default = "10.0.0.0/16" } variable "private_subnets" { description = "Private subnets for VPC" type = list(string) default = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"] } variable "public_subnets" { description = "Public subnets for VPC" type = list(string) default = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"] } variable "database_subnets" { description = "Database subnets for VPC" type = list(string) default = ["10.0.201.0/24", "10.0.202.0/24", "10.0.203.0/24"] } variable "kubernetes_version" { description = "Kubernetes version for EKS cluster" type = string default = "1.27" } variable "cluster_endpoint_public_access_cidrs" { description = "CIDR blocks that can access the EKS cluster endpoint" type = list(string) default = ["0.0.0.0/0"] } variable "db_username" { description = "Username for RDS instance" type = string default = "saasidp_admin" sensitive = true } variable "redis_auth_token" { description = "Auth token for Redis cluster" type = string sensitive = true } outputs.tf: | # Terraform Outputs output "vpc_id" { description = "ID of the VPC" value = module.vpc.vpc_id } output "vpc_cidr_block" { description = "CIDR block of the VPC" value = module.vpc.vpc_cidr_block } output "private_subnets" { description = "List of private subnet IDs" value = module.vpc.private_subnets } output "public_subnets" { description = "List of public subnet IDs" value = module.vpc.public_subnets } output "database_subnets" { description = "List of database subnet IDs" value = module.vpc.database_subnets } output "eks_cluster_id" { description = "The name/id of the EKS cluster" value = module.eks.cluster_id } output "eks_cluster_arn" { description = "The Amazon Resource Name (ARN) of the cluster" value = module.eks.cluster_arn } output "eks_cluster_endpoint" { description = "Endpoint for EKS control plane" value = module.eks.cluster_endpoint } output "eks_cluster_security_group_id" { description = "Security group ID attached to the EKS cluster" value = module.eks.cluster_security_group_id } output "eks_node_groups" { description = "EKS node groups" value = module.eks.eks_managed_node_groups } output "rds_instance_id" { description = "The RDS instance ID" value = module.rds_primary.db_instance_id } output "rds_instance_endpoint" { description = "The RDS instance endpoint" value = module.rds_primary.db_instance_endpoint sensitive = true } output "rds_instance_port" { description = "The RDS instance port" value = module.rds_primary.db_instance_port } output "redis_cluster_id" { description = "The Redis cluster ID" value = module.redis_cluster.replication_group_id } output "redis_primary_endpoint" { description = "The Redis primary endpoint" value = module.redis_cluster.primary_endpoint_address sensitive = true } output "redis_reader_endpoint" { description = "The Redis reader endpoint" value = module.redis_cluster.reader_endpoint_address sensitive = true } --- # CI/CD Pipeline Configuration apiVersion: tekton.dev/v1beta1 kind: Pipeline metadata: name: saas-idp-deploy-pipeline namespace: saas-idp-production labels: app: saas-idp component: cicd spec: description: | This pipeline deploys the SaaS IDP application to production with proper validation, testing, and rollout strategies. params: - name: git-url type: string description: The git repository URL to clone from - name: git-revision type: string description: The git revision to clone default: main - name: image-reference type: string description: The container image reference to build and deploy - name: target-environment type: string description: Target environment for deployment default: production - name: region type: string description: Target region for deployment default: us-east-1 workspaces: - name: shared-data description: Shared workspace for pipeline - name: git-credentials description: Git credentials optional: true tasks: - name: fetch-source taskRef: name: git-clone kind: ClusterTask workspaces: - name: output workspace: shared-data - name: basic-auth workspace: git-credentials params: - name: url value: $(params.git-url) - name: revision value: $(params.git-revision) - name: deleteExisting value: "true" - name: security-scan taskRef: name: security-scan runAfter: ["fetch-source"] workspaces: - name: source workspace: shared-data params: - name: image value: $(params.image-reference) - name: lint-and-test taskRef: name: lint-test runAfter: ["fetch-source"] workspaces: - name: source workspace: shared-data - name: build-image taskRef: name: buildah kind: ClusterTask runAfter: ["security-scan", "lint-and-test"] workspaces: - name: source workspace: shared-data params: - name: IMAGE value: $(params.image-reference) - name: DOCKERFILE value: ./Dockerfile.production - name: CONTEXT value: . - name: FORMAT value: oci - name: BUILD_EXTRA_ARGS value: | --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') --build-arg VCS_REF=$(params.git-revision) --build-arg VERSION=$(params.git-revision) - name: image-scan taskRef: name: image-security-scan runAfter: ["build-image"] params: - name: image value: $(params.image-reference) - name: update-manifests taskRef: name: update-k8s-manifests runAfter: ["image-scan"] workspaces: - name: source workspace: shared-data params: - name: image value: $(params.image-reference) - name: environment value: $(params.target-environment) - name: region value: $(params.region) - name: deploy-canary taskRef: name: argo-rollouts-deploy runAfter: ["update-manifests"] params: - name: deployment-name value: saas-idp-app - name: namespace value: saas-idp-production - name: strategy value: canary - name: canary-percentage value: "10" - name: integration-tests taskRef: name: integration-tests runAfter: ["deploy-canary"] params: - name: environment value: $(params.target-environment) - name: region value: $(params.region) - name: test-suite value: smoke-tests - name: performance-tests taskRef: name: performance-tests runAfter: ["integration-tests"] params: - name: environment value: $(params.target-environment) - name: load-pattern value: production-baseline - name: duration value: 5m - name: promote-canary taskRef: name: argo-rollouts-promote runAfter: ["performance-tests"] when: - input: "$(tasks.performance-tests.results.success)" operator: in values: ["true"] params: - name: deployment-name value: saas-idp-app - name: namespace value: saas-idp-production - name: health-check taskRef: name: health-check runAfter: ["promote-canary"] params: - name: environment value: $(params.target-environment) - name: region value: $(params.region) - name: timeout value: 300s - name: notify-deployment taskRef: name: notification runAfter: ["health-check"] params: - name: webhook-url value: "https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK" - name: message value: | SaaS IDP deployment completed successfully! Environment: $(params.target-environment) Region: $(params.region) Image: $(params.image-reference) Git Revision: $(params.git-revision) finally: - name: cleanup taskRef: name: cleanup-resources params: - name: environment value: $(params.target-environment) --- # Infrastructure Deployment Job apiVersion: batch/v1 kind: Job metadata: name: infrastructure-deployment namespace: saas-idp-production labels: app: saas-idp component: infrastructure-deployment annotations: argocd.argoproj.io/sync-wave: "-1" spec: template: metadata: labels: app: saas-idp component: infrastructure-deployment spec: restartPolicy: OnFailure serviceAccountName: infrastructure-deployment-sa securityContext: runAsNonRoot: true runAsUser: 1001 fsGroup: 1001 containers: - name: terraform image: hashicorp/terraform:1.6 command: - /bin/sh - -c args: - | set -e echo "Starting infrastructure deployment..." # Initialize Terraform terraform init -backend-config="bucket=${TF_STATE_BUCKET}" \ -backend-config="key=${TF_STATE_KEY}" \ -backend-config="region=${AWS_REGION}" # Plan infrastructure changes terraform plan -out=tfplan \ -var="vpc_cidr=${VPC_CIDR}" \ -var="kubernetes_version=${K8S_VERSION}" \ -var="db_username=${DB_USERNAME}" # Apply infrastructure changes terraform apply -auto-approve tfplan # Output important values terraform output -json > /tmp/terraform-outputs.json echo "Infrastructure deployment completed successfully!" env: - name: TF_STATE_BUCKET value: "saas-idp-terraform-state" - name: TF_STATE_KEY value: "global-infrastructure/terraform.tfstate" - name: AWS_REGION value: "us-east-1" - name: VPC_CIDR value: "10.0.0.0/16" - name: K8S_VERSION value: "1.27" - name: DB_USERNAME valueFrom: secretKeyRef: name: terraform-credentials key: db-username envFrom: - secretRef: name: aws-credentials - secretRef: name: terraform-credentials volumeMounts: - name: terraform-config mountPath: /terraform workingDir: /terraform resources: requests: memory: "512Mi" cpu: "500m" limits: memory: "2Gi" cpu: "1000m" securityContext: allowPrivilegeEscalation: false capabilities: drop: - ALL volumes: - name: terraform-config configMap: name: terraform-config --- # Service Account for Infrastructure Deployment apiVersion: v1 kind: ServiceAccount metadata: name: infrastructure-deployment-sa namespace: saas-idp-production labels: app: saas-idp component: infrastructure-deployment annotations: eks.amazonaws.com/role-arn: "arn:aws:iam::ACCOUNT-ID:role/InfrastructureDeploymentRole" --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: infrastructure-deployment rules: - apiGroups: ["*"] resources: ["*"] verbs: ["*"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: infrastructure-deployment roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: infrastructure-deployment subjects: - kind: ServiceAccount name: infrastructure-deployment-sa namespace: saas-idp-production