# Cost Optimization and Resource Management # Spot instances, reserved capacity, resource rightsizing, and multi-cloud cost comparison --- # Karpenter Node Pool for Cost-Optimized Spot Instances apiVersion: karpenter.sh/v1beta1 kind: NodePool metadata: name: cost-optimized-spot namespace: saas-idp-production labels: app: saas-idp component: cost-optimization spec: # Template defines the node properties template: metadata: labels: node-type: cost-optimized capacity-type: spot workload-class: fault-tolerant spec: # Requirements define instance selection criteria requirements: - key: karpenter.sh/capacity-type operator: In values: ["spot"] - key: node.kubernetes.io/instance-type operator: In values: - c5.large - c5.xlarge - c5.2xlarge - c5.4xlarge - m5.large - m5.xlarge - m5.2xlarge - m5.4xlarge - r5.large - r5.xlarge - r5.2xlarge - t3.medium - t3.large - t3.xlarge - key: kubernetes.io/arch operator: In values: ["amd64"] - key: karpenter.k8s.aws/instance-family operator: NotIn values: ["g", "p", "x"] # Exclude GPU/high-performance instances # Node class reference nodeClassRef: apiVersion: karpenter.k8s.aws/v1beta1 kind: EC2NodeClass name: cost-optimized-nodeclass # Taints to ensure only cost-tolerant workloads schedule here taints: - key: "spot-instance" value: "true" effect: NoSchedule - key: "cost-optimized" value: "true" effect: NoSchedule # Limits define the maximum resource consumption limits: cpu: "10000" memory: "40000Gi" # Disruption settings for graceful spot instance handling disruption: consolidationPolicy: WhenUnderutilized consolidateAfter: 30s expireAfter: 2h # Rotate nodes every 2 hours for cost optimization --- # EC2 Node Class for Cost-Optimized Instances apiVersion: karpenter.k8s.aws/v1beta1 kind: EC2NodeClass metadata: name: cost-optimized-nodeclass namespace: saas-idp-production labels: app: saas-idp component: cost-optimization spec: # AMI selection amiFamily: AL2 amiSelectorTerms: - id: ami-0abcdef1234567890 # Specify cost-optimized AMI - name: "amazon-eks-node-1.27-*" # Instance profile instanceProfile: "KarpenterNodeInstanceProfile-saas-idp" # Subnet selection for multi-AZ spot distribution subnetSelectorTerms: - tags: karpenter.sh/discovery: "saas-idp-cluster" Type: Private # Security group selection securityGroupSelectorTerms: - tags: karpenter.sh/discovery: "saas-idp-cluster" # Instance store configuration instanceStoreConfiguration: policy: RAID0 # User data for cost optimization userData: | #!/bin/bash /etc/eks/bootstrap.sh saas-idp-cluster --container-runtime containerd # Configure instance for cost optimization echo 'net.core.rmem_max = 134217728' >> /etc/sysctl.conf echo 'net.core.wmem_max = 134217728' >> /etc/sysctl.conf sysctl -p # Enable CloudWatch detailed monitoring for cost tracking yq eval '.agent.metrics_collection_interval = 60' -i /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json # Block device mappings for cost-optimized storage blockDeviceMappings: - deviceName: /dev/xvda ebs: volumeSize: 50Gi volumeType: gp3 iops: 3000 throughput: 125 deleteOnTermination: true encrypted: true # Tags for cost tracking tags: CostCenter: "platform-engineering" Environment: "production" Project: "saas-idp" NodeType: "cost-optimized" CapacityType: "spot" --- # Reserved Capacity Node Pool apiVersion: karpenter.sh/v1beta1 kind: NodePool metadata: name: reserved-capacity namespace: saas-idp-production labels: app: saas-idp component: reserved-capacity spec: template: metadata: labels: node-type: reserved capacity-type: on-demand workload-class: critical spec: requirements: - key: karpenter.sh/capacity-type operator: In values: ["on-demand"] - key: node.kubernetes.io/instance-type operator: In values: - c5.large # Reserved instances - c5.xlarge # Reserved instances - m5.large # Reserved instances - m5.xlarge # Reserved instances - key: kubernetes.io/arch operator: In values: ["amd64"] nodeClassRef: apiVersion: karpenter.k8s.aws/v1beta1 kind: EC2NodeClass name: reserved-capacity-nodeclass taints: - key: "reserved-instance" value: "true" effect: NoSchedule - key: "critical-workload" value: "true" effect: NoSchedule limits: cpu: "5000" memory: "20000Gi" disruption: consolidationPolicy: WhenEmpty consolidateAfter: 300s expireAfter: 24h # Keep reserved instances longer --- # Cost Optimization Controller apiVersion: apps/v1 kind: Deployment metadata: name: cost-optimization-controller namespace: saas-idp-production labels: app: saas-idp component: cost-optimization-controller spec: replicas: 2 strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 1 maxSurge: 1 selector: matchLabels: app: saas-idp component: cost-optimization-controller template: metadata: labels: app: saas-idp component: cost-optimization-controller annotations: prometheus.io/scrape: "true" prometheus.io/port: "8080" prometheus.io/path: "/metrics" spec: serviceAccountName: cost-optimization-sa securityContext: runAsNonRoot: true runAsUser: 1001 fsGroup: 1001 containers: - name: controller image: saas-idp/cost-optimization-controller:latest ports: - name: http containerPort: 8080 - name: metrics containerPort: 9090 env: - name: AWS_REGION value: "us-east-1" - name: CLUSTER_NAME value: "saas-idp-cluster" - name: COST_ANALYSIS_INTERVAL value: "1h" - name: RIGHTSIZING_INTERVAL value: "24h" - name: SPOT_INTERRUPTION_HANDLER value: "true" - name: RESERVED_INSTANCE_OPTIMIZER value: "true" - name: IDLE_RESOURCE_DETECTOR value: "true" envFrom: - configMapRef: name: cost-optimization-config - secretRef: name: aws-credentials resources: requests: memory: "512Mi" cpu: "200m" limits: memory: "2Gi" cpu: "1000m" livenessProbe: httpGet: path: /health port: http initialDelaySeconds: 30 periodSeconds: 10 readinessProbe: httpGet: path: /ready port: http initialDelaySeconds: 5 periodSeconds: 5 securityContext: allowPrivilegeEscalation: false capabilities: drop: - ALL --- apiVersion: v1 kind: ConfigMap metadata: name: cost-optimization-config namespace: saas-idp-production labels: app: saas-idp component: cost-optimization-controller data: config.yaml: | cost_optimization: # Spot instance management spot_management: enabled: true diversification: min_instance_types: 3 min_availability_zones: 2 max_spot_percentage: 70 interruption_handling: drain_timeout: 300 rebalance_recommendations: true capacity_rebalancing: true bid_strategy: max_price_percentage: 60 # Max 60% of on-demand price fallback_to_on_demand: true # Reserved instance optimization reserved_instances: enabled: true utilization_threshold: 80 commitment_analysis: lookback_days: 30 forecast_days: 365 recommendations: min_savings_percentage: 20 coverage_target: 60 types: - standard - convertible # Right-sizing recommendations rightsizing: enabled: true analysis_window_days: 14 cpu_utilization_threshold: 25 memory_utilization_threshold: 25 recommendations: min_savings_percentage: 10 safety_margin: 20 # 20% buffer above actual usage excluded_workloads: - database - cache - monitoring metrics_sources: - prometheus - cloudwatch - kubernetes-metrics-api # Idle resource detection idle_resources: enabled: true detection_rules: persistent_volumes: unused_days: 7 size_threshold_gb: 10 load_balancers: zero_traffic_days: 3 network_interfaces: unattached_hours: 24 ebs_snapshots: age_days: 90 keep_latest: 5 cleanup: dry_run: false notify_before_deletion: true deletion_delay_hours: 24 # Cost allocation and tracking cost_tracking: enabled: true tagging_enforcement: true required_tags: - CostCenter - Project - Environment - Owner budget_alerts: enabled: true thresholds: [50, 75, 90, 100] notification_channels: - slack - email showback: enabled: true granularity: namespace reports: daily: true weekly: true monthly: true # Multi-cloud cost comparison multi_cloud: enabled: true providers: - aws - gcp - azure comparison_metrics: - compute_cost - storage_cost - network_cost - database_cost analysis_frequency: daily report_threshold_percentage: 15 # Report if other clouds are 15%+ cheaper # Performance vs cost optimization performance_cost: enabled: true sla_requirements: availability: 99.99 response_time_p95: 200 error_rate: 0.01 cost_performance_ratio: target_efficiency: 80 # Target 80% cost efficiency performance_weight: 60 # 60% performance, 40% cost optimization_strategies: - instance_type_optimization - auto_scaling_tuning - storage_class_optimization - network_optimization --- # Resource Rightsizing CronJob apiVersion: batch/v1 kind: CronJob metadata: name: resource-rightsizing namespace: saas-idp-production labels: app: saas-idp component: resource-rightsizing spec: schedule: "0 6 * * *" # Daily at 6 AM UTC concurrencyPolicy: Forbid successfulJobsHistoryLimit: 3 failedJobsHistoryLimit: 3 jobTemplate: spec: template: metadata: labels: app: saas-idp component: resource-rightsizing spec: restartPolicy: OnFailure serviceAccountName: resource-rightsizing-sa securityContext: runAsNonRoot: true runAsUser: 1001 fsGroup: 1001 containers: - name: rightsizing-analyzer image: saas-idp/resource-rightsizer:latest env: - name: PROMETHEUS_URL value: "http://prometheus-global-federation:9090" - name: ANALYSIS_WINDOW_DAYS value: "14" - name: SLACK_WEBHOOK valueFrom: secretKeyRef: name: notification-credentials key: slack-webhook - name: DRY_RUN value: "false" envFrom: - configMapRef: name: rightsizing-config - secretRef: name: aws-credentials resources: requests: memory: "512Mi" cpu: "200m" limits: memory: "2Gi" cpu: "1000m" securityContext: allowPrivilegeEscalation: false capabilities: drop: - ALL --- apiVersion: v1 kind: ConfigMap metadata: name: rightsizing-config namespace: saas-idp-production labels: app: saas-idp component: rightsizing data: config.yaml: | rightsizing: analysis: window_days: 14 cpu_threshold: 25 # % memory_threshold: 25 # % safety_margin: 20 # % min_samples: 1000 percentile: 95 workload_profiles: web_servers: cpu_target: 70 memory_target: 75 burstable: true background_jobs: cpu_target: 80 memory_target: 70 burstable: false databases: cpu_target: 60 memory_target: 80 burstable: false exclude: true # Manual optimization only caches: cpu_target: 50 memory_target: 85 burstable: false exclude: true # Manual optimization only recommendations: min_savings_dollar: 50 min_savings_percentage: 10 max_recommendations_per_run: 50 approval_required_threshold: 500 # Dollar amount auto_apply_threshold: 100 # Dollar amount notifications: channels: - type: slack webhook_secret: notification-credentials webhook_key: slack-webhook - type: email recipients: - platform-team@saas-idp.com - finops@saas-idp.com message_template: | Resource Rightsizing Report Analysis Period: {{ .AnalysisPeriod }} Total Recommendations: {{ .TotalRecommendations }} Potential Monthly Savings: ${{ .MonthlySavings }} Top Recommendations: {{ range .TopRecommendations }} • {{ .WorkloadName }}: {{ .CurrentResources }} → {{ .RecommendedResources }} (Save ${{ .MonthlySavings }}/month) {{ end }} View full report: {{ .ReportURL }} --- # Spot Instance Interruption Handler apiVersion: apps/v1 kind: DaemonSet metadata: name: spot-interruption-handler namespace: saas-idp-production labels: app: saas-idp component: spot-interruption-handler spec: selector: matchLabels: app: saas-idp component: spot-interruption-handler template: metadata: labels: app: saas-idp component: spot-interruption-handler annotations: prometheus.io/scrape: "true" prometheus.io/port: "8080" spec: serviceAccountName: spot-interruption-handler-sa hostNetwork: true tolerations: - key: "spot-instance" effect: NoSchedule - key: "cost-optimized" effect: NoSchedule - key: node-role.kubernetes.io/master effect: NoSchedule - key: node-role.kubernetes.io/control-plane effect: NoSchedule nodeSelector: capacity-type: spot containers: - name: handler image: saas-idp/spot-interruption-handler:latest ports: - name: http containerPort: 8080 env: - name: NODE_NAME valueFrom: fieldRef: fieldPath: spec.nodeName - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: DRAIN_TIMEOUT value: "300" - name: CHECK_INTERVAL value: "5" - name: METADATA_URL value: "http://169.254.169.254" - name: SLACK_WEBHOOK valueFrom: secretKeyRef: name: notification-credentials key: slack-webhook resources: requests: memory: "128Mi" cpu: "50m" limits: memory: "256Mi" cpu: "100m" securityContext: runAsNonRoot: true runAsUser: 65534 allowPrivilegeEscalation: false capabilities: drop: - ALL --- # Cost Analytics and Reporting Service apiVersion: apps/v1 kind: Deployment metadata: name: cost-analytics namespace: saas-idp-production labels: app: saas-idp component: cost-analytics spec: replicas: 2 selector: matchLabels: app: saas-idp component: cost-analytics template: metadata: labels: app: saas-idp component: cost-analytics annotations: prometheus.io/scrape: "true" prometheus.io/port: "8080" spec: serviceAccountName: cost-analytics-sa securityContext: runAsNonRoot: true runAsUser: 1001 fsGroup: 1001 containers: - name: cost-analytics image: saas-idp/cost-analytics:latest ports: - name: http containerPort: 8080 - name: metrics containerPort: 9090 env: - name: AWS_REGION value: "us-east-1" - name: COST_EXPLORER_ENABLED value: "true" - name: BILLING_BUCKET value: "saas-idp-billing-reports" - name: SHOWBACK_ENABLED value: "true" - name: CHARGEBACK_ENABLED value: "true" - name: REPORT_FREQUENCY value: "daily" envFrom: - configMapRef: name: cost-analytics-config - secretRef: name: aws-credentials resources: requests: memory: "1Gi" cpu: "500m" limits: memory: "4Gi" cpu: "2000m" livenessProbe: httpGet: path: /health port: http initialDelaySeconds: 60 periodSeconds: 15 readinessProbe: httpGet: path: /ready port: http initialDelaySeconds: 30 periodSeconds: 10 securityContext: allowPrivilegeEscalation: false capabilities: drop: - ALL --- apiVersion: v1 kind: ConfigMap metadata: name: cost-analytics-config namespace: saas-idp-production labels: app: saas-idp component: cost-analytics data: config.yaml: | cost_analytics: data_sources: aws: cost_explorer: true billing_reports: true cloudwatch_metrics: true pricing_api: true kubernetes: resource_quotas: true usage_metrics: true pod_metrics: true namespace_metrics: true prometheus: endpoint: "http://prometheus-global-federation:9090" queries: cpu_usage: 'sum(rate(container_cpu_usage_seconds_total[5m])) by (namespace, pod)' memory_usage: 'sum(container_memory_working_set_bytes) by (namespace, pod)' network_usage: 'sum(rate(container_network_transmit_bytes_total[5m])) by (namespace, pod)' cost_allocation: methods: - resource_based - usage_based - request_based allocation_keys: - namespace - team - project - environment - cost_center allocation_rules: shared_services: method: usage_based services: - monitoring - logging - ingress - dns infrastructure: method: resource_based include_overhead: true overhead_percentage: 15 reporting: formats: - json - csv - html - pdf delivery: email: enabled: true recipients: - finops@saas-idp.com - engineering-leads@saas-idp.com schedule: "0 8 * * 1" # Weekly on Monday at 8 AM slack: enabled: true channel: "#finops" schedule: "0 9 * * *" # Daily at 9 AM s3: enabled: true bucket: "saas-idp-cost-reports" prefix: "cost-analytics/" dashboards: cost_trends: true budget_tracking: true rightsizing_opportunities: true reserved_instance_utilization: true spot_instance_savings: true multi_cloud_comparison: true budgets: monthly_budget: 50000 # $50k per month quarterly_budget: 140000 # $140k per quarter alerts: - threshold: 50 type: actual notification: email - threshold: 80 type: actual notification: slack - threshold: 100 type: forecasted notification: pagerduty optimization_recommendations: rightsizing: enabled: true min_savings: 100 analysis_window_days: 14 reserved_instances: enabled: true min_savings_percentage: 20 commitment_analysis_days: 90 spot_instances: enabled: true max_interruption_rate: 5 # 5% acceptable interruption rate workload_suitability_score: 80 storage_optimization: enabled: true lifecycle_policies: true intelligent_tiering: true unused_volume_detection: true --- # Service Accounts and RBAC apiVersion: v1 kind: ServiceAccount metadata: name: cost-optimization-sa namespace: saas-idp-production labels: app: saas-idp component: cost-optimization annotations: eks.amazonaws.com/role-arn: "arn:aws:iam::ACCOUNT-ID:role/CostOptimizationRole" --- apiVersion: v1 kind: ServiceAccount metadata: name: resource-rightsizing-sa namespace: saas-idp-production labels: app: saas-idp component: resource-rightsizing annotations: eks.amazonaws.com/role-arn: "arn:aws:iam::ACCOUNT-ID:role/ResourceRightsizingRole" --- apiVersion: v1 kind: ServiceAccount metadata: name: spot-interruption-handler-sa namespace: saas-idp-production labels: app: saas-idp component: spot-interruption-handler annotations: eks.amazonaws.com/role-arn: "arn:aws:iam::ACCOUNT-ID:role/SpotInterruptionHandlerRole" --- apiVersion: v1 kind: ServiceAccount metadata: name: cost-analytics-sa namespace: saas-idp-production labels: app: saas-idp component: cost-analytics annotations: eks.amazonaws.com/role-arn: "arn:aws:iam::ACCOUNT-ID:role/CostAnalyticsRole" --- # RBAC for Cost Optimization Components apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cost-optimization-controller rules: - apiGroups: [""] resources: ["nodes", "pods", "namespaces", "persistentvolumes", "persistentvolumeclaims"] verbs: ["get", "list", "watch"] - apiGroups: ["apps"] resources: ["deployments", "replicasets", "statefulsets", "daemonsets"] verbs: ["get", "list", "watch", "update", "patch"] - apiGroups: ["autoscaling"] resources: ["horizontalpodautoscalers", "verticalpodautoscalers"] verbs: ["get", "list", "watch", "create", "update", "patch", "delete"] - apiGroups: ["metrics.k8s.io"] resources: ["nodes", "pods"] verbs: ["get", "list"] - apiGroups: ["custom.metrics.k8s.io"] resources: ["*"] verbs: ["get", "list"] - apiGroups: ["karpenter.sh"] resources: ["nodepools", "ec2nodeclasses"] verbs: ["get", "list", "watch", "create", "update", "patch", "delete"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cost-optimization-controller roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cost-optimization-controller subjects: - kind: ServiceAccount name: cost-optimization-sa namespace: saas-idp-production - kind: ServiceAccount name: resource-rightsizing-sa namespace: saas-idp-production - kind: ServiceAccount name: spot-interruption-handler-sa namespace: saas-idp-production - kind: ServiceAccount name: cost-analytics-sa namespace: saas-idp-production --- # Services apiVersion: v1 kind: Service metadata: name: cost-optimization-controller namespace: saas-idp-production labels: app: saas-idp component: cost-optimization-controller spec: type: ClusterIP ports: - name: http port: 8080 targetPort: http - name: metrics port: 9090 targetPort: metrics selector: app: saas-idp component: cost-optimization-controller --- apiVersion: v1 kind: Service metadata: name: cost-analytics namespace: saas-idp-production labels: app: saas-idp component: cost-analytics spec: type: ClusterIP ports: - name: http port: 8080 targetPort: http - name: metrics port: 9090 targetPort: metrics selector: app: saas-idp component: cost-analytics