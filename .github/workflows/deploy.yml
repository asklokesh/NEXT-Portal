name: Deploy

on:
 push:
 branches: [ main ]
 workflow_dispatch:
 inputs:
 environment:
 description: 'Environment to deploy to'
 required: true
 default: 'staging'
 type: choice
 options:
 - staging
 - production

env:
 REGISTRY: ghcr.io
 IMAGE_NAME: ${{ github.repository }}

jobs:
 build-and-push:
 runs-on: ubuntu-latest
 permissions:
 contents: read
 packages: write
 outputs:
 image-tag: ${{ steps.meta.outputs.tags }}
 image-digest: ${{ steps.build.outputs.digest }}
 
 steps:
 - name: Checkout code
 uses: actions/checkout@v4
 
 - name: Set up Docker Buildx
 uses: docker/setup-buildx-action@v3
 
 - name: Log in to Container Registry
 uses: docker/login-action@v3
 with:
 registry: ${{ env.REGISTRY }}
 username: ${{ github.actor }}
 password: ${{ secrets.GITHUB_TOKEN }}
 
 - name: Extract metadata
 id: meta
 uses: docker/metadata-action@v5
 with:
 images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
 tags: |
 type=ref,event=branch
 type=ref,event=pr
 type=semver,pattern={{version}}
 type=semver,pattern={{major}}.{{minor}}
 type=sha,prefix={{branch}}-
 type=raw,value=latest,enable={{is_default_branch}}
 
 - name: Build and push Docker image
 id: build
 uses: docker/build-push-action@v5
 with:
 context: .
 file: ./Dockerfile.production
 push: true
 tags: ${{ steps.meta.outputs.tags }}
 labels: ${{ steps.meta.outputs.labels }}
 cache-from: type=gha
 cache-to: type=gha,mode=max
 build-args: |
 BUILD_DATE=${{ github.event.repository.updated_at }}
 VCS_REF=${{ github.sha }}
 VERSION=${{ github.ref_name }}

 deploy-staging:
 needs: build-and-push
 runs-on: ubuntu-latest
 if: github.event_name == 'push' || github.event.inputs.environment == 'staging'
 environment:
 name: staging
 url: https://staging.backstage-idp.example.com
 
 steps:
 - name: Checkout code
 uses: actions/checkout@v4
 
 - name: Setup kubectl
 uses: azure/setup-kubectl@v3
 with:
 version: 'latest'
 
 - name: Configure kubectl
 run: |
 echo "${{ secrets.STAGING_KUBECONFIG }}" | base64 -d > kubeconfig
 echo "KUBECONFIG=$(pwd)/kubeconfig" >> $GITHUB_ENV
 
 - name: Update image in Kubernetes
 run: |
 kubectl set image deployment/backstage-idp \
 app=${{ needs.build-and-push.outputs.image-tag }} \
 -n backstage-idp-staging
 
 - name: Wait for rollout
 run: |
 kubectl rollout status deployment/backstage-idp \
 -n backstage-idp-staging \
 --timeout=10m
 
 - name: Run smoke tests
 run: |
 STAGING_URL="https://staging.backstage-idp.example.com"
 
 # Health check
 curl -f ${STAGING_URL}/api/health || exit 1
 
 # Ready check
 curl -f ${STAGING_URL}/api/health/ready || exit 1
 
 echo "Smoke tests passed!"

 deploy-production:
 needs: [build-and-push, deploy-staging]
 runs-on: ubuntu-latest
 if: github.event.inputs.environment == 'production'
 environment:
 name: production
 url: https://backstage-idp.example.com
 
 steps:
 - name: Checkout code
 uses: actions/checkout@v4
 
 - name: Setup kubectl
 uses: azure/setup-kubectl@v3
 with:
 version: 'latest'
 
 - name: Configure kubectl
 run: |
 echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > kubeconfig
 echo "KUBECONFIG=$(pwd)/kubeconfig" >> $GITHUB_ENV
 
 - name: Create backup
 run: |
 # Backup current deployment
 kubectl get deployment backstage-idp -n backstage-idp -o yaml > backup-deployment.yaml
 
 # Backup database (example with pg_dump)
 kubectl exec -n backstage-idp postgres-0 -- pg_dump -U backstage_user backstage_idp > backup-$(date +%Y%m%d-%H%M%S).sql
 
 - name: Update image in Kubernetes (Canary)
 run: |
 # Update canary deployment first (10% traffic)
 kubectl set image deployment/backstage-idp-canary \
 app=${{ needs.build-and-push.outputs.image-tag }} \
 -n backstage-idp
 
 kubectl rollout status deployment/backstage-idp-canary \
 -n backstage-idp \
 --timeout=5m
 
 - name: Run canary tests
 run: |
 PROD_URL="https://backstage-idp.example.com"
 
 # Run comprehensive tests against canary
 npm run test:production
 env:
 PRODUCTION_URL: https://backstage-idp.example.com
 
 - name: Promote to production
 run: |
 # Update main deployment
 kubectl set image deployment/backstage-idp \
 app=${{ needs.build-and-push.outputs.image-tag }} \
 -n backstage-idp
 
 # Wait for rollout
 kubectl rollout status deployment/backstage-idp \
 -n backstage-idp \
 --timeout=15m
 
 - name: Post-deployment verification
 run: |
 # Verify all pods are running
 kubectl get pods -n backstage-idp -l app=backstage-idp
 
 # Check metrics
 curl -H "Authorization: Bearer ${{ secrets.METRICS_TOKEN }}" \
 https://backstage-idp.example.com/api/metrics
 
 - name: Notify deployment
 if: always()
 uses: 8398a7/action-slack@v3
 with:
 status: ${{ job.status }}
 text: |
 Production deployment ${{ job.status }}
 Version: ${{ needs.build-and-push.outputs.image-tag }}
 Actor: ${{ github.actor }}
 env:
 SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

 rollback:
 needs: deploy-production
 runs-on: ubuntu-latest
 if: failure()
 environment: production
 
 steps:
 - name: Configure kubectl
 run: |
 echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > kubeconfig
 echo "KUBECONFIG=$(pwd)/kubeconfig" >> $GITHUB_ENV
 
 - name: Rollback deployment
 run: |
 kubectl rollout undo deployment/backstage-idp -n backstage-idp
 kubectl rollout status deployment/backstage-idp -n backstage-idp
 
 - name: Notify rollback
 uses: 8398a7/action-slack@v3
 with:
 status: custom
 custom_payload: |
 {
 text: " Production deployment rolled back",
 attachments: [{
 color: 'warning',
 text: 'Automatic rollback triggered due to deployment failure'
 }]
 }
 env:
 SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}