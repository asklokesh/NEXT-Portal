# SaaS IDP - Production Operational Runbooks ## Table of Contents - [P0 Critical Incident Runbooks](#p0-critical-incident-runbooks) - [P1 High Priority Runbooks](#p1-high-priority-runbooks) - [P2 Medium Priority Runbooks](#p2-medium-priority-runbooks) - [Security Incident Runbooks](#security-incident-runbooks) - [Automated Remediation Scripts](#automated-remediation-scripts) - [Escalation Procedures](#escalation-procedures) - [Post-Incident Procedures](#post-incident-procedures) --- ## P0 Critical Incident Runbooks ### P0-001: System Complete Outage **Alert:** `P0_SystemDown` **MTTR Target:** < 5 minutes **Impact:** Total platform unavailability #### Immediate Actions (0-2 minutes) 1. **Acknowledge Alert** - Page primary on-call engineer 2. **Status Page Update** - Auto-update status page to "Major Outage" 3. **Executive Notification** - Auto-page CTO and VP Engineering 4. **Customer Communication** - Send automated incident notification #### Investigation Steps (2-5 minutes) ```bash # Check system health curl -f https://api.saas-idp.com/health || echo "API DOWN" # Check load balancer status kubectl get pods -n saas-idp-production kubectl get services -n saas-idp-production # Check database connectivity docker exec -it postgres-primary psql -c "SELECT 1" docker exec -it redis-primary redis-cli ping ``` #### Automated Remediation ```yaml # Auto-scaling trigger apiVersion: v1 kind: ConfigMap metadata: name: p0-system-down-remediation data: auto-scale.sh: | #!/bin/bash # Immediate horizontal scaling kubectl scale deployment saas-idp-api --replicas=10 kubectl scale deployment saas-idp-worker --replicas=5 # Restart unhealthy pods kubectl delete pods -l app=saas-idp-api --field-selector=status.phase=Failed # Trigger circuit breaker reset curl -X POST http://localhost:8080/admin/circuit-breaker/reset ``` #### Recovery Actions 1. **Traffic Rerouting** - Activate DR region if primary region down 2. **Database Failover** - Promote read replica to primary 3. **Cache Warming** - Pre-populate Redis cache with critical data 4. **Service Restart** - Rolling restart of application services --- ### P0-002: Database Complete Failure **Alert:** `P0_DatabaseDown` **MTTR Target:** < 5 minutes **Impact:** Data unavailability, application failure #### Immediate Actions ```bash #!/bin/bash # Database failover script set -e echo "Starting database failover procedure..." # 1. Stop writes to primary kubectl patch postgresql primary --type='merge' -p='{"spec":{"postgresql":{"parameters":{"default_transaction_read_only":"on"}}}}' # 2. Promote replica to primary kubectl patch postgresql replica --type='merge' -p='{"spec":{"postgresql":{"replicaOf":null}}}' # 3. Update application config kubectl patch configmap app-config --type='merge' -p='{"data":{"DATABASE_URL":"postgresql://replica:5432/saasidp"}}' # 4. Restart application pods kubectl rollout restart deployment/saas-idp-api kubectl rollout restart deployment/saas-idp-worker # 5. Update DNS/Load Balancer # (This step depends on your infrastructure) echo "Database failover completed" ``` --- ### P0-003: Authentication System Failure **Alert:** `P0_AuthenticationSystemDown` **MTTR Target:** < 3 minutes **Impact:** Users cannot login #### Automated Recovery ```python #!/usr/bin/env python3 """ Automated authentication system recovery """ import requests import subprocess import time def restart_auth_service(): """Restart authentication service""" subprocess.run(["kubectl", "rollout", "restart", "deployment/auth-service"]) def clear_auth_cache(): """Clear authentication cache""" redis_command = ["kubectl", "exec", "-it", "redis-primary", "--", "redis-cli", "FLUSHDB"] subprocess.run(redis_command) def verify_auth_endpoints(): """Verify auth endpoints are responding""" endpoints = [ "https://api.saas-idp.com/auth/health", "https://api.saas-idp.com/auth/providers", ] for endpoint in endpoints: try: response = requests.get(endpoint, timeout=5) if response.status_code != 200: return False except: return False return True def main(): print("Starting authentication system recovery...") # Step 1: Clear cache clear_auth_cache() # Step 2: Restart service restart_auth_service() # Step 3: Wait for startup time.sleep(30) # Step 4: Verify if verify_auth_endpoints(): print("Authentication system recovery successful") # Update status page requests.post("https://api.statuspage.io/v1/pages/PAGE_ID/incidents/INCIDENT_ID", json={"status": "investigating"}) else: print("Authentication system recovery failed - escalating") # Trigger manual escalation if __name__ == "__main__": main() ``` --- ## P1 High Priority Runbooks ### P1-001: Severe Performance Degradation **Alert:** `P1_SeverePerformanceDegradation` **MTTR Target:** < 15 minutes **Impact:** Slow user experience #### Investigation Checklist - [ ] Check CPU/Memory usage across all services - [ ] Verify database query performance - [ ] Check for slow queries in application logs - [ ] Validate cache hit rates - [ ] Review recent deployments #### Performance Recovery Script ```bash #!/bin/bash # Performance optimization script echo "Starting performance recovery..." # 1. Scale up compute resources kubectl patch hpa saas-idp-api -p '{"spec":{"minReplicas":5,"maxReplicas":20}}' # 2. Optimize database connections kubectl exec -it postgres-primary -- psql -c " SELECT pg_reload_conf(); SELECT pg_stat_reset(); " # 3. Clear cache and warm with essentials kubectl exec -it redis-primary -- redis-cli FLUSHALL python3 /scripts/cache-warmer.py --critical-only # 4. Enable circuit breaker for non-critical services curl -X POST http://api-gateway:8080/circuit-breaker/enable \ -d '{"services": ["analytics", "recommendations"]}' # 5. Monitor for improvement echo "Performance recovery actions completed. Monitoring..." ``` --- ### P1-002: High Error Rate **Alert:** `P1_HighErrorRate` **MTTR Target:** < 15 minutes #### Error Analysis Script ```python #!/usr/bin/env python3 """ Automated error analysis and remediation """ import json import subprocess from datetime import datetime, timedelta def analyze_errors(): """Analyze recent errors from logs""" # Query logs for last 10 minutes end_time = datetime.now() start_time = end_time - timedelta(minutes=10) query = f""" kubectl logs -l app=saas-idp-api --since={start_time.isoformat()} | grep ERROR | head -100 """ result = subprocess.run(query, shell=True, capture_output=True, text=True) errors = result.stdout.strip().split('\n') # Categorize errors error_categories = {} for error in errors: if 'database' in error.lower(): error_categories['database'] = error_categories.get('database', 0) + 1 elif 'timeout' in error.lower(): error_categories['timeout'] = error_categories.get('timeout', 0) + 1 elif 'authentication' in error.lower(): error_categories['auth'] = error_categories.get('auth', 0) + 1 else: error_categories['other'] = error_categories.get('other', 0) + 1 return error_categories def remediate_database_errors(): """Remediate database-related errors""" # Restart database connections subprocess.run(["kubectl", "rollout", "restart", "deployment/saas-idp-api"]) def remediate_timeout_errors(): """Remediate timeout errors""" # Increase timeout configurations subprocess.run([ "kubectl", "patch", "configmap", "app-config", "--type=merge", "-p", '{"data":{"REQUEST_TIMEOUT":"30000","DB_TIMEOUT":"10000"}}' ]) def main(): errors = analyze_errors() print(f"Error analysis: {json.dumps(errors, indent=2)}") # Apply targeted remediation if errors.get('database', 0) > 10: print("High database errors detected - restarting connections") remediate_database_errors() if errors.get('timeout', 0) > 5: print("High timeout errors detected - increasing timeouts") remediate_timeout_errors() ``` --- ## P2 Medium Priority Runbooks ### P2-001: High Resource Usage **Alert:** `P2_HighResourceUsage` **MTTR Target:** < 1 hour #### Resource Optimization ```bash #!/bin/bash # Resource optimization for capacity management echo "Starting resource optimization..." # 1. Check current resource usage kubectl top nodes kubectl top pods --all-namespaces # 2. Identify resource-heavy pods kubectl get pods --all-namespaces --sort-by='.status.containerStatuses[0].restartCount' -o wide # 3. Optimize memory usage # Clear unnecessary caches find /tmp -type f -name "*.log" -mtime +1 -delete find /var/log -type f -name "*.log" -mtime +7 -delete # 4. Scale down non-essential services during peak load kubectl scale deployment analytics-service --replicas=1 kubectl scale deployment recommendation-engine --replicas=1 # 5. Optimize garbage collection kubectl exec -it $(kubectl get pods -l app=saas-idp-api -o jsonpath='{.items[0].metadata.name}') \ -- node -e "if (global.gc) global.gc();" echo "Resource optimization completed" ``` --- ## Security Incident Runbooks ### SEC-001: Brute Force Attack **Alert:** `P1_BruteForceAttackDetected` **Response Time:** < 5 minutes #### Immediate Response ```bash #!/bin/bash # Brute force attack response ATTACKER_IP=$1 THRESHOLD=$2 echo "Responding to brute force attack from IP: $ATTACKER_IP" # 1. Block IP at load balancer level curl -X POST "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/firewall/access_rules/rules" \ -H "Authorization: Bearer $CF_API_TOKEN" \ -H "Content-Type: application/json" \ -d "{ \"mode\": \"block\", \"configuration\": { \"target\": \"ip\", \"value\": \"$ATTACKER_IP\" }, \"notes\": \"Brute force attack - auto-blocked by monitoring system\" }" # 2. Invalidate any existing sessions for affected users kubectl exec -it redis-primary -- redis-cli --scan --pattern "session:*" | \ xargs kubectl exec -it redis-primary -- redis-cli DEL # 3. Enable additional security measures kubectl patch configmap security-config --type=merge -p='{"data":{"RATE_LIMIT_STRICT":"true","MFA_REQUIRED":"true"}}' # 4. Alert security team curl -X POST $SLACK_SECURITY_WEBHOOK \ -H 'Content-type: application/json' \ -d "{ \"text\": \" SECURITY ALERT: Brute force attack blocked from IP $ATTACKER_IP\" }" echo "Brute force attack response completed" ``` --- ## Automated Remediation Scripts ### Circuit Breaker Implementation ```yaml apiVersion: v1 kind: ConfigMap metadata: name: circuit-breaker-config data: circuit-breaker.yml: | services: analytics: failure_threshold: 5 timeout_threshold: 30s recovery_timeout: 60s recommendations: failure_threshold: 3 timeout_threshold: 10s recovery_timeout: 30s notifications: failure_threshold: 10 timeout_threshold: 5s recovery_timeout: 120s ``` ### Auto-scaling Configuration ```yaml apiVersion: autoscaling/v2 kind: HorizontalPodAutoscaler metadata: name: saas-idp-api-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: saas-idp-api minReplicas: 3 maxReplicas: 50 metrics: - type: Resource resource: name: cpu target: type: Utilization averageUtilization: 70 - type: Resource resource: name: memory target: type: Utilization averageUtilization: 80 - type: Pods pods: metric: name: http_requests_per_second target: type: AverageValue averageValue: "100" behavior: scaleUp: stabilizationWindowSeconds: 30 policies: - type: Percent value: 100 periodSeconds: 30 scaleDown: stabilizationWindowSeconds: 300 policies: - type: Percent value: 10 periodSeconds: 60 ``` --- ## Escalation Procedures ### P0 Escalation Chain 1. **Primary On-Call** (0-2 minutes) 2. **Secondary On-Call** (2-5 minutes) 3. **Engineering Manager** (5-10 minutes) 4. **CTO** (10-15 minutes) 5. **CEO** (15+ minutes, customer-impacting only) ### Communication Templates #### P0 Incident Communication ``` Subject: [P0 INCIDENT] SaaS IDP Platform Outage - {{INCIDENT_ID}} IMPACT: Complete platform unavailability START TIME: {{START_TIME}} AFFECTED USERS: All users ESTIMATED RESOLUTION: {{ETA}} CURRENT STATUS: {{STATUS}} ACTIONS TAKEN: - {{ACTION_1}} - {{ACTION_2}} NEXT UPDATE: {{NEXT_UPDATE_TIME}} War Room: {{WAR_ROOM_LINK}} Status Page: {{STATUS_PAGE_LINK}} ``` #### Customer Notification Template ``` Subject: Service Disruption - SaaS IDP Platform Dear {{CUSTOMER_NAME}}, We are currently experiencing a service disruption affecting the SaaS IDP platform. IMPACT: {{IMPACT_DESCRIPTION}} START TIME: {{START_TIME}} CURRENT STATUS: {{STATUS}} Our engineering team is actively working to resolve this issue. We will provide updates every 30 minutes until resolution. We sincerely apologize for any inconvenience this may cause. Latest updates: {{STATUS_PAGE_LINK}} Best regards, SaaS IDP Operations Team ``` --- ## Post-Incident Procedures ### Post-Incident Review Template ```markdown # Post-Incident Review - {{INCIDENT_ID}} ## Incident Summary - **Date:** {{DATE}} - **Duration:** {{DURATION}} - **Impact:** {{IMPACT}} - **Root Cause:** {{ROOT_CAUSE}} ## Timeline | Time | Event | |------|-------| | {{TIME}} | {{EVENT}} | ## What Went Well - {{POSITIVE_1}} - {{POSITIVE_2}} ## What Could Be Improved - {{IMPROVEMENT_1}} - {{IMPROVEMENT_2}} ## Action Items | Action | Owner | Due Date | Priority | |--------|-------|----------|----------| | {{ACTION}} | {{OWNER}} | {{DUE_DATE}} | {{PRIORITY}} | ## Follow-up Actions - [ ] Update runbooks with lessons learned - [ ] Implement additional monitoring - [ ] Conduct team training - [ ] Review and update alerting thresholds ``` ### Automated Incident Metrics ```python #!/usr/bin/env python3 """ Calculate incident metrics for reporting """ import json from datetime import datetime, timedelta class IncidentMetrics: def calculate_mttr(self, incidents): """Calculate Mean Time to Recovery""" total_resolution_time = 0 resolved_incidents = [i for i in incidents if i['status'] == 'resolved'] for incident in resolved_incidents: start = datetime.fromisoformat(incident['start_time']) end = datetime.fromisoformat(incident['resolution_time']) total_resolution_time += (end - start).total_seconds() return total_resolution_time / len(resolved_incidents) if resolved_incidents else 0 def calculate_availability(self, incidents, period_days=30): """Calculate service availability percentage""" total_downtime = 0 period_seconds = period_days * 24 * 3600 for incident in incidents: if incident['impact'] == 'total_outage': start = datetime.fromisoformat(incident['start_time']) end = datetime.fromisoformat(incident['resolution_time']) total_downtime += (end - start).total_seconds() availability = ((period_seconds - total_downtime) / period_seconds) * 100 return round(availability, 4) def generate_report(self, incidents): """Generate monthly incident report""" report = { 'mttr_seconds': self.calculate_mttr(incidents), 'availability_percent': self.calculate_availability(incidents), 'total_incidents': len(incidents), 'p0_incidents': len([i for i in incidents if i['priority'] == 'P0']), 'p1_incidents': len([i for i in incidents if i['priority'] == 'P1']), 'security_incidents': len([i for i in incidents if 'security' in i['tags']]) } return report ``` --- This comprehensive set of runbooks provides: - Clear step-by-step procedures for each alert type - Automated remediation scripts - Escalation procedures - Post-incident analysis - Communication templates - Metrics calculation Each runbook is designed to minimize MTTR and ensure consistent response to production incidents.