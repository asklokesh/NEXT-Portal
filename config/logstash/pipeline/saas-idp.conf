# Logstash pipeline configuration for SaaS IDP
input {
  # Beats input from Filebeat
  beats {
    port => 5044
  }

  # Direct TCP input for structured logs
  tcp {
    port => 5000
    codec => json_lines
    tags => ["tcp-input"]
  }

  # HTTP input for webhook-style log ingestion
  http {
    port => 8080
    codec => json
    tags => ["http-input"]
  }

  # File input for direct log file processing
  file {
    path => "/usr/share/logstash/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
    tags => ["file-input"]
  }
}

filter {
  # Parse timestamp field
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }

  # Add common fields
  mutate {
    add_field => {
      "[@metadata][index]" => "saas-idp-%{+YYYY.MM.dd}"
      "platform" => "saas-idp"
    }
  }

  # Enrich with GeoIP data if IP field is present
  if [ip] and [ip] != "unknown" and [ip] != "127.0.0.1" and [ip] != "::1" {
    geoip {
      source => "ip"
      target => "geo"
    }
  }

  # Parse user agent if present
  if [userAgent] {
    useragent {
      source => "userAgent"
      target => "user_agent"
    }
  }

  # Security event processing
  if [security] {
    mutate {
      add_field => { "event_category" => "security" }
    }

    # Calculate risk score if not present
    if ![security][risk_score] {
      ruby {
        code => "
          severity = event.get('[security][severity]')
          outcome = event.get('[security][outcome]')
          
          risk_score = case severity
          when 'critical' then 90
          when 'high' then 70
          when 'medium' then 40
          when 'low' then 20
          else 10
          end
          
          # Increase risk for failures
          if outcome == 'failure'
            risk_score += 20
          end
          
          event.set('[security][risk_score]', [risk_score, 100].min)
        "
      }
    }
  }

  # Business event processing
  if [business] {
    mutate {
      add_field => { "event_category" => "business" }
    }

    # Convert currency values
    if [business][value] and [business][currency] {
      mutate {
        add_field => { "[business][value_usd]" => "%{[business][value]}" }
      }
      
      # Currency conversion would go here in a real implementation
      # For now, we'll assume USD
    }
  }

  # Performance event processing
  if [performance] {
    mutate {
      add_field => { "event_category" => "performance" }
    }

    # Convert memory usage to MB
    if [performance][memoryUsage][rss] {
      ruby {
        code => "
          rss = event.get('[performance][memoryUsage][rss]')
          event.set('[performance][memoryUsage][rss_mb]', (rss / 1024.0 / 1024.0).round(2))
        "
      }
    }

    # Categorize performance based on duration
    if [performance][duration] {
      ruby {
        code => "
          duration = event.get('[performance][duration]')
          category = case duration
          when 0..100 then 'fast'
          when 101..500 then 'normal'
          when 501..2000 then 'slow'
          else 'very_slow'
          end
          event.set('[performance][category]', category)
        "
      }
    }
  }

  # HTTP request processing
  if [route] or [url] {
    mutate {
      add_field => { "event_category" => "http" }
    }

    # Extract API version from route
    if [route] {
      grok {
        match => { "route" => "/api/v(?<api_version>\d+)/" }
        tag_on_failure => ["_grok_api_version_failure"]
      }
    }

    # Classify HTTP status codes
    if [statusCode] {
      ruby {
        code => "
          status = event.get('statusCode').to_i
          classification = case status
          when 200..299 then 'success'
          when 300..399 then 'redirect'
          when 400..499 then 'client_error'
          when 500..599 then 'server_error'
          else 'unknown'
          end
          event.set('status_classification', classification)
        "
      }
    }
  }

  # Plugin-specific processing
  if [plugin_id] or [component] =~ /plugin/ {
    mutate {
      add_field => { "event_category" => "plugin" }
    }
  }

  # Database operation processing
  if [db] {
    mutate {
      add_field => { "event_category" => "database" }
    }

    # Anonymize sensitive query data
    if [db][statement] {
      mutate {
        gsub => [
          "[db][statement]", "'[^']*'", "'***'",
          "[db][statement]", '"[^"]*"', '"***"',
          "[db][statement]", "\b\d{4}-\d{2}-\d{2}\b", "****-**-**"
        ]
      }
    }
  }

  # Error processing
  if [level] == "error" or [error] {
    mutate {
      add_field => { 
        "event_category" => "error"
        "alert_needed" => "true"
      }
    }

    # Extract stack trace info
    if [error][stack] {
      grok {
        match => { "[error][stack]" => "at (?<error_function>[^\s]+) \((?<error_file>[^:]+):(?<error_line>\d+):" }
        tag_on_failure => ["_grok_stack_failure"]
      }
    }
  }

  # Clean up and normalize fields
  mutate {
    # Remove empty fields
    remove_field => [ "[metadata]" ]
    
    # Convert string numbers to integers where appropriate
    convert => {
      "statusCode" => "integer"
      "duration" => "float"
      "pid" => "integer"
    }
  }

  # Fingerprint for deduplication
  fingerprint {
    source => ["message", "service", "component", "level"]
    target => "[@metadata][fingerprint]"
    method => "SHA256"
  }
}

output {
  # Main application logs
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
    user => "${ELASTICSEARCH_USERNAME:elastic}"
    password => "${ELASTICSEARCH_PASSWORD:elastic123}"
    index => "%{[@metadata][index]}"
    template_name => "saas-idp"
    template_pattern => "saas-idp-*"
    template => "/usr/share/logstash/templates/saas-idp-template.json"
    template_overwrite => true
    document_id => "%{[@metadata][fingerprint]}"
  }

  # Security events to dedicated index
  if [event_category] == "security" {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      user => "${ELASTICSEARCH_USERNAME:elastic}"
      password => "${ELASTICSEARCH_PASSWORD:elastic123}"
      index => "saas-idp-security-%{+YYYY.MM.dd}"
    }
  }

  # Business events to dedicated index
  if [event_category] == "business" {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      user => "${ELASTICSEARCH_USERNAME:elastic}"
      password => "${ELASTICSEARCH_PASSWORD:elastic123}"
      index => "saas-idp-business-%{+YYYY.MM.dd}"
    }
  }

  # Error logs to dedicated index
  if [level] == "error" {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      user => "${ELASTICSEARCH_USERNAME:elastic}"
      password => "${ELASTICSEARCH_PASSWORD:elastic123}"
      index => "saas-idp-errors-%{+YYYY.MM.dd}"
    }
  }

  # Performance metrics to dedicated index
  if [performance] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      user => "${ELASTICSEARCH_USERNAME:elastic}"
      password => "${ELASTICSEARCH_PASSWORD:elastic123}"
      index => "saas-idp-performance-%{+YYYY.MM.dd}"
    }
  }

  # Debug output for development
  if "${LOG_LEVEL:info}" == "debug" {
    stdout {
      codec => rubydebug
    }
  }
}