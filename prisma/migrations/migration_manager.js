#!/usr/bin/env node // ============================================ // MIGRATION MANAGEMENT SYSTEM // Database Migration Runner with Rollback Support // ============================================ const fs = require('fs').promises; const path = require('path'); const { Client } = require('pg'); const crypto = require('crypto'); class MigrationManager { constructor(config = {}) { this.config = { host: config.host || process.env.DB_HOST || 'localhost', port: config.port || process.env.DB_PORT || 5432, database: config.database || process.env.DB_NAME || 'saas_idp', username: config.username || process.env.DB_USERNAME || 'postgres', password: config.password || process.env.DB_PASSWORD, ssl: config.ssl || process.env.DB_SSL === 'true', migrationsDir: config.migrationsDir || path.join(__dirname), backupDir: config.backupDir || path.join(__dirname, 'backups'), dryRun: config.dryRun || false };\n \n this.client = new Client({\n host: this.config.host,\n port: this.config.port,\n database: this.config.database,\n user: this.config.username,\n password: this.config.password,\n ssl: this.config.ssl\n });\n \n this.migrationPattern = /^(\\d{3})_(.+)\\.sql$/;\n }\n \n async connect() {\n try {\n await this.client.connect();\n console.log(' Connected to database');\n } catch (error) {\n console.error(' Database connection failed:', error.message);\n throw error;\n }\n }\n \n async disconnect() {\n await this.client.end();\n console.log(' Disconnected from database');\n }\n \n // ============================================\n // MIGRATION DISCOVERY AND VALIDATION\n // ============================================\n \n async discoverMigrations() {\n try {\n const files = await fs.readdir(this.config.migrationsDir);\n const migrations = [];\n \n for (const file of files) {\n const match = file.match(this.migrationPattern);\n if (match) {\n const [, version, name] = match;\n const filePath = path.join(this.config.migrationsDir, file);\n const content = await fs.readFile(filePath, 'utf8');\n const checksum = this.calculateChecksum(content);\n \n migrations.push({\n version,\n name: name.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase()),\n filename: file,\n filePath,\n content,\n checksum\n });\n }\n }\n \n return migrations.sort((a, b) => a.version.localeCompare(b.version));\n } catch (error) {\n console.error(' Failed to discover migrations:', error.message);\n throw error;\n }\n }\n \n async getAppliedMigrations() {\n try {\n // Ensure schema_migrations table exists\n await this.ensureMigrationsTable();\n \n const result = await this.client.query(\n 'SELECT * FROM schema_migrations ORDER BY version'\n );\n \n return result.rows;\n } catch (error) {\n console.error(' Failed to get applied migrations:', error.message);\n throw error;\n }\n }\n \n async ensureMigrationsTable() {\n const createTableSQL = `\n CREATE TABLE IF NOT EXISTS schema_migrations (\n version VARCHAR(255) PRIMARY KEY,\n name VARCHAR(500) NOT NULL,\n executed_at TIMESTAMP DEFAULT NOW(),\n execution_time_ms INTEGER,\n checksum VARCHAR(64),\n rollback_sql TEXT,\n status VARCHAR(20) DEFAULT 'COMPLETED'\n );\n `;\n \n await this.client.query(createTableSQL);\n }\n \n // ============================================\n // MIGRATION EXECUTION\n // ============================================\n \n async migrate(options = {}) {\n const {\n target = null,\n force = false,\n createBackup = true\n } = options;\n \n try {\n console.log(' Starting database migration...');\n \n const availableMigrations = await this.discoverMigrations();\n const appliedMigrations = await this.getAppliedMigrations();\n \n const appliedVersions = new Set(appliedMigrations.map(m => m.version));\n const pendingMigrations = availableMigrations.filter(m => \n !appliedVersions.has(m.version)\n );\n \n if (target) {\n const targetIndex = pendingMigrations.findIndex(m => m.version === target);\n if (targetIndex === -1) {\n throw new Error(`Target migration ${target} not found or already applied`);\n }\n pendingMigrations.splice(targetIndex + 1);\n }\n \n if (pendingMigrations.length === 0) {\n console.log(' No pending migrations found. Database is up to date.');\n return { applied: [], skipped: [] };\n }\n \n console.log(` Found ${pendingMigrations.length} pending migrations:`);\n pendingMigrations.forEach(m => {\n console.log(` ${m.version}: ${m.name}`);\n });\n \n if (this.config.dryRun) {\n console.log(' Dry run mode - no changes will be applied');\n return { applied: [], skipped: pendingMigrations };\n }\n \n // Create database backup if requested\n if (createBackup) {\n await this.createBackup(`before_migration_${Date.now()}`);\n }\n \n const appliedMigrationResults = [];\n \n for (const migration of pendingMigrations) {\n console.log(`\\n⏳ Applying migration ${migration.version}: ${migration.name}`);\n \n const startTime = Date.now();\n \n try {\n await this.applyMigration(migration, force);\n const executionTime = Date.now() - startTime;\n \n appliedMigrationResults.push({\n ...migration,\n executionTime,\n status: 'COMPLETED'\n });\n \n console.log(` Migration ${migration.version} completed in ${executionTime}ms`);\n } catch (error) {\n console.error(` Migration ${migration.version} failed:`, error.message);\n \n // Record failed migration\n await this.recordFailedMigration(migration, error.message);\n \n throw new Error(`Migration ${migration.version} failed: ${error.message}`);\n }\n }\n \n console.log(`\\n Successfully applied ${appliedMigrationResults.length} migrations`);\n \n return { applied: appliedMigrationResults, skipped: [] };\n \n } catch (error) {\n console.error(' Migration process failed:', error.message);\n throw error;\n }\n }\n \n async applyMigration(migration, force = false) {\n const client = this.client;\n \n try {\n // Validate checksum if migration exists\n const existing = await client.query(\n 'SELECT * FROM schema_migrations WHERE version = $1',\n [migration.version]\n );\n \n if (existing.rows.length > 0 && !force) {\n const existingMigration = existing.rows[0];\n if (existingMigration.checksum !== migration.checksum) {\n throw new Error(\n `Migration ${migration.version} checksum mismatch. ` +\n 'Use --force to override or check for manual modifications.'\n );\n }\n return; // Already applied\n }\n \n // Begin transaction\n await client.query('BEGIN');\n \n // Record migration start\n await client.query(`\n INSERT INTO schema_migrations (version, name, checksum, status)\n VALUES ($1, $2, $3, 'RUNNING')\n ON CONFLICT (version) DO UPDATE SET\n executed_at = NOW(),\n status = 'RUNNING'\n `, [migration.version, migration.name, migration.checksum]);\n \n // Execute migration SQL\n const sqlStatements = this.parseSQLStatements(migration.content);\n \n for (const statement of sqlStatements) {\n if (statement.trim()) {\n await client.query(statement);\n }\n }\n \n // Record successful completion\n await client.query(`\n UPDATE schema_migrations \n SET status = 'COMPLETED',\n execution_time_ms = EXTRACT(EPOCH FROM (NOW() - executed_at)) * 1000\n WHERE version = $1\n `, [migration.version]);\n \n // Commit transaction\n await client.query('COMMIT');\n \n } catch (error) {\n // Rollback transaction\n await client.query('ROLLBACK');\n throw error;\n }\n }\n \n // ============================================\n // ROLLBACK FUNCTIONALITY\n // ============================================\n \n async rollback(options = {}) {\n const {\n target = null,\n steps = 1,\n createBackup = true\n } = options;\n \n try {\n console.log(' Starting database rollback...');\n \n const appliedMigrations = await this.getAppliedMigrations();\n const completedMigrations = appliedMigrations\n .filter(m => m.status === 'COMPLETED')\n .sort((a, b) => b.version.localeCompare(a.version));\n \n if (completedMigrations.length === 0) {\n console.log(' No migrations to roll back.');\n return { rolledBack: [] };\n }\n \n let migrationsToRollback = [];\n \n if (target) {\n // Roll back to specific version\n const targetIndex = completedMigrations.findIndex(m => m.version === target);\n if (targetIndex === -1) {\n throw new Error(`Target migration ${target} not found`);\n }\n migrationsToRollback = completedMigrations.slice(0, targetIndex);\n } else {\n // Roll back specified number of steps\n migrationsToRollback = completedMigrations.slice(0, steps);\n }\n \n if (migrationsToRollback.length === 0) {\n console.log(' No migrations to roll back based on criteria.');\n return { rolledBack: [] };\n }\n \n console.log(` Rolling back ${migrationsToRollback.length} migrations:`);\n migrationsToRollback.forEach(m => {\n console.log(` ${m.version}: ${m.name}`);\n });\n \n if (this.config.dryRun) {\n console.log(' Dry run mode - no changes will be applied');\n return { rolledBack: [] };\n }\n \n // Create database backup\n if (createBackup) {\n await this.createBackup(`before_rollback_${Date.now()}`);\n }\n \n const rolledBackMigrations = [];\n \n for (const migration of migrationsToRollback) {\n console.log(`\\n⏪ Rolling back migration ${migration.version}: ${migration.name}`);\n \n try {\n await this.rollbackMigration(migration);\n rolledBackMigrations.push(migration);\n console.log(` Rollback of ${migration.version} completed`);\n } catch (error) {\n console.error(` Rollback of ${migration.version} failed:`, error.message);\n throw new Error(`Rollback failed at migration ${migration.version}: ${error.message}`);\n }\n }\n \n console.log(`\\n Successfully rolled back ${rolledBackMigrations.length} migrations`);\n \n return { rolledBack: rolledBackMigrations };\n \n } catch (error) {\n console.error(' Rollback process failed:', error.message);\n throw error;\n }\n }\n \n async rollbackMigration(migration) {\n const client = this.client;\n \n try {\n if (!migration.rollback_sql) {\n throw new Error(`No rollback script available for migration ${migration.version}`);\n }\n \n // Begin transaction\n await client.query('BEGIN');\n \n // Update migration status\n await client.query(\n 'UPDATE schema_migrations SET status = $1 WHERE version = $2',\n ['ROLLING_BACK', migration.version]\n );\n \n // Execute rollback SQL\n const rollbackStatements = this.parseSQLStatements(migration.rollback_sql);\n \n for (const statement of rollbackStatements) {\n if (statement.trim()) {\n await client.query(statement);\n }\n }\n \n // Update migration status\n await client.query(\n 'UPDATE schema_migrations SET status = $1 WHERE version = $2',\n ['ROLLED_BACK', migration.version]\n );\n \n // Commit transaction\n await client.query('COMMIT');\n \n } catch (error) {\n // Rollback transaction\n await client.query('ROLLBACK');\n throw error;\n }\n }\n \n // ============================================\n // BACKUP AND RESTORE\n // ============================================\n \n async createBackup(backupName) {\n try {\n console.log(` Creating database backup: ${backupName}`);\n \n // Ensure backup directory exists\n await fs.mkdir(this.config.backupDir, { recursive: true });\n \n const backupFile = path.join(this.config.backupDir, `${backupName}.sql`);\n \n // Use pg_dump to create backup\n const { spawn } = require('child_process');\n \n return new Promise((resolve, reject) => {\n const pgDump = spawn('pg_dump', [\n '--host', this.config.host,\n '--port', this.config.port,\n '--username', this.config.username,\n '--dbname', this.config.database,\n '--file', backupFile,\n '--verbose',\n '--no-password'\n ], {\n env: { ...process.env, PGPASSWORD: this.config.password }\n });\n \n pgDump.on('close', (code) => {\n if (code === 0) {\n console.log(` Backup created successfully: ${backupFile}`);\n resolve(backupFile);\n } else {\n reject(new Error(`pg_dump exited with code ${code}`));\n }\n });\n \n pgDump.on('error', (error) => {\n reject(new Error(`Failed to spawn pg_dump: ${error.message}`));\n });\n });\n \n } catch (error) {\n console.warn(` Backup creation failed: ${error.message}`);\n // Don't fail the migration for backup issues\n }\n }\n \n // ============================================\n // UTILITY METHODS\n // ============================================\n \n async getStatus() {\n try {\n const availableMigrations = await this.discoverMigrations();\n const appliedMigrations = await this.getAppliedMigrations();\n \n const appliedVersions = new Set(appliedMigrations.map(m => m.version));\n const pendingMigrations = availableMigrations.filter(m => \n !appliedVersions.has(m.version)\n );\n \n return {\n available: availableMigrations.length,\n applied: appliedMigrations.length,\n pending: pendingMigrations.length,\n appliedMigrations,\n pendingMigrations\n };\n } catch (error) {\n console.error(' Failed to get migration status:', error.message);\n throw error;\n }\n }\n \n parseSQLStatements(sql) {\n // Simple SQL statement parser\n // This is a basic implementation - you might want to use a proper SQL parser\n return sql\n .split(';')\n .map(stmt => stmt.trim())\n .filter(stmt => stmt && !stmt.startsWith('--'));\n }\n \n calculateChecksum(content) {\n return crypto.createHash('sha256').update(content).digest('hex').substring(0, 16);\n }\n \n async recordFailedMigration(migration, errorMessage) {\n try {\n await this.client.query(`\n UPDATE schema_migrations \n SET status = 'FAILED',\n execution_time_ms = EXTRACT(EPOCH FROM (NOW() - executed_at)) * 1000\n WHERE version = $1\n `, [migration.version]);\n } catch (error) {\n console.error('Failed to record migration failure:', error.message);\n }\n }\n}\n\n// ============================================\n// CLI INTERFACE\n// ============================================\n\nclass MigrationCLI {\n constructor() {\n this.manager = null;\n }\n \n async run() {\n const args = process.argv.slice(2);\n const command = args[0];\n \n try {\n this.manager = new MigrationManager(this.parseConfig(args));\n await this.manager.connect();\n \n switch (command) {\n case 'migrate':\n case 'up':\n await this.runMigrate(args);\n break;\n \n case 'rollback':\n case 'down':\n await this.runRollback(args);\n break;\n \n case 'status':\n await this.runStatus();\n break;\n \n case 'create':\n await this.runCreate(args);\n break;\n \n case 'backup':\n await this.runBackup(args);\n break;\n \n default:\n this.showHelp();\n process.exit(1);\n }\n \n } catch (error) {\n console.error(' Command failed:', error.message);\n process.exit(1);\n } finally {\n if (this.manager) {\n await this.manager.disconnect();\n }\n }\n }\n \n async runMigrate(args) {\n const options = {\n target: this.getArgValue(args, '--target'),\n force: args.includes('--force'),\n createBackup: !args.includes('--no-backup')\n };\n \n const result = await this.manager.migrate(options);\n \n if (result.applied.length > 0) {\n console.log('\\n Migration Summary:');\n result.applied.forEach(m => {\n console.log(` ${m.version}: ${m.name} (${m.executionTime}ms)`);\n });\n }\n }\n \n async runRollback(args) {\n const options = {\n target: this.getArgValue(args, '--target'),\n steps: parseInt(this.getArgValue(args, '--steps') || '1'),\n createBackup: !args.includes('--no-backup')\n };\n \n const result = await this.manager.rollback(options);\n \n if (result.rolledBack.length > 0) {\n console.log('\\n Rollback Summary:');\n result.rolledBack.forEach(m => {\n console.log(` ⏪ ${m.version}: ${m.name}`);\n });\n }\n }\n \n async runStatus() {\n const status = await this.manager.getStatus();\n \n console.log('\\n Migration Status:');\n console.log(` Available migrations: ${status.available}`);\n console.log(` Applied migrations: ${status.applied}`);\n console.log(` Pending migrations: ${status.pending}`);\n \n if (status.pendingMigrations.length > 0) {\n console.log('\\n⏳ Pending Migrations:');\n status.pendingMigrations.forEach(m => {\n console.log(` ${m.version}: ${m.name}`);\n });\n }\n \n if (status.appliedMigrations.length > 0) {\n console.log('\\n Applied Migrations:');\n status.appliedMigrations\n .sort((a, b) => b.version.localeCompare(a.version))\n .slice(0, 10)\n .forEach(m => {\n const status_icon = m.status === 'COMPLETED' ? '' : \n m.status === 'FAILED' ? '' : '⏳';\n console.log(` ${status_icon} ${m.version}: ${m.name} (${m.executed_at})`);\n });\n }\n }\n \n async runCreate(args) {\n const name = args[1];\n if (!name) {\n console.error(' Migration name is required');\n process.exit(1);\n }\n \n const availableMigrations = await this.manager.discoverMigrations();\n const lastVersion = availableMigrations.length > 0 ? \n Math.max(...availableMigrations.map(m => parseInt(m.version))) : 0;\n \n const newVersion = String(lastVersion + 1).padStart(3, '0');\n const filename = `${newVersion}_${name.replace(/\\s+/g, '_').toLowerCase()}.sql`;\n const filepath = path.join(this.manager.config.migrationsDir, filename);\n \n const template = this.getMigrationTemplate(newVersion, name);\n \n await fs.writeFile(filepath, template);\n console.log(` Created migration: ${filepath}`);\n }\n \n async runBackup(args) {\n const backupName = args[1] || `manual_backup_${Date.now()}`;\n await this.manager.createBackup(backupName);\n }\n \n parseConfig(args) {\n return {\n dryRun: args.includes('--dry-run'),\n host: this.getArgValue(args, '--host'),\n port: this.getArgValue(args, '--port'),\n database: this.getArgValue(args, '--database'),\n username: this.getArgValue(args, '--username'),\n password: this.getArgValue(args, '--password'),\n };\n }\n \n getArgValue(args, argName) {\n const index = args.indexOf(argName);\n return index !== -1 && index + 1 < args.length ? args[index + 1] : null;\n }\n \n getMigrationTemplate(version, name) {\n return `-- ============================================\n-- MIGRATION ${version}: ${name.toUpperCase()}\n-- Description: TODO - Add description\n-- ============================================\n\nBEGIN;\n\n-- TODO: Add your migration SQL here\n\n-- Example:\n-- CREATE TABLE example_table (\n-- id TEXT PRIMARY KEY DEFAULT gen_random_uuid(),\n-- name TEXT NOT NULL,\n-- created_at TIMESTAMP DEFAULT NOW()\n-- );\n\n-- CREATE INDEX IF NOT EXISTS idx_example_name ON example_table(name);\n\nCOMMIT;\n\n-- ============================================\n-- ROLLBACK SCRIPT\n-- ============================================\n-- TODO: Add rollback SQL (will be executed in reverse order)\n\n-- Example:\n-- DROP TABLE IF EXISTS example_table;\n`;\n }\n \n showHelp() {\n console.log(`\n Database Migration Manager\n\nUsage: node migration_manager.js <command> [options]\n\nCommands:\n migrate, up Apply pending migrations\n rollback, down Rollback applied migrations\n status Show migration status\n create <name> Create new migration file\n backup <name> Create database backup\n\nOptions:\n --target <version> Migrate to specific version\n --steps <number> Number of migrations to rollback (default: 1)\n --force Force apply migrations (ignore checksum)\n --dry-run Show what would be done without executing\n --no-backup Skip creating backup before migrations\n \n --host <host> Database host\n --port <port> Database port\n --database <name> Database name\n --username <user> Database username\n --password <pass> Database password\n\nExamples:\n node migration_manager.js migrate\n node migration_manager.js migrate --target 005\n node migration_manager.js rollback --steps 3\n node migration_manager.js status\n node migration_manager.js create \"Add user roles\"\n`);\n }\n}\n\n// ============================================\n// EXECUTION\n// ============================================\n\nif (require.main === module) {\n const cli = new MigrationCLI();\n cli.run().catch(console.error);\n}\n\nmodule.exports = { MigrationManager, MigrationCLI };