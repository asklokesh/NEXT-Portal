/** * Visual Testing Utilities * * Shared utilities and helpers for visual regression testing * to ensure consistent screenshot capture and comparison. */ import { Page, expect, Locator } from '@playwright/test'; import { promises as fs } from 'fs'; import path from 'path'; interface ScreenshotOptions { fullPage?: boolean; clip?: { x: number; y: number; width: number; height: number }; omitBackground?: boolean; animations?: 'disabled' | 'allow'; caret?: 'hide' | 'initial'; scale?: 'css' | 'device'; mask?: Locator[]; threshold?: number; maxDiffPixels?: number; mode?: 'strict' | 'balanced'; } interface VisualTestOptions { hideVolatileElements?: boolean; waitForStability?: boolean; mockAnimations?: boolean; customWait?: number; beforeScreenshot?: () => Promise<void>; } export class VisualTestUtils { constructor(private page: Page) {} /** * Hide elements that frequently change and cause visual test flakiness */ async hideVolatileElements(): Promise<void> { await this.page.addStyleTag({ content: ` /* Hide timestamp and time-based elements */ [data-testid*="timestamp"], [data-testid*="time"], [data-testid*="date"], [data-testid*="duration"], [data-testid*="last-updated"], [data-testid*="created-at"], [data-testid*="uptime"], .timestamp, .last-updated, .created-at, .uptime, /* Hide loading indicators and animations */ .animate-spin, .animate-pulse, .animate-bounce, .animate-ping, .spinner, .loading, /* Hide dynamic counters */ [data-testid*="counter"], [data-testid*="count"], .counter, .count-up, /* Hide version numbers that might change */ [data-testid="build-version"], [data-testid="app-version"], .build-info, /* Hide tooltips that might appear */ .tooltip, [role="tooltip"], /* Hide focus rings for consistent screenshots */ *:focus { outline: none !important; box-shadow: none !important; } /* Disable transitions for consistent screenshots */ *, *::before, *::after { animation-duration: 0s !important; animation-delay: 0s !important; transition-duration: 0s !important; transition-delay: 0s !important; } /* Hide scroll bars */ ::-webkit-scrollbar { display: none; } /* Ensure consistent font rendering */ * { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } `, }); } /** * Wait for page to be in a stable state for screenshot */ async waitForStability(timeout: number = 3000): Promise<void> { // Wait for network to be idle await this.page.waitForLoadState('networkidle', { timeout }); // Wait for fonts to load await this.page.evaluate(() => document.fonts.ready); // Wait for any pending JavaScript execution await this.page.evaluate(() => new Promise(resolve => setTimeout(resolve, 100))); // Wait for images to load await this.page.waitForFunction(() => { const images = Array.from(document.images); return images.every(img => img.complete); }, { timeout: 5000 }).catch(() => { console.warn('Some images may not have loaded completely'); }); // Wait for any lazy-loaded content await this.page.evaluate(() => { return new Promise<void>((resolve) => { if ('requestIdleCallback' in window) { window.requestIdleCallback(() => resolve()); } else { setTimeout(resolve, 100); } }); }); } /** * Mock authentication state for consistent testing */ async mockAuthState(role: 'admin' | 'user' | 'guest' = 'user'): Promise<void> { const authTokens = { admin: 'mock-admin-jwt-token-12345', user: 'mock-user-jwt-token-67890', guest: null, }; const userData = { admin: { id: 'admin-user-id', name: 'Test Admin', email: 'admin@example.com', role: 'admin', permissions: ['read', 'write', 'admin'], }, user: { id: 'regular-user-id', name: 'Test User', email: 'user@example.com', role: 'user', permissions: ['read'], }, guest: null, }; await this.page.evaluate( ({ token, user }) => { if (token) { localStorage.setItem('auth-token', token); localStorage.setItem('user-data', JSON.stringify(user)); } else { localStorage.removeItem('auth-token'); localStorage.removeItem('user-data'); } }, { token: authTokens[role], user: userData[role] } ); } /** * Set consistent viewport and browser settings */ async setupConsistentEnvironment(): Promise<void> { // Set timezone to UTC for consistent time display await this.page.emulateTimezone('UTC'); // Set consistent locale await this.page.setExtraHTTPHeaders({ 'Accept-Language': 'en-US,en;q=0.9', }); // Mock system preferences await this.page.evaluate(() => { // Mock date to fixed time for consistent screenshots const mockDate = new Date('2024-01-15T12:00:00Z'); global.Date = class extends Date { constructor(...args: any[]) { if (args.length === 0) { super(mockDate); } else { super(...args); } } static now() { return mockDate.getTime(); } } as any; // Mock performance.now() for consistent measurements if (typeof performance !== 'undefined' && performance.now) { let startTime = 0; performance.now = () => startTime += 16.67; // ~60fps } }); } /** * Take a screenshot with consistent options */ async screenshot( name: string, element?: Locator, options: ScreenshotOptions & VisualTestOptions = {} ): Promise<void> { const { hideVolatileElements = true, waitForStability = true, mockAnimations = true, customWait = 0, beforeScreenshot, ...screenshotOptions } = options; // Setup consistent environment if (hideVolatileElements) { await this.hideVolatileElements(); } // Wait for page stability if (waitForStability) { await this.waitForStability(); } // Custom wait if specified if (customWait > 0) { await this.page.waitForTimeout(customWait); } // Execute custom pre-screenshot logic if (beforeScreenshot) { await beforeScreenshot(); } // Default screenshot options const defaultOptions: ScreenshotOptions = { fullPage: true, animations: 'disabled', caret: 'hide', scale: 'css', threshold: 0.2, maxDiffPixels: 100, mode: 'strict', ...screenshotOptions, }; // Take screenshot if (element) { await expect(element).toHaveScreenshot(`${name}.png`, defaultOptions); } else { await expect(this.page).toHaveScreenshot(`${name}.png`, defaultOptions); } } /** * Compare two screenshots manually */ async compareScreenshots( baseline: string, current: string, threshold: number = 0.2 ): Promise<boolean> { try { const baselineBuffer = await fs.readFile(baseline); const currentBuffer = await fs.readFile(current); // Simple buffer comparison (in real implementation, you'd use image comparison library) if (baselineBuffer.length !== currentBuffer.length) { return false; } let differences = 0; for (let i = 0; i < baselineBuffer.length; i++) { if (baselineBuffer[i] !== currentBuffer[i]) { differences++; } } const diffPercentage = differences / baselineBuffer.length; return diffPercentage <= threshold; } catch (error) { console.error('Screenshot comparison failed:', error); return false; } } /** * Create test data fixtures for visual tests */ async setupVisualTestData(): Promise<void> { // Mock API responses with consistent data await this.page.route('**/api/plugins**', (route) => { const mockPlugins = [ { id: 'visual-test-plugin-1', name: 'Visual Test Plugin One', version: '1.0.0', description: 'A plugin designed specifically for visual testing with consistent data.', author: 'Test Author', category: 'Testing', tags: ['visual', 'test', 'stable'], icon: 'test-tube', downloadCount: 1000, rating: 4.5, reviews: 20, status: 'available', }, { id: 'visual-test-plugin-2', name: 'Visual Test Plugin Two', version: '2.1.0', description: 'Another plugin for visual regression testing with different properties.', author: 'Another Author', category: 'Development', tags: ['dev', 'tools'], icon: 'code', downloadCount: 2500, rating: 4.8, reviews: 45, status: 'installed', }, ]; route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify({ plugins: mockPlugins, total: mockPlugins.length, pagination: { page: 1, limit: 20, total: mockPlugins.length, totalPages: 1, }, }), }); }); // Mock user data await this.page.route('**/api/user**', (route) => { route.fulfill({ status: 200, contentType: 'application/json', body: JSON.stringify({ id: 'visual-test-user', name: 'Visual Test User', email: 'visual@test.com', role: 'user', }), }); }); } /** * Generate baseline screenshots */ async generateBaselines(testName: string): Promise<void> { const baselineDir = path.resolve('./tests/visual/screenshots/baseline'); await fs.mkdir(baselineDir, { recursive: true }); console.log(`Generating baseline screenshots for: ${testName}`); // Implementation would go here to systematically capture baseline images } /** * Validate screenshot differences */ async validateScreenshotDifferences(testResults: any): Promise<void> { const failedTests = testResults.filter((result: any) => !result.passed); if (failedTests.length > 0) { console.log('\n Visual regression test failures:'); failedTests.forEach((test: any) => { console.log(` ${test.name}: ${test.error}`); console.log(` Baseline: ${test.baseline}`); console.log(` Actual: ${test.actual}`); console.log(` Diff: ${test.diff}`); }); } } /** * Clean up old screenshots and test artifacts */ async cleanupOldScreenshots(daysToKeep: number = 7): Promise<void> { const cutoffDate = new Date(); cutoffDate.setDate(cutoffDate.getDate() - daysToKeep); const directories = [ './tests/visual/screenshots/actual', './tests/visual/screenshots/diff', './tests/visual/test-results', ]; for (const dir of directories) { try { const files = await fs.readdir(path.resolve(dir)); for (const file of files) { const filePath = path.resolve(dir, file); const stats = await fs.stat(filePath); if (stats.mtime < cutoffDate) { await fs.unlink(filePath); console.log(`Cleaned up old screenshot: ${file}`); } } } catch (error) { // Directory might not exist, that's okay } } } } /** * Responsive breakpoints for visual testing */ export const VISUAL_BREAKPOINTS = { mobile: { width: 375, height: 667 }, mobileLandscape: { width: 667, height: 375 }, tablet: { width: 768, height: 1024 }, tabletLandscape: { width: 1024, height: 768 }, desktop: { width: 1280, height: 720 }, desktopLarge: { width: 1920, height: 1080 }, desktopXL: { width: 2560, height: 1440 }, }; /** * Common screenshot options for different scenarios */ export const SCREENSHOT_OPTIONS = { component: { fullPage: false, animations: 'disabled' as const, caret: 'hide' as const, threshold: 0.1, }, page: { fullPage: true, animations: 'disabled' as const, caret: 'hide' as const, threshold: 0.2, }, modal: { fullPage: false, animations: 'disabled' as const, caret: 'hide' as const, threshold: 0.15, }, mobile: { fullPage: true, animations: 'disabled' as const, caret: 'hide' as const, threshold: 0.25, // Higher threshold for mobile due to rendering differences }, }; /** * Test data generators for consistent visual tests */ export const VISUAL_TEST_DATA = { plugins: [ { id: 'visual-plugin-1', name: 'Consistent Test Plugin', version: '1.0.0', description: 'A plugin with stable visual properties for testing', downloadCount: 1234, rating: 4.5, reviews: 67, }, { id: 'visual-plugin-2', name: 'Another Test Plugin', version: '2.1.0', description: 'Second plugin for grid layout testing', downloadCount: 5678, rating: 4.8, reviews: 123, }, ], users: [ { id: 'visual-user-1', name: 'Test User', email: 'test@visual.com', role: 'user', }, ], };