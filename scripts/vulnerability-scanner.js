#!/usr/bin/env node

/**
 * Dependency Vulnerability Scanner
 * Scans npm dependencies for known security vulnerabilities
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

// Configuration
const config = {
  reportPath: process.env.VULN_REPORT_PATH || './vulnerability-report.json',
  severityThreshold: process.env.VULN_SEVERITY_THRESHOLD || 'moderate',
  exitOnVulns: process.env.VULN_EXIT_ON_FOUND !== 'false',
  packageFiles: [
    './package.json',
    './backstage/package.json',
    './backstage/packages/app/package.json',
    './backstage/packages/backend/package.json'
  ]
};

// Severity levels in order of importance
const severityLevels = {
  'info': 0,
  'low': 1,
  'moderate': 2,
  'high': 3,
  'critical': 4
};

class VulnerabilityScanner {
  constructor() {
    this.results = [];
    this.startTime = Date.now();
    this.stats = {
      total_packages: 0,
      vulnerabilities: {
        info: 0,
        low: 0,
        moderate: 0,
        high: 0,
        critical: 0
      },
      packages_scanned: 0,
      packages_with_vulnerabilities: 0
    };
  }

  async scanProject() {
    console.log('🔍 Dependency Vulnerability Scanner');
    console.log('='.repeat(50));
    console.log(`Severity Threshold: ${config.severityThreshold}`);
    console.log(`Exit on Vulnerabilities: ${config.exitOnVulns}`);
    console.log('');

    try {
      // Check if npm audit is available
      await this.checkNpmAuditAvailable();

      // Scan each package.json file
      for (const packageFile of config.packageFiles) {
        if (fs.existsSync(packageFile)) {
          console.log(`📦 Scanning ${packageFile}...`);
          await this.scanPackageFile(packageFile);
        } else {
          console.log(`⚠️  Skipping ${packageFile} (not found)`);
        }
      }

      // Generate report
      await this.generateReport();
      this.printSummary();
      
      return this.shouldExitWithError();

    } catch (error) {
      console.error(`💥 Scanner failed: ${error.message}`);
      throw error;
    }
  }

  async checkNpmAuditAvailable() {
    try {
      execSync('npm audit --version', { stdio: 'ignore' });
    } catch (error) {
      throw new Error('npm audit command not available. Please ensure npm is installed and up to date.');
    }
  }

  async scanPackageFile(packagePath) {
    const packageDir = path.dirname(packagePath);
    const packageName = path.basename(packageDir) || 'root';

    try {
      // Read package.json to get dependency count
      const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      const depCount = Object.keys({
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      }).length;

      console.log(`   Dependencies: ${depCount}`);
      this.stats.total_packages += depCount;

      // Run npm audit
      const auditResult = await this.runNpmAudit(packageDir);
      
      if (auditResult) {
        this.results.push({
          package: packageName,
          path: packagePath,
          dependencies: depCount,
          vulnerabilities: auditResult.vulnerabilities || {},
          advisories: auditResult.advisories || {},
          metadata: auditResult.metadata || {}
        });

        this.updateStats(auditResult);
        this.printPackageResults(packageName, auditResult);
      }

      this.stats.packages_scanned++;

    } catch (error) {
      console.error(`   ❌ Error scanning ${packagePath}: ${error.message}`);
      this.results.push({
        package: packageName,
        path: packagePath,
        error: error.message,
        vulnerabilities: {},
        advisories: {},
        metadata: {}
      });
    }
  }

  async runNpmAudit(directory) {
    return new Promise((resolve, reject) => {
      const auditProcess = spawn('npm', ['audit', '--json'], {
        cwd: directory,
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      auditProcess.stdout.on('data', (data) => {
        stdout += data;
      });

      auditProcess.stderr.on('data', (data) => {
        stderr += data;
      });

      auditProcess.on('close', (code) => {
        try {
          // npm audit returns non-zero exit codes when vulnerabilities are found
          // This is expected behavior, so we don't treat it as an error
          if (stdout.trim()) {
            const result = JSON.parse(stdout);
            resolve(result);
          } else if (stderr.includes('ENOENT') || stderr.includes('no such file')) {
            // No package-lock.json or node_modules
            console.log('   ⚠️  No package-lock.json found, running npm install...');
            this.runNpmInstall(directory)
              .then(() => this.runNpmAudit(directory))
              .then(resolve)
              .catch(reject);
          } else {
            resolve({ vulnerabilities: {}, advisories: {}, metadata: {} });
          }
        } catch (parseError) {
          if (stderr.trim()) {
            reject(new Error(`npm audit failed: ${stderr}`));
          } else {
            resolve({ vulnerabilities: {}, advisories: {}, metadata: {} });
          }
        }
      });

      auditProcess.on('error', (error) => {
        reject(new Error(`Failed to run npm audit: ${error.message}`));
      });
    });
  }

  async runNpmInstall(directory) {
    return new Promise((resolve, reject) => {
      console.log('   📥 Installing dependencies...');
      const installProcess = spawn('npm', ['install'], {
        cwd: directory,
        stdio: 'inherit'
      });

      installProcess.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`npm install failed with exit code ${code}`));
        }
      });

      installProcess.on('error', (error) => {
        reject(new Error(`Failed to run npm install: ${error.message}`));
      });
    });
  }

  updateStats(auditResult) {
    if (auditResult.vulnerabilities) {
      Object.entries(auditResult.vulnerabilities).forEach(([severity, count]) => {
        if (this.stats.vulnerabilities.hasOwnProperty(severity)) {
          this.stats.vulnerabilities[severity] += count;
        }
      });
    }

    // Check if this package has vulnerabilities
    const hasVulns = Object.values(auditResult.vulnerabilities || {}).some(count => count > 0);
    if (hasVulns) {
      this.stats.packages_with_vulnerabilities++;
    }
  }

  printPackageResults(packageName, auditResult) {
    const vulns = auditResult.vulnerabilities || {};
    const totalVulns = Object.values(vulns).reduce((sum, count) => sum + count, 0);

    if (totalVulns === 0) {
      console.log('   ✅ No vulnerabilities found');
    } else {
      console.log(`   ⚠️  Found ${totalVulns} vulnerabilities:`);
      
      Object.entries(vulns).forEach(([severity, count]) => {
        if (count > 0) {
          const icon = this.getSeverityIcon(severity);
          console.log(`      ${icon} ${severity}: ${count}`);
        }
      });

      // Show high/critical advisories
      if (auditResult.advisories) {
        const criticalAdvisories = Object.values(auditResult.advisories)
          .filter(advisory => advisory.severity === 'high' || advisory.severity === 'critical')
          .slice(0, 3); // Show top 3

        criticalAdvisories.forEach(advisory => {
          console.log(`      🚨 ${advisory.title} (${advisory.module_name})`);
        });
      }
    }
  }

  getSeverityIcon(severity) {
    switch (severity) {
      case 'critical': return '🔥';
      case 'high': return '🚨';
      case 'moderate': return '⚠️';
      case 'low': return '💡';
      case 'info': return 'ℹ️';
      default: return '❓';
    }
  }

  async generateReport() {
    const totalVulns = Object.values(this.stats.vulnerabilities).reduce((sum, count) => sum + count, 0);
    const highRiskVulns = this.stats.vulnerabilities.high + this.stats.vulnerabilities.critical;

    const report = {
      timestamp: new Date().toISOString(),
      config,
      stats: this.stats,
      duration: Date.now() - this.startTime,
      results: this.results,
      summary: {
        total_vulnerabilities: totalVulns,
        high_risk_vulnerabilities: highRiskVulns,
        packages_affected: this.stats.packages_with_vulnerabilities,
        risk_level: this.calculateRiskLevel(),
        recommendations: this.generateRecommendations()
      },
      detailed_advisories: this.extractDetailedAdvisories()
    };

    try {
      const reportDir = path.dirname(config.reportPath);
      if (!fs.existsSync(reportDir)) {
        fs.mkdirSync(reportDir, { recursive: true });
      }
      
      fs.writeFileSync(config.reportPath, JSON.stringify(report, null, 2));
      console.log(`\n📊 Vulnerability report: ${config.reportPath}`);
    } catch (error) {
      console.error(`Failed to generate report: ${error.message}`);
    }

    return report;
  }

  extractDetailedAdvisories() {
    const advisories = [];
    
    this.results.forEach(result => {
      if (result.advisories) {
        Object.values(result.advisories).forEach(advisory => {
          advisories.push({
            package: result.package,
            ...advisory,
            severity_level: severityLevels[advisory.severity] || 0
          });
        });
      }
    });

    // Sort by severity (highest first) and return top 20
    return advisories
      .sort((a, b) => b.severity_level - a.severity_level)
      .slice(0, 20);
  }

  calculateRiskLevel() {
    const { critical, high, moderate } = this.stats.vulnerabilities;
    
    if (critical > 0) return 'CRITICAL';
    if (high > 5) return 'HIGH';
    if (high > 0 || moderate > 10) return 'MEDIUM';
    if (moderate > 0) return 'LOW';
    return 'MINIMAL';
  }

  generateRecommendations() {
    const recommendations = [];
    const { critical, high, moderate, low } = this.stats.vulnerabilities;

    if (critical > 0) {
      recommendations.push({
        priority: 'immediate',
        action: 'Fix critical vulnerabilities immediately',
        description: `${critical} critical vulnerabilities require immediate attention`,
        commands: ['npm audit fix --force', 'npm update']
      });
    }

    if (high > 0) {
      recommendations.push({
        priority: 'high',
        action: 'Address high severity vulnerabilities',
        description: `${high} high severity vulnerabilities should be fixed soon`,
        commands: ['npm audit fix', 'npm update']
      });
    }

    if (moderate > 5) {
      recommendations.push({
        priority: 'medium',
        action: 'Review and fix moderate vulnerabilities',
        description: `${moderate} moderate vulnerabilities detected`,
        commands: ['npm audit', 'npm outdated', 'npm update']
      });
    }

    if (this.stats.packages_with_vulnerabilities > 0) {
      recommendations.push({
        priority: 'ongoing',
        action: 'Implement automated vulnerability scanning',
        description: 'Set up regular dependency scanning in CI/CD pipeline',
        commands: ['npm audit', 'setup vulnerability scanning in CI']
      });
    }

    return recommendations;
  }

  printSummary() {
    console.log('');
    console.log('🛡️ Vulnerability Scan Summary');
    console.log('='.repeat(50));
    
    const totalVulns = Object.values(this.stats.vulnerabilities).reduce((sum, count) => sum + count, 0);
    
    console.log(`📦 Packages Scanned: ${this.stats.packages_scanned}`);
    console.log(`📊 Total Dependencies: ${this.stats.total_packages}`);
    console.log(`⚠️  Packages with Vulnerabilities: ${this.stats.packages_with_vulnerabilities}`);
    console.log(`🔍 Total Vulnerabilities: ${totalVulns}`);
    console.log('');

    if (totalVulns > 0) {
      console.log('Vulnerability Breakdown:');
      Object.entries(this.stats.vulnerabilities).forEach(([severity, count]) => {
        if (count > 0) {
          const icon = this.getSeverityIcon(severity);
          console.log(`  ${icon} ${severity.charAt(0).toUpperCase() + severity.slice(1)}: ${count}`);
        }
      });
      console.log('');
    }

    const riskLevel = this.calculateRiskLevel();
    const riskIcon = this.getRiskIcon(riskLevel);
    console.log(`${riskIcon} Risk Level: ${riskLevel}`);
    
    const duration = Math.round((Date.now() - this.startTime) / 1000);
    console.log(`⏱️  Scan Duration: ${duration}s`);
    console.log('='.repeat(50));

    // Show immediate actions if needed
    if (this.stats.vulnerabilities.critical > 0 || this.stats.vulnerabilities.high > 0) {
      console.log('');
      console.log('🚨 Immediate Actions Required:');
      console.log('  1. Run: npm audit fix');
      console.log('  2. Review: npm audit');
      console.log('  3. Update: npm update');
      console.log('');
    }
  }

  getRiskIcon(riskLevel) {
    switch (riskLevel) {
      case 'CRITICAL': return '🔥';
      case 'HIGH': return '🚨';
      case 'MEDIUM': return '⚠️';
      case 'LOW': return '💡';
      case 'MINIMAL': return '✅';
      default: return '❓';
    }
  }

  shouldExitWithError() {
    if (!config.exitOnVulns) return false;

    const thresholdLevel = severityLevels[config.severityThreshold] || 0;
    
    // Check if we have vulnerabilities at or above the threshold
    for (const [severity, count] of Object.entries(this.stats.vulnerabilities)) {
      if (count > 0 && severityLevels[severity] >= thresholdLevel) {
        return true;
      }
    }

    return false;
  }
}

// CLI execution
if (require.main === module) {
  const scanner = new VulnerabilityScanner();
  scanner.scanProject()
    .then(shouldFail => {
      process.exit(shouldFail ? 1 : 0);
    })
    .catch(error => {
      console.error('💥 Vulnerability scan failed:', error.message);
      process.exit(1);
    });
}

module.exports = { VulnerabilityScanner, config };