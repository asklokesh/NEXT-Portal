#!/usr/bin/env node /** * Case Sensitivity Checker * Prevents case sensitivity issues across different filesystems */ const fs = require('fs').promises; const path = require('path'); const { execSync } = require('child_process'); class CaseSensitivityChecker { constructor() { this.issues = []; this.knownComponents = new Map(); this.srcDir = './src'; } async check() { console.log(' Checking for case sensitivity issues...\n'); try { // Step 1: Map all component files await this.mapComponents(); // Step 2: Check imports in TypeScript/JavaScript files await this.checkImports(); // Step 3: Check path references await this.checkPathReferences(); // Step 4: Report findings this.reportFindings(); return this.issues.length === 0; } catch (error) { console.error(' Case sensitivity check failed:', error.message); return false; } } async mapComponents() { console.log(' Mapping component files...'); const files = await this.getAllFiles(this.srcDir, /\.(ts|tsx|js|jsx)$/); for (const file of files) { const basename = path.basename(file, path.extname(file)); const dirname = path.dirname(file); const relativePath = path.relative(this.srcDir, file); // Store both the actual case and lowercase version const key = relativePath.toLowerCase(); if (this.knownComponents.has(key)) { const existing = this.knownComponents.get(key); if (existing.path !== relativePath) { this.issues.push({ type: 'duplicate_case', message: `Potential case conflict between "${existing.path}" and "${relativePath}"`, files: [existing.path, relativePath] }); } } else { this.knownComponents.set(key, { path: relativePath, basename: basename, actualCase: basename }); } } console.log(` Found ${this.knownComponents.size} component files\n`); } async checkImports() { console.log(' Checking import statements...'); const files = await this.getAllFiles(this.srcDir, /\.(ts|tsx|js|jsx)$/); for (const file of files) { await this.checkFileImports(file); } console.log(' Import check completed\n'); } async checkFileImports(filePath) { try { const content = await fs.readFile(filePath, 'utf8'); const lines = content.split('\n'); for (let i = 0; i < lines.length; i++) { const line = lines[i]; const importMatch = line.match(/import.*from\s+['"`]([^'"`]+)['"`]/); if (importMatch) { const importPath = importMatch[1]; await this.validateImportPath(filePath, importPath, i + 1); } } } catch (error) { console.log(` Warning: Could not check imports in ${filePath}`); } } async validateImportPath(filePath, importPath, lineNumber) { // Check relative imports starting with . or @/ if (importPath.startsWith('./') || importPath.startsWith('../') || importPath.startsWith('@/')) { let resolvedPath; if (importPath.startsWith('@/')) { // Handle path mapping resolvedPath = importPath.replace('@/', ''); } else { // Handle relative imports const fileDir = path.dirname(filePath); resolvedPath = path.normalize(path.join(fileDir, importPath)); resolvedPath = path.relative(this.srcDir, resolvedPath); } // Check if this import has case issues const normalizedPath = resolvedPath.toLowerCase(); // Look for the component in our map const component = this.knownComponents.get(normalizedPath) || this.knownComponents.get(normalizedPath + '.tsx') || this.knownComponents.get(normalizedPath + '.ts') || this.knownComponents.get(normalizedPath + '/index.tsx') || this.knownComponents.get(normalizedPath + '/index.ts'); if (component && component.path !== resolvedPath) { // Check common case sensitivity issues if (importPath.includes('/skeleton') && component.path.includes('/Skeleton')) { this.issues.push({ type: 'case_mismatch', message: `Case mismatch in import: "${importPath}" should be "${component.path}"`, file: filePath, line: lineNumber, expected: component.path, actual: importPath }); } else if (importPath.toLowerCase() !== component.path.toLowerCase()) { // General case mismatch this.issues.push({ type: 'case_mismatch', message: `Potential case mismatch in import: "${importPath}" vs "${component.path}"`, file: filePath, line: lineNumber, expected: component.path, actual: importPath }); } } } } async checkPathReferences() { console.log(' Checking path references...'); // Check for common case sensitivity patterns const patterns = [ { pattern: /skeleton/gi, correct: 'Skeleton' }, { pattern: /button/gi, correct: 'Button' }, { pattern: /dialog/gi, correct: 'Dialog' }, { pattern: /card/gi, correct: 'Card' }, ]; const files = await this.getAllFiles(this.srcDir, /\.(ts|tsx|js|jsx)$/); for (const file of files) { const content = await fs.readFile(file, 'utf8'); // Check for import statements with incorrect casing const importLines = content.match(/import.*from\s+['"`][^'"`]*['"`]/g) || []; for (const importLine of importLines) { for (const { pattern, correct } of patterns) { const matches = importLine.match(pattern); if (matches) { for (const match of matches) { if (match !== correct && match.toLowerCase() === correct.toLowerCase()) { this.issues.push({ type: 'import_case', message: `Import path case issue: "${match}" should be "${correct}"`, file: path.relative(process.cwd(), file), line: importLine, expected: correct, actual: match }); } } } } } } console.log(' Path reference check completed\n'); } async getAllFiles(dir, pattern) { const files = []; async function walk(currentDir) { const entries = await fs.readdir(currentDir, { withFileTypes: true }); for (const entry of entries) { const fullPath = path.join(currentDir, entry.name); if (entry.isDirectory()) { // Skip node_modules, .next, etc. if (!entry.name.startsWith('.') && entry.name !== 'node_modules' && entry.name !== '__tests__' && entry.name !== '__mocks__') { await walk(fullPath); } } else if (entry.isFile() && pattern.test(entry.name)) { files.push(fullPath); } } } await walk(dir); return files; } reportFindings() { console.log(' Case Sensitivity Report'); console.log('=' * 50); if (this.issues.length === 0) { console.log(' No case sensitivity issues found!'); return; } console.log(` Found ${this.issues.length} case sensitivity issues:\n`); const groupedIssues = this.groupIssuesByType(); for (const [type, issues] of Object.entries(groupedIssues)) { console.log(` ${type.toUpperCase().replace('_', ' ')}:`); for (const issue of issues) { console.log(` ${issue.message}`); if (issue.file) { console.log(` File: ${issue.file}${issue.line ? `:${issue.line}` : ''}`); } if (issue.expected && issue.actual) { console.log(` Expected: ${issue.expected}`); console.log(` Actual: ${issue.actual}`); } console.log(); } } // Generate fix suggestions this.generateFixSuggestions(); } groupIssuesByType() { return this.issues.reduce((groups, issue) => { const type = issue.type || 'unknown'; if (!groups[type]) groups[type] = []; groups[type].push(issue); return groups; }, {}); } generateFixSuggestions() { console.log(' Fix Suggestions:'); console.log('-'.repeat(30)); const caseMismatchIssues = this.issues.filter(i => i.type === 'case_mismatch'); if (caseMismatchIssues.length > 0) { console.log('1. Update import statements:'); caseMismatchIssues.forEach(issue => { if (issue.file && issue.expected && issue.actual) { console.log(` sed -i 's|${issue.actual}|${issue.expected}|g' "${issue.file}"`); } }); console.log(); } console.log('2. To automatically fix common issues, run:'); console.log(' npm run lint:case-sensitivity -- --fix'); console.log(); console.log('3. To prevent future issues, ensure your editor:'); console.log(' - Has case-sensitive file matching enabled'); console.log(' - Uses the provided ESLint configuration'); console.log(' - Has import auto-completion properly configured'); } } // Auto-fix capability async function autoFix() { console.log(' Attempting automatic fixes...\n'); // Common fixes const fixes = [ { pattern: /import\s+{([^}]*)}\s+from\s+['"`]@\/components\/ui\/skeleton['"`]/g, replacement: 'import {$1} from "@/components/ui/Skeleton"' }, { pattern: /from\s+['"`]([^'"`]*\/ui\/skeleton)['"`]/g, replacement: 'from "$1".replace("skeleton", "Skeleton")' } ]; // Apply fixes would go here... console.log(' Automatic fixes applied (if any)'); } // CLI interface if (require.main === module) { const checker = new CaseSensitivityChecker(); const shouldFix = process.argv.includes('--fix'); if (shouldFix) { autoFix().then(() => { return checker.check(); }).then(success => { process.exit(success ? 0 : 1); }).catch(error => { console.error('Error:', error); process.exit(1); }); } else { checker.check().then(success => { process.exit(success ? 0 : 1); }).catch(error => { console.error('Error:', error); process.exit(1); }); } } module.exports = { CaseSensitivityChecker };