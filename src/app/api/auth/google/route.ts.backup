import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { randomBytes } from 'crypto';
import { sessionRedis } from '@/lib/db/client';
import { createAuditLog } from '@/lib/audit/service';

// Enhanced OAuth configuration validation for Google
const validateGoogleOAuthConfig = () => {
  const clientId = process.env.GOOGLE_CLIENT_ID;
  const clientSecret = process.env.GOOGLE_CLIENT_SECRET;
  const appUrl = process.env.NEXT_PUBLIC_APP_URL;
  
  if (!clientId || !clientSecret) {
    throw new Error('Google OAuth credentials not configured');
  }
  
  if (!appUrl) {
    throw new Error('Application URL not configured');
  }
  
  return { clientId, clientSecret, appUrl };
};

export async function GET(req: NextRequest) {
  const startTime = Date.now();
  const ipAddress = req.ip || req.headers.get('x-forwarded-for') || 'unknown';
  const userAgent = req.headers.get('user-agent') || 'unknown';
  
  try {
    // Validate OAuth configuration
    const { clientId, appUrl } = validateGoogleOAuthConfig();
    
    const url = new URL(req.url);
    const returnTo = url.searchParams.get('returnTo') || '/dashboard';
    
    // Validate returnTo parameter to prevent open redirects
    const allowedRedirectPaths = ['/dashboard', '/plugins', '/services', '/teams'];
    let validatedReturnTo = '/dashboard';
    
    if (returnTo.startsWith('/') && !returnTo.startsWith('//')) {
      const pathSegment = returnTo.split('?')[0];
      if (allowedRedirectPaths.some(path => pathSegment.startsWith(path))) {
        validatedReturnTo = returnTo;
      }
    }

    // Generate cryptographically secure state parameter
    const stateToken = randomBytes(32).toString('hex');
    const stateData = {
      returnTo: validatedReturnTo,
      timestamp: Date.now(),
      nonce: randomBytes(16).toString('hex'),
      provider: 'google'
    };

    // Store state in Redis with 10 minute expiration
    await sessionRedis.setex(
      `oauth_state:${stateToken}`,
      600, // 10 minutes
      JSON.stringify(stateData)
    );

    const redirectUri = `${appUrl}/api/auth/google/callback`;
    
    // Enhanced scope for Google OAuth
    const scope = [
      'openid',
      'profile',
      'email'
    ].join(' ');

    // Build Google OAuth URL with enhanced security parameters
    const googleOAuthUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');
    googleOAuthUrl.searchParams.set('client_id', clientId);
    googleOAuthUrl.searchParams.set('redirect_uri', redirectUri);
    googleOAuthUrl.searchParams.set('scope', scope);
    googleOAuthUrl.searchParams.set('state', stateToken);
    googleOAuthUrl.searchParams.set('response_type', 'code');
    googleOAuthUrl.searchParams.set('access_type', 'offline');
    googleOAuthUrl.searchParams.set('prompt', 'consent');
    
    // Add security parameters
    googleOAuthUrl.searchParams.set('include_granted_scopes', 'false');

    // Log OAuth initiation
    await createAuditLog({
      action: 'oauth.google.initiated',
      resource: 'authentication',
      resourceId: null,
      userId: null,
      details: {
        returnTo: validatedReturnTo,
        ipAddress,
        userAgent,
        duration: Date.now() - startTime
      },
      status: 'success'
    });

    // Add security headers
    const response = NextResponse.redirect(googleOAuthUrl.toString());
    response.headers.set('X-Frame-Options', 'DENY');
    response.headers.set('X-Content-Type-Options', 'nosniff');
    response.headers.set('Referrer-Policy', 'no-referrer');

    return response;
  } catch (error) {
    console.error('Google OAuth start error:', error);
    
    // Log OAuth error
    await createAuditLog({
      action: 'oauth.google.failed',
      resource: 'authentication',
      resourceId: null,
      userId: null,
      details: {
        error: error instanceof Error ? error.message : 'Unknown error',
        ipAddress,
        userAgent,
        duration: Date.now() - startTime
      },
      status: 'error'
    });

    // Return user-friendly error without exposing sensitive details
    return NextResponse.json(
      { 
        error: 'Authentication service temporarily unavailable',
        code: 'AUTH_CONFIG_ERROR'
      },
      { status: 503 }
    );
  }
}