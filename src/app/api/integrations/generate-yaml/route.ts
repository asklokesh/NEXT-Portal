import { NextRequest, NextResponse } from 'next/server';
import * as yaml from 'js-yaml';

export async function POST(request: NextRequest) {
 try {
 const config = await request.json();
 
 // Generate complete app-config.yaml content
 const yamlContent = generateAppConfigYaml(config);
 
 return new NextResponse(yamlContent, {
 headers: {
 'Content-Type': 'text/yaml',
 'Content-Disposition': 'attachment; filename="app-config.yaml"',
 },
 });
 } catch (error) {
 console.error('Failed to generate YAML:', error);
 return NextResponse.json(
 { error: 'Failed to generate configuration' },
 { status: 500 }
 );
 }
}

function generateAppConfigYaml(config: any): string {
 const appConfig: any = {
 app: {
 title: 'Backstage',
 baseUrl: 'http://localhost:4410',
 },
 organization: {
 name: 'My Company',
 },
 backend: {
 baseUrl: 'http://localhost:4410',
 listen: {
 port: 4410,
 },
 csp: {
 'connect-src': ["'self'", 'http:', 'https:'],
 },
 cors: {
 origin: 'http://localhost:4400',
 methods: ['GET', 'POST', 'PUT', 'DELETE'],
 credentials: true,
 },
 database: {
 client: 'better-sqlite3',
 connection: ':memory:',
 },
 },
 integrations: {},
 proxy: {},
 techdocs: {
 builder: 'local',
 generator: {
 runIn: 'docker',
 },
 publisher: {
 type: 'local',
 },
 },
 auth: {
 providers: {},
 },
 catalog: {
 import: {
 entityFilename: 'catalog-info.yaml',
 pullRequestBranchName: 'backstage-integration',
 },
 rules: [],
 locations: [],
 },
 };

 // Add integrations from providers
 config.providers.forEach((provider: any) => {
 if (!provider.enabled) return;

 switch (provider.type) {
 case 'github':
 if (!appConfig.integrations.github) {
 appConfig.integrations.github = [];
 }
 appConfig.integrations.github.push({
 host: provider.config.host || 'github.com',
 token: '${GITHUB_TOKEN}', // Use environment variable
 ...(provider.config.enterprise && { 
 apiBaseUrl: provider.config.apiBaseUrl,
 rawBaseUrl: provider.config.apiBaseUrl?.replace('/api', '/raw'),
 }),
 });
 break;

 case 'gitlab':
 if (!appConfig.integrations.gitlab) {
 appConfig.integrations.gitlab = [];
 }
 appConfig.integrations.gitlab.push({
 host: provider.config.host || 'gitlab.com',
 token: '${GITLAB_TOKEN}', // Use environment variable
 ...(provider.config.apiBaseUrl && { apiBaseUrl: provider.config.apiBaseUrl }),
 });
 break;

 case 'aws':
 appConfig.aws = {
 accounts: provider.config.accounts?.map((account: any) => ({
 accountId: account.accountId,
 roleArn: account.roleArn,
 region: account.region || 'us-east-1',
 ...(account.profile && { profile: account.profile }),
 })) || [],
 };
 break;
 }
 });

 // Add catalog locations
 config.locations.forEach((location: any) => {
 if (!location.enabled) return;

 switch (location.type) {
 case 'url':
 appConfig.catalog.locations.push({
 type: 'url',
 target: location.target,
 });
 break;

 case 'github-discovery':
 // Create a processor configuration
 appConfig.catalog.locations.push({
 type: 'github-org',
 target: `https://github.com/${location.target}`,
 rules: [
 {
 allow: [location.filters?.catalogPath || 'catalog-info.yaml'],
 ...(location.filters?.filters?.[0]?.include && {
 filter: location.filters.filters[0].include,
 }),
 },
 ],
 });
 break;

 case 'gitlab-discovery':
 appConfig.catalog.locations.push({
 type: 'gitlab-discovery',
 target: location.target,
 });
 break;
 }
 });

 // Add Kubernetes configuration if any K8s provider exists
 const k8sProvider = config.providers.find((p: any) => p.type === 'kubernetes' && p.enabled);
 if (k8sProvider) {
 appConfig.kubernetes = {
 serviceLocatorMethod: {
 type: 'multiTenant',
 },
 clusterLocatorMethods: [
 {
 type: 'config',
 clusters: k8sProvider.config.clusters?.map((cluster: any) => ({
 name: cluster.name,
 url: cluster.url,
 authProvider: cluster.authProvider,
 ...(cluster.skipTLSVerify && { skipTLSVerify: true }),
 ...(cluster.authProvider === 'serviceAccount' && {
 serviceAccountToken: '${KUBE_TOKEN}',
 }),
 })) || [],
 },
 ],
 };
 }

 // Add schedule configuration
 if (config.schedule) {
 appConfig.catalog.processingInterval = {
 frequency: { minutes: config.schedule.frequency },
 timeout: { seconds: config.schedule.timeout },
 };
 }

 // Convert to YAML with proper formatting
 const yamlStr = yaml.dump(appConfig, {
 indent: 2,
 lineWidth: -1,
 noRefs: true,
 sortKeys: false,
 quotingType: '"',
 forceQuotes: false,
 });

 // Add header comments
 const header = `# Backstage App Configuration
# Generated by Zero-Maintenance Integration Config UI
# Generated at: ${new Date().toISOString()}
#
# IMPORTANT: Replace environment variable placeholders with actual values:
# - \${GITHUB_TOKEN}: Your GitHub personal access token
# - \${GITLAB_TOKEN}: Your GitLab personal access token
# - \${KUBE_TOKEN}: Your Kubernetes service account token
#
# For more information, see: https://backstage.io/docs/conf/

`;

 return header + yamlStr;
}