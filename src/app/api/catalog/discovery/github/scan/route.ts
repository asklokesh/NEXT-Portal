import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { GitHubScanner, type GitHubConfig, type ScanOptions, type ScanResult } from '@/lib/discovery/GitHubScanner';

// Request validation schema
const ScanRequestSchema = z.object({
  config: z.object({
    token: z.string().optional(),
    appId: z.number().optional(),
    privateKey: z.string().optional(),
    installationId: z.number().optional(),
    baseUrl: z.string().optional(),
  }),
  options: z.object({
    organizations: z.array(z.string()).optional(),
    users: z.array(z.string()).optional(),
    repositories: z.array(z.string()).optional(),
    includePrivate: z.boolean().default(false),
    includeArchived: z.boolean().default(false),
    includeForks: z.boolean().default(true),
    batchSize: z.number().min(1).max(100).default(50),
    rateLimitDelay: z.number().min(0).max(10000).default(1000),
    maxConcurrent: z.number().min(1).max(10).default(5),
    dryRun: z.boolean().default(true),
  }).optional(),
});

type ScanRequest = z.infer<typeof ScanRequestSchema>;

// Response schema
const ScanResponseSchema = z.object({
  success: z.boolean(),
  data: z.object({
    repositories: z.array(z.any()),
    totalScanned: z.number(),
    rateLimitInfo: z.object({
      limit: z.number(),
      remaining: z.number(),
      resetTime: z.date(),
    }),
    errors: z.array(z.object({
      repository: z.string().optional(),
      error: z.string(),
      details: z.any().optional(),
    })),
    summary: z.object({
      withCatalogInfo: z.number(),
      autoGenerated: z.number(),
      private: z.number(),
      archived: z.number(),
      byLanguage: z.record(z.number()),
      byFramework: z.record(z.number()),
    }),
  }).optional(),
  error: z.string().optional(),
  timestamp: z.date(),
});

/**
 * POST /api/catalog/discovery/github/scan
 * 
 * Scans GitHub repositories and discovers catalog entities
 */
export async function POST(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    // Parse and validate request body
    const body = await request.json();
    const validatedRequest = ScanRequestSchema.parse(body);
    
    const { config, options = {} } = validatedRequest;
    
    // Validate authentication configuration
    if (!config.token && !(config.appId && config.privateKey && config.installationId)) {
      return NextResponse.json(
        {
          success: false,
          error: 'GitHub authentication is required. Provide either a token or GitHub App credentials.',
          timestamp: new Date(),
        },
        { status: 400 }
      );
    }

    // Validate scan targets
    const hasTargets = (options.organizations && options.organizations.length > 0) ||
                      (options.users && options.users.length > 0) ||
                      (options.repositories && options.repositories.length > 0);
    
    if (!hasTargets) {
      return NextResponse.json(
        {
          success: false,
          error: 'At least one scan target is required (organizations, users, or repositories).',
          timestamp: new Date(),
        },
        { status: 400 }
      );
    }

    // Create GitHub scanner instance
    const githubConfig: GitHubConfig = {
      token: config.token,
      appId: config.appId,
      privateKey: config.privateKey,
      installationId: config.installationId,
      baseUrl: config.baseUrl,
    };

    const scanner = new GitHubScanner(githubConfig);

    // Prepare scan options with defaults
    const scanOptions: ScanOptions = {
      organizations: options.organizations || [],
      users: options.users || [],
      repositories: options.repositories || [],
      includePrivate: options.includePrivate,
      includeArchived: options.includeArchived,
      includeForks: options.includeForks,
      batchSize: options.batchSize,
      rateLimitDelay: options.rateLimitDelay,
      maxConcurrent: options.maxConcurrent,
      dryRun: options.dryRun,
    };

    // Log scan initiation
    console.log(`[GitHub Scan] Starting scan with options:`, {
      organizations: scanOptions.organizations?.length || 0,
      users: scanOptions.users?.length || 0,
      repositories: scanOptions.repositories?.length || 0,
      includePrivate: scanOptions.includePrivate,
      includeArchived: scanOptions.includeArchived,
      includeForks: scanOptions.includeForks,
      dryRun: scanOptions.dryRun,
    });

    // Execute the scan
    const scanResult: ScanResult = await scanner.scanRepositories(scanOptions);

    // Calculate execution time
    const executionTime = Date.now() - startTime;

    // Log scan completion
    console.log(`[GitHub Scan] Completed in ${executionTime}ms:`, {
      totalScanned: scanResult.totalScanned,
      withCatalogInfo: scanResult.summary.withCatalogInfo,
      autoGenerated: scanResult.summary.autoGenerated,
      errors: scanResult.errors.length,
      rateLimitRemaining: scanResult.rateLimitInfo.remaining,
    });

    // Return successful response
    return NextResponse.json({
      success: true,
      data: {
        repositories: scanResult.repositories,
        totalScanned: scanResult.totalScanned,
        rateLimitInfo: scanResult.rateLimitInfo,
        errors: scanResult.errors,
        summary: scanResult.summary,
        executionTime,
      },
      timestamp: new Date(),
    });

  } catch (error) {
    console.error('[GitHub Scan] Error:', error);

    // Handle validation errors
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request format',
          details: error.errors,
          timestamp: new Date(),
        },
        { status: 400 }
      );
    }

    // Handle GitHub API errors
    if (error && typeof error === 'object' && 'status' in error) {
      const githubError = error as { status: number; message: string };
      
      if (githubError.status === 401) {
        return NextResponse.json(
          {
            success: false,
            error: 'GitHub authentication failed. Please check your credentials.',
            timestamp: new Date(),
          },
          { status: 401 }
        );
      }
      
      if (githubError.status === 403) {
        return NextResponse.json(
          {
            success: false,
            error: 'GitHub API rate limit exceeded or insufficient permissions.',
            timestamp: new Date(),
          },
          { status: 429 }
        );
      }
      
      if (githubError.status === 404) {
        return NextResponse.json(
          {
            success: false,
            error: 'One or more specified organizations, users, or repositories not found.',
            timestamp: new Date(),
          },
          { status: 404 }
        );
      }
    }

    // Handle other errors
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    
    return NextResponse.json(
      {
        success: false,
        error: `GitHub scan failed: ${errorMessage}`,
        timestamp: new Date(),
      },
      { status: 500 }
    );
  }
}

/**
 * GET /api/catalog/discovery/github/scan
 * 
 * Returns information about the GitHub scanning capability
 */
export async function GET() {
  return NextResponse.json({
    service: 'GitHub Repository Scanner',
    version: '1.0.0',
    description: 'Scans GitHub repositories to discover and catalog services',
    capabilities: {
      authentication: ['Personal Access Token', 'GitHub App'],
      sources: ['Organizations', 'Users', 'Specific Repositories'],
      detection: [
        'catalog-info.yaml files',
        'Programming languages',
        'Frameworks and libraries',
        'Dependencies',
        'Team ownership (CODEOWNERS)',
      ],
      features: [
        'Batch processing with rate limiting',
        'Auto-generation of catalog entries',
        'Dry-run mode',
        'Comprehensive error reporting',
        'Progress tracking',
      ],
    },
    limits: {
      maxBatchSize: 100,
      maxConcurrent: 10,
      maxRateLimitDelay: 10000,
    },
    examples: {
      scanOrganization: {
        config: {
          token: 'ghp_xxxxxxxxxxxxxxxxxxxx',
        },
        options: {
          organizations: ['my-org'],
          includePrivate: true,
          dryRun: true,
        },
      },
      scanUser: {
        config: {
          appId: 123456,
          privateKey: '-----BEGIN RSA PRIVATE KEY-----...',
          installationId: 12345678,
        },
        options: {
          users: ['username'],
          includeForks: false,
        },
      },
      scanSpecificRepos: {
        config: {
          token: 'ghp_xxxxxxxxxxxxxxxxxxxx',
        },
        options: {
          repositories: ['owner/repo1', 'owner/repo2'],
        },
      },
    },
    timestamp: new Date(),
  });
}

/**
 * OPTIONS /api/catalog/discovery/github/scan
 * 
 * Handles CORS preflight requests
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}