import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import type { Repository, CatalogEntity } from '@/lib/discovery/GitHubScanner';

// Import validation schema
const ImportRequestSchema = z.object({
  repositories: z.array(z.object({
    id: z.number(),
    name: z.string(),
    full_name: z.string(),
    description: z.string().nullable(),
    private: z.boolean(),
    html_url: z.string(),
    clone_url: z.string(),
    ssh_url: z.string(),
    default_branch: z.string(),
    language: z.string().nullable(),
    languages: z.record(z.number()),
    topics: z.array(z.string()),
    created_at: z.string(),
    updated_at: z.string(),
    pushed_at: z.string(),
    stargazers_count: z.number(),
    forks_count: z.number(),
    size: z.number(),
    archived: z.boolean(),
    disabled: z.boolean(),
    has_catalog_info: z.boolean(),
    catalog_info: z.any().optional(),
    auto_generated_catalog: z.any().optional(),
    dependencies: z.record(z.any()),
    team_ownership: z.object({
      teams: z.array(z.string()),
      codeowners: z.array(z.object({
        pattern: z.string(),
        owners: z.array(z.string()),
      })),
      maintainers: z.array(z.string()),
    }).optional(),
    framework_detection: z.object({
      framework: z.string().nullable(),
      version: z.string().optional(),
      confidence: z.number(),
      indicators: z.array(z.string()),
    }),
  })),
  options: z.object({
    overwriteExisting: z.boolean().default(false),
    skipValidation: z.boolean().default(false),
    generateMissing: z.boolean().default(true),
    defaultOwner: z.string().default('unknown'),
    defaultLifecycle: z.string().default('experimental'),
    addTags: z.array(z.string()).default(['github-imported']),
  }).optional(),
});

type ImportRequest = z.infer<typeof ImportRequestSchema>;

interface ImportResult {
  imported: number;
  skipped: number;
  errors: number;
  details: {
    imported: Array<{
      repository: string;
      entityName: string;
      entityKind: string;
      catalogPath?: string;
    }>;
    skipped: Array<{
      repository: string;
      reason: string;
    }>;
    errors: Array<{
      repository: string;
      error: string;
      details?: any;
    }>;
  };
  summary: {
    byKind: Record<string, number>;
    byLanguage: Record<string, number>;
    byFramework: Record<string, number>;
    withExistingCatalog: number;
    autoGenerated: number;
  };
}

/**
 * POST /api/catalog/discovery/github/import
 * 
 * Imports discovered GitHub repositories into the service catalog
 */
export async function POST(request: NextRequest) {
  const startTime = Date.now();

  try {
    // Parse and validate request body
    const body = await request.json();
    const validatedRequest = ImportRequestSchema.parse(body);
    
    const { repositories, options = {} } = validatedRequest;

    if (repositories.length === 0) {
      return NextResponse.json(
        {
          success: false,
          error: 'No repositories provided for import',
          timestamp: new Date(),
        },
        { status: 400 }
      );
    }

    // Initialize import result
    const result: ImportResult = {
      imported: 0,
      skipped: 0,
      errors: 0,
      details: {
        imported: [],
        skipped: [],
        errors: [],
      },
      summary: {
        byKind: {},
        byLanguage: {},
        byFramework: {},
        withExistingCatalog: 0,
        autoGenerated: 0,
      },
    };

    console.log(`[GitHub Import] Starting import of ${repositories.length} repositories`);

    // Process each repository
    for (const repository of repositories) {
      try {
        const importResult = await importRepository(repository, options);
        
        if (importResult.success) {
          result.imported++;
          result.details.imported.push({
            repository: repository.full_name,
            entityName: importResult.entityName!,
            entityKind: importResult.entityKind!,
            catalogPath: importResult.catalogPath,
          });

          // Update summary statistics
          const kind = importResult.entityKind!;
          result.summary.byKind[kind] = (result.summary.byKind[kind] || 0) + 1;

          if (repository.language) {
            result.summary.byLanguage[repository.language] = 
              (result.summary.byLanguage[repository.language] || 0) + 1;
          }

          if (repository.framework_detection.framework) {
            const framework = repository.framework_detection.framework;
            result.summary.byFramework[framework] = 
              (result.summary.byFramework[framework] || 0) + 1;
          }

          if (repository.has_catalog_info) {
            result.summary.withExistingCatalog++;
          } else if (repository.auto_generated_catalog) {
            result.summary.autoGenerated++;
          }

        } else if (importResult.skipped) {
          result.skipped++;
          result.details.skipped.push({
            repository: repository.full_name,
            reason: importResult.reason!,
          });
        } else {
          result.errors++;
          result.details.errors.push({
            repository: repository.full_name,
            error: importResult.error!,
            details: importResult.details,
          });
        }
      } catch (error) {
        result.errors++;
        result.details.errors.push({
          repository: repository.full_name,
          error: error instanceof Error ? error.message : 'Unknown error',
          details: error,
        });
      }
    }

    // Calculate execution time
    const executionTime = Date.now() - startTime;

    console.log(`[GitHub Import] Completed in ${executionTime}ms:`, {
      imported: result.imported,
      skipped: result.skipped,
      errors: result.errors,
    });

    // Return successful response
    return NextResponse.json({
      success: true,
      data: {
        ...result,
        executionTime,
        totalProcessed: repositories.length,
      },
      timestamp: new Date(),
    });

  } catch (error) {
    console.error('[GitHub Import] Error:', error);

    // Handle validation errors
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid request format',
          details: error.errors,
          timestamp: new Date(),
        },
        { status: 400 }
      );
    }

    // Handle other errors
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    
    return NextResponse.json(
      {
        success: false,
        error: `GitHub import failed: ${errorMessage}`,
        timestamp: new Date(),
      },
      { status: 500 }
    );
  }
}

/**
 * Import a single repository into the catalog
 */
async function importRepository(
  repository: Repository, 
  options: NonNullable<ImportRequest['options']>
): Promise<{
  success: boolean;
  skipped?: boolean;
  error?: string;
  reason?: string;
  details?: any;
  entityName?: string;
  entityKind?: string;
  catalogPath?: string;
}> {
  
  const catalogEntity = repository.catalog_info || repository.auto_generated_catalog;
  
  if (!catalogEntity && !options.generateMissing) {
    return {
      success: false,
      skipped: true,
      reason: 'No catalog entity found and auto-generation disabled',
    };
  }

  let entityToImport: CatalogEntity;

  if (catalogEntity) {
    entityToImport = catalogEntity;
  } else {
    // Generate a basic catalog entity if none exists
    entityToImport = generateBasicCatalogEntity(repository, options);
  }

  // Enhance entity with import options
  if (options.addTags && options.addTags.length > 0) {
    entityToImport.metadata.tags = [
      ...(entityToImport.metadata.tags || []),
      ...options.addTags,
    ];
  }

  // Set default values if not present
  if (entityToImport.spec) {
    if (!entityToImport.spec.owner) {
      entityToImport.spec.owner = options.defaultOwner;
    }
    if (!entityToImport.spec.lifecycle) {
      entityToImport.spec.lifecycle = options.defaultLifecycle;
    }
  }

  try {
    // Check if entity already exists
    const existingEntity = await checkExistingEntity(entityToImport);
    
    if (existingEntity && !options.overwriteExisting) {
      return {
        success: false,
        skipped: true,
        reason: 'Entity already exists and overwrite not enabled',
      };
    }

    // Validate entity if validation is enabled
    if (!options.skipValidation) {
      const validationResult = await validateCatalogEntity(entityToImport);
      if (!validationResult.valid) {
        return {
          success: false,
          error: 'Entity validation failed',
          details: validationResult.errors,
        };
      }
    }

    // Import entity into catalog
    const importResult = await importCatalogEntity(entityToImport, {
      overwrite: options.overwriteExisting,
      source: 'github-discovery',
      metadata: {
        repositoryUrl: repository.html_url,
        lastImported: new Date().toISOString(),
        importMethod: repository.has_catalog_info ? 'existing-catalog' : 'auto-generated',
      },
    });

    return {
      success: true,
      entityName: entityToImport.metadata.name,
      entityKind: entityToImport.kind,
      catalogPath: importResult.catalogPath,
    };

  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Import failed',
      details: error,
    };
  }
}

/**
 * Generate a basic catalog entity for repositories without existing catalog-info.yaml
 */
function generateBasicCatalogEntity(
  repository: Repository, 
  options: NonNullable<ImportRequest['options']>
): CatalogEntity {
  
  // Determine entity type based on repository characteristics
  let entityType = 'service';
  
  if (repository.topics.includes('library') || repository.topics.includes('package')) {
    entityType = 'library';
  } else if (repository.topics.includes('website') || repository.topics.includes('docs')) {
    entityType = 'website';
  }

  // Generate labels
  const labels: Record<string, string> = {
    'backstage.io/source': 'github-discovery',
  };
  
  if (repository.framework_detection.framework) {
    labels['backstage.io/framework'] = repository.framework_detection.framework
      .toLowerCase()
      .replace(/\s+/g, '-');
  }
  
  if (repository.language) {
    labels['backstage.io/language'] = repository.language.toLowerCase();
  }

  // Generate annotations
  const annotations: Record<string, string> = {
    'github.com/project-slug': repository.full_name,
    'backstage.io/source-location': `url:${repository.html_url}`,
    'backstage.io/managed-by-location': `url:${repository.html_url}`,
  };

  // Generate links
  const links = [
    {
      url: repository.html_url,
      title: 'Repository',
      icon: 'github',
    },
  ];

  // Create the entity
  const entity: CatalogEntity = {
    apiVersion: 'backstage.io/v1alpha1',
    kind: 'Component',
    metadata: {
      name: repository.name.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
      title: repository.name,
      description: repository.description || `Auto-imported from GitHub: ${repository.full_name}`,
      labels,
      annotations,
      tags: [...repository.topics, 'github-imported', 'auto-generated'],
      links,
    },
    spec: {
      type: entityType,
      lifecycle: options.defaultLifecycle,
      owner: options.defaultOwner,
    },
  };

  return entity;
}

/**
 * Check if catalog entity already exists
 */
async function checkExistingEntity(entity: CatalogEntity): Promise<boolean> {
  try {
    // This would typically query your catalog database
    // For now, we'll return false to allow all imports
    // In a real implementation, you would:
    // 1. Query the catalog database/service
    // 2. Check if an entity with the same name/namespace/kind exists
    // 3. Return true if found, false otherwise
    
    return false;
  } catch (error) {
    console.error('Error checking existing entity:', error);
    return false;
  }
}

/**
 * Validate catalog entity against schema
 */
async function validateCatalogEntity(entity: CatalogEntity): Promise<{
  valid: boolean;
  errors?: string[];
}> {
  try {
    // Basic validation - in production, use Backstage's catalog validation
    const errors: string[] = [];

    if (!entity.metadata.name) {
      errors.push('Entity name is required');
    }

    if (!/^[a-z0-9-]+$/.test(entity.metadata.name)) {
      errors.push('Entity name must contain only lowercase letters, numbers, and hyphens');
    }

    if (!entity.kind) {
      errors.push('Entity kind is required');
    }

    if (!entity.apiVersion) {
      errors.push('Entity apiVersion is required');
    }

    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : undefined,
    };

  } catch (error) {
    return {
      valid: false,
      errors: ['Validation error: ' + (error instanceof Error ? error.message : 'Unknown error')],
    };
  }
}

/**
 * Import catalog entity into the catalog system
 */
async function importCatalogEntity(
  entity: CatalogEntity,
  options: {
    overwrite?: boolean;
    source?: string;
    metadata?: Record<string, any>;
  }
): Promise<{
  success: boolean;
  catalogPath?: string;
  entityRef?: string;
}> {
  try {
    // This would typically:
    // 1. Connect to your catalog database/service
    // 2. Store the entity with appropriate metadata
    // 3. Update indexes and relationships
    // 4. Notify other systems of the new entity
    
    console.log(`[GitHub Import] Importing entity: ${entity.kind}:${entity.metadata.namespace || 'default'}/${entity.metadata.name}`);
    
    // For now, we'll simulate successful import
    // In a real implementation, you would:
    // - Store in database
    // - Update search indexes
    // - Trigger webhooks/events
    // - Update catalog caches
    
    const catalogPath = `/${entity.kind.toLowerCase()}/${entity.metadata.namespace || 'default'}/${entity.metadata.name}`;
    const entityRef = `${entity.kind}:${entity.metadata.namespace || 'default'}/${entity.metadata.name}`;

    return {
      success: true,
      catalogPath,
      entityRef,
    };

  } catch (error) {
    console.error('Error importing catalog entity:', error);
    throw error;
  }
}

/**
 * GET /api/catalog/discovery/github/import
 * 
 * Returns information about the GitHub import capability
 */
export async function GET() {
  return NextResponse.json({
    service: 'GitHub Repository Importer',
    version: '1.0.0',
    description: 'Imports GitHub repositories into the service catalog',
    capabilities: {
      entityTypes: ['Component', 'Resource', 'System'],
      validation: true,
      overwriteProtection: true,
      batchImport: true,
      autoGeneration: true,
    },
    options: {
      overwriteExisting: {
        type: 'boolean',
        default: false,
        description: 'Whether to overwrite existing entities',
      },
      skipValidation: {
        type: 'boolean',
        default: false,
        description: 'Skip entity validation before import',
      },
      generateMissing: {
        type: 'boolean',
        default: true,
        description: 'Auto-generate catalog entries for repositories without catalog-info.yaml',
      },
      defaultOwner: {
        type: 'string',
        default: 'unknown',
        description: 'Default owner for imported entities',
      },
      defaultLifecycle: {
        type: 'string',
        default: 'experimental',
        description: 'Default lifecycle for imported entities',
      },
      addTags: {
        type: 'array',
        default: ['github-imported'],
        description: 'Additional tags to add to imported entities',
      },
    },
    timestamp: new Date(),
  });
}

/**
 * OPTIONS /api/catalog/discovery/github/import
 * 
 * Handles CORS preflight requests
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}