import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { PrismaClient } from '@prisma/client';
import { auth } from '@/lib/auth';

const prisma = new PrismaClient();

// Environment configuration schema
const EnvironmentConfigSchema = z.object({
  pluginId: z.string().min(1),
  environment: z.enum(['development', 'staging', 'production']),
  configuration: z.record(z.any()).optional(),
  secrets: z.record(z.string()).optional(),
  variables: z.record(z.string()).optional(),
  resources: z.object({
    cpu: z.string().optional(),
    memory: z.string().optional(),
    replicas: z.number().min(1).optional()
  }).optional(),
  scaling: z.object({
    enabled: z.boolean().default(false),
    minReplicas: z.number().min(1).default(1),
    maxReplicas: z.number().min(1).default(10),
    targetCPU: z.number().min(1).max(100).default(80)
  }).optional(),
  health: z.object({
    enabled: z.boolean().default(true),
    path: z.string().default('/health'),
    interval: z.number().min(10).default(30),
    timeout: z.number().min(1).default(10),
    retries: z.number().min(1).default(3)
  }).optional()
});\n\nconst PromotionRequestSchema = z.object({\n  pluginId: z.string().min(1),\n  fromEnvironment: z.enum(['development', 'staging']),\n  toEnvironment: z.enum(['staging', 'production']),\n  version: z.string().min(1),\n  notes: z.string().optional(),\n  skipApproval: z.boolean().default(false),\n  rollbackPlan: z.object({\n    enabled: z.boolean().default(true),\n    autoRollbackOnFailure: z.boolean().default(false),\n    healthCheckGracePeriod: z.number().min(60).default(300) // 5 minutes\n  }).optional()\n});\n\nconst EnvironmentFiltersSchema = z.object({\n  pluginId: z.string().optional(),\n  environment: z.enum(['development', 'staging', 'production']).optional(),\n  isActive: z.coerce.boolean().optional(),\n  page: z.coerce.number().min(1).default(1),\n  limit: z.coerce.number().min(1).max(50).default(20)\n});\n\n// GET /api/marketplace/environments - Get environment configurations\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await auth();\n    if (!session?.user?.email) {\n      return NextResponse.json({ \n        success: false, \n        error: 'Authentication required' \n      }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const rawFilters = Object.fromEntries(searchParams.entries());\n    const filters = EnvironmentFiltersSchema.parse(rawFilters);\n\n    // Get user\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      select: { id: true, role: true }\n    });\n\n    if (!user) {\n      return NextResponse.json({ \n        success: false, \n        error: 'User not found' \n      }, { status: 404 });\n    }\n\n    // Build where clause based on filters and permissions\n    let where: any = {};\n    \n    if (filters.pluginId) {\n      where.pluginId = filters.pluginId;\n    }\n    \n    if (filters.environment) {\n      where.environment = filters.environment;\n    }\n    \n    if (filters.isActive !== undefined) {\n      where.isActive = filters.isActive;\n    }\n\n    // If not admin, only show environments for user's plugins\n    if (user.role !== 'ADMIN') {\n      const userPlugins = await prisma.plugin.findMany({\n        where: { author: user.id },\n        select: { id: true }\n      });\n      const userPluginIds = userPlugins.map(p => p.id);\n      where.pluginId = { in: userPluginIds };\n    }\n\n    const [environments, totalCount] = await Promise.all([\n      prisma.pluginEnvironment.findMany({\n        where,\n        skip: (filters.page - 1) * filters.limit,\n        take: filters.limit,\n        include: {\n          plugin: {\n            select: {\n              id: true,\n              name: true,\n              displayName: true,\n              author: true\n            }\n          }\n        },\n        orderBy: [{ environment: 'asc' }, { createdAt: 'desc' }]\n      }),\n      prisma.pluginEnvironment.count({ where })\n    ]);\n\n    // Get deployment status for each environment\n    const environmentsWithStatus = await Promise.all(\n      environments.map(async (env) => {\n        // Get latest deployment for this environment\n        const latestDeployment = await prisma.pluginDeployment.findFirst({\n          where: {\n            pluginVersion: {\n              pluginId: env.pluginId\n            },\n            environment: env.environment\n          },\n          orderBy: { startedAt: 'desc' },\n          include: {\n            pluginVersion: {\n              select: {\n                version: true,\n                status: true\n              }\n            }\n          }\n        });\n\n        // Get environment health metrics\n        const healthMetrics = await prisma.pluginMetrics.findMany({\n          where: {\n            pluginId: env.pluginId,\n            environment: env.environment,\n            metricName: { in: ['cpu_usage', 'memory_usage', 'error_rate', 'response_time'] },\n            timestamp: {\n              gte: new Date(Date.now() - 5 * 60 * 1000) // Last 5 minutes\n            }\n          },\n          orderBy: { timestamp: 'desc' },\n          take: 20\n        });\n\n        return {\n          id: env.id,\n          pluginId: env.pluginId,\n          environment: env.environment,\n          isActive: env.isActive,\n          configuration: env.configuration,\n          resources: env.resources,\n          scaling: env.scaling,\n          health: env.health,\n          createdBy: env.createdBy,\n          createdAt: env.createdAt.toISOString(),\n          updatedAt: env.updatedAt.toISOString(),\n          plugin: env.plugin,\n          deployment: latestDeployment ? {\n            id: latestDeployment.id,\n            version: latestDeployment.pluginVersion.version,\n            status: latestDeployment.status,\n            progress: latestDeployment.progress,\n            startedAt: latestDeployment.startedAt.toISOString(),\n            completedAt: latestDeployment.completedAt?.toISOString()\n          } : null,\n          metrics: {\n            cpu: healthMetrics.filter(m => m.metricName === 'cpu_usage').slice(0, 5),\n            memory: healthMetrics.filter(m => m.metricName === 'memory_usage').slice(0, 5),\n            errorRate: healthMetrics.filter(m => m.metricName === 'error_rate').slice(0, 5),\n            responseTime: healthMetrics.filter(m => m.metricName === 'response_time').slice(0, 5)\n          }\n        };\n      })\n    );\n\n    // Get environment summary statistics\n    const environmentStats = await prisma.pluginEnvironment.groupBy({\n      by: ['environment'],\n      where: user.role === 'ADMIN' ? {} : {\n        plugin: { author: user.id }\n      },\n      _count: { environment: true }\n    });\n\n    const summary = {\n      total: totalCount,\n      byEnvironment: environmentStats.reduce((acc, stat) => {\n        acc[stat.environment] = stat._count.environment;\n        return acc;\n      }, {} as Record<string, number>),\n      active: environments.filter(env => env.isActive).length\n    };\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        environments: environmentsWithStatus,\n        pagination: {\n          page: filters.page,\n          limit: filters.limit,\n          total: totalCount,\n          totalPages: Math.ceil(totalCount / filters.limit),\n          hasNext: filters.page * filters.limit < totalCount,\n          hasPrev: filters.page > 1\n        },\n        summary\n      }\n    });\n\n  } catch (error) {\n    console.error('Environments API Error:', error);\n    \n    if (error instanceof z.ZodError) {\n      return NextResponse.json({\n        success: false,\n        error: 'Invalid request parameters',\n        details: error.errors\n      }, { status: 400 });\n    }\n\n    return NextResponse.json({\n      success: false,\n      error: 'Failed to fetch environment configurations',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  } finally {\n    await prisma.$disconnect();\n  }\n}\n\n// POST /api/marketplace/environments - Create or update environment configuration\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await auth();\n    if (!session?.user?.email) {\n      return NextResponse.json({ \n        success: false, \n        error: 'Authentication required' \n      }, { status: 401 });\n    }\n\n    const body = await request.json();\n    const action = body.action || 'configure';\n\n    // Get user\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      select: { id: true, role: true }\n    });\n\n    if (!user) {\n      return NextResponse.json({ \n        success: false, \n        error: 'User not found' \n      }, { status: 404 });\n    }\n\n    if (action === 'configure') {\n      const envConfig = EnvironmentConfigSchema.parse(body);\n\n      // Verify user owns the plugin or has admin rights\n      const plugin = await prisma.plugin.findFirst({\n        where: {\n          id: envConfig.pluginId,\n          ...(user.role !== 'ADMIN' ? { author: user.id } : {})\n        }\n      });\n\n      if (!plugin) {\n        return NextResponse.json({\n          success: false,\n          error: 'Plugin not found or access denied'\n        }, { status: 404 });\n      }\n\n      // Create or update environment configuration\n      const environment = await prisma.pluginEnvironment.upsert({\n        where: {\n          pluginId_environment: {\n            pluginId: envConfig.pluginId,\n            environment: envConfig.environment\n          }\n        },\n        create: {\n          pluginId: envConfig.pluginId,\n          environment: envConfig.environment,\n          isActive: true,\n          configuration: envConfig.configuration || {},\n          secrets: envConfig.secrets ? JSON.stringify(envConfig.secrets) : null,\n          variables: envConfig.variables || {},\n          resources: envConfig.resources || {},\n          scaling: envConfig.scaling || {},\n          health: envConfig.health || {},\n          deployment: 'ROLLING', // Default deployment strategy\n          createdBy: user.id\n        },\n        update: {\n          configuration: envConfig.configuration || {},\n          secrets: envConfig.secrets ? JSON.stringify(envConfig.secrets) : undefined,\n          variables: envConfig.variables || {},\n          resources: envConfig.resources || {},\n          scaling: envConfig.scaling || {},\n          health: envConfig.health || {},\n          updatedAt: new Date()\n        },\n        include: {\n          plugin: {\n            select: {\n              name: true,\n              displayName: true\n            }\n          }\n        }\n      });\n\n      return NextResponse.json({\n        success: true,\n        data: {\n          environmentId: environment.id,\n          pluginId: environment.pluginId,\n          environment: environment.environment,\n          isActive: environment.isActive,\n          message: 'Environment configuration updated successfully'\n        }\n      });\n\n    } else if (action === 'promote') {\n      const promotionRequest = PromotionRequestSchema.parse(body);\n\n      // Verify user owns the plugin or has admin rights\n      const plugin = await prisma.plugin.findFirst({\n        where: {\n          id: promotionRequest.pluginId,\n          ...(user.role !== 'ADMIN' ? { author: user.id } : {})\n        },\n        include: {\n          versions: {\n            where: { version: promotionRequest.version },\n            take: 1\n          }\n        }\n      });\n\n      if (!plugin || plugin.versions.length === 0) {\n        return NextResponse.json({\n          success: false,\n          error: 'Plugin or version not found, or access denied'\n        }, { status: 404 });\n      }\n\n      const pluginVersion = plugin.versions[0];\n\n      // Check if source environment deployment exists and is successful\n      const sourceDeployment = await prisma.pluginDeployment.findFirst({\n        where: {\n          pluginVersionId: pluginVersion.id,\n          environment: promotionRequest.fromEnvironment,\n          status: 'DEPLOYED'\n        },\n        orderBy: { startedAt: 'desc' }\n      });\n\n      if (!sourceDeployment) {\n        return NextResponse.json({\n          success: false,\n          error: `No successful deployment found in ${promotionRequest.fromEnvironment} environment`\n        }, { status: 400 });\n      }\n\n      // Check if approval is required for production promotions\n      const requiresApproval = promotionRequest.toEnvironment === 'production' && !promotionRequest.skipApproval;\n      \n      if (requiresApproval && user.role !== 'ADMIN') {\n        // Create approval request\n        const governance = await prisma.pluginGovernance.findFirst({\n          where: {\n            pluginId: promotionRequest.pluginId,\n            isActive: true\n          }\n        });\n\n        if (governance) {\n          const approval = await prisma.pluginApproval.create({\n            data: {\n              governanceId: governance.id,\n              pluginId: promotionRequest.pluginId,\n              pluginVersionId: pluginVersion.id,\n              requestType: 'CONFIGURATION_CHANGE',\n              requestedBy: user.id,\n              priority: 'MEDIUM',\n              reason: `Promote plugin from ${promotionRequest.fromEnvironment} to ${promotionRequest.toEnvironment}`,\n              comments: promotionRequest.notes ? JSON.stringify([{\n                text: promotionRequest.notes,\n                author: user.id,\n                timestamp: new Date()\n              }]) : null,\n              requirements: JSON.stringify({\n                fromEnvironment: promotionRequest.fromEnvironment,\n                toEnvironment: promotionRequest.toEnvironment,\n                version: promotionRequest.version,\n                rollbackPlan: promotionRequest.rollbackPlan\n              })\n            }\n          });\n\n          return NextResponse.json({\n            success: true,\n            data: {\n              approvalId: approval.id,\n              status: 'pending_approval',\n              message: 'Promotion request submitted for approval'\n            }\n          });\n        }\n      }\n\n      // Create promotion deployment\n      const deployment = await prisma.pluginDeployment.create({\n        data: {\n          pluginVersionId: pluginVersion.id,\n          environment: promotionRequest.toEnvironment,\n          status: 'PENDING',\n          strategy: 'ROLLING',\n          progress: 0,\n          deployedBy: user.id,\n          rollbackPlan: promotionRequest.rollbackPlan ? JSON.stringify(promotionRequest.rollbackPlan) : null\n        }\n      });\n\n      // Start the deployment process (this would integrate with your deployment system)\n      // For now, we'll simulate it\n      setTimeout(async () => {\n        try {\n          await simulateDeployment(deployment.id);\n        } catch (error) {\n          console.error('Deployment simulation error:', error);\n        }\n      }, 1000);\n\n      return NextResponse.json({\n        success: true,\n        data: {\n          deploymentId: deployment.id,\n          status: 'deploying',\n          environment: promotionRequest.toEnvironment,\n          version: promotionRequest.version,\n          message: 'Plugin promotion started'\n        }\n      });\n\n    } else {\n      return NextResponse.json({\n        success: false,\n        error: 'Invalid action. Use \"configure\" or \"promote\"'\n      }, { status: 400 });\n    }\n\n  } catch (error) {\n    console.error('Environment action error:', error);\n    \n    if (error instanceof z.ZodError) {\n      return NextResponse.json({\n        success: false,\n        error: 'Invalid request data',\n        details: error.errors\n      }, { status: 400 });\n    }\n\n    return NextResponse.json({\n      success: false,\n      error: 'Failed to process environment action',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  } finally {\n    await prisma.$disconnect();\n  }\n}\n\n// DELETE /api/marketplace/environments - Delete environment configuration\nexport async function DELETE(request: NextRequest) {\n  try {\n    const session = await auth();\n    if (!session?.user?.email) {\n      return NextResponse.json({ \n        success: false, \n        error: 'Authentication required' \n      }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const environmentId = searchParams.get('environmentId');\n    const pluginId = searchParams.get('pluginId');\n    const environment = searchParams.get('environment');\n\n    if (!environmentId && !(pluginId && environment)) {\n      return NextResponse.json({\n        success: false,\n        error: 'Either environmentId or (pluginId + environment) is required'\n      }, { status: 400 });\n    }\n\n    // Get user\n    const user = await prisma.user.findUnique({\n      where: { email: session.user.email },\n      select: { id: true, role: true }\n    });\n\n    if (!user) {\n      return NextResponse.json({ \n        success: false, \n        error: 'User not found' \n      }, { status: 404 });\n    }\n\n    // Find environment configuration\n    const where: any = environmentId ? { id: environmentId } : {\n      pluginId,\n      environment\n    };\n\n    const envConfig = await prisma.pluginEnvironment.findFirst({\n      where,\n      include: {\n        plugin: {\n          select: { author: true }\n        }\n      }\n    });\n\n    if (!envConfig) {\n      return NextResponse.json({\n        success: false,\n        error: 'Environment configuration not found'\n      }, { status: 404 });\n    }\n\n    // Check permissions\n    if (user.role !== 'ADMIN' && envConfig.plugin.author !== user.id) {\n      return NextResponse.json({\n        success: false,\n        error: 'Access denied'\n      }, { status: 403 });\n    }\n\n    // Don't allow deletion of production environments without special permission\n    if (envConfig.environment === 'production' && user.role !== 'ADMIN') {\n      return NextResponse.json({\n        success: false,\n        error: 'Production environment configurations cannot be deleted without admin privileges'\n      }, { status: 403 });\n    }\n\n    // Delete the environment configuration\n    await prisma.pluginEnvironment.delete({\n      where: { id: envConfig.id }\n    });\n\n    return NextResponse.json({\n      success: true,\n      message: 'Environment configuration deleted successfully'\n    });\n\n  } catch (error) {\n    console.error('Environment deletion error:', error);\n    \n    return NextResponse.json({\n      success: false,\n      error: 'Failed to delete environment configuration',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    }, { status: 500 });\n  } finally {\n    await prisma.$disconnect();\n  }\n}\n\n// Helper function to simulate deployment process\nasync function simulateDeployment(deploymentId: string) {\n  const stages = ['PENDING', 'DEPLOYING', 'DEPLOYED'];\n  \n  for (let i = 0; i < stages.length; i++) {\n    const status = stages[i] as any;\n    const progress = ((i + 1) / stages.length) * 100;\n    \n    await new Promise(resolve => setTimeout(resolve, 2000)); // 2 second delay between stages\n    \n    await prisma.pluginDeployment.update({\n      where: { id: deploymentId },\n      data: {\n        status,\n        progress,\n        ...(status === 'DEPLOYED' ? { completedAt: new Date() } : {})\n      }\n    });\n  }\n}