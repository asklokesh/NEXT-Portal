// Marketplace Performance Optimizer\n// Handles caching, search indexing, CDN optimization, and real-time performance monitoring\n// Designed to support 10,000+ plugins with sub-second search performance\n\nimport { Redis } from 'ioredis';\nimport { PrismaClient } from '@prisma/client';\nimport { z } from 'zod';\nimport { createHash } from 'crypto';\nimport Fuse from 'fuse.js';\n\nconst prisma = new PrismaClient();\n\n// Performance optimization configuration\nconst PerformanceConfigSchema = z.object({\n  cache: z.object({\n    redis: z.object({\n      host: z.string().default('localhost'),\n      port: z.number().default(6379),\n      password: z.string().optional(),\n      db: z.number().default(0)\n    }),\n    ttl: z.object({\n      plugins: z.number().default(300), // 5 minutes\n      search: z.number().default(60), // 1 minute\n      metadata: z.number().default(600), // 10 minutes\n      analytics: z.number().default(1800) // 30 minutes\n    })\n  }),\n  search: z.object({\n    engine: z.enum(['fuse', 'elasticsearch', 'algolia']).default('fuse'),\n    indexBatchSize: z.number().default(1000),\n    maxResultsPerPage: z.number().default(100),\n    searchTimeout: z.number().default(5000), // 5 seconds\n    boostFields: z.object({\n      name: z.number().default(2.0),\n      displayName: z.number().default(1.8),\n      description: z.number().default(1.2),\n      tags: z.number().default(1.0),\n      author: z.number().default(0.8)\n    })\n  }),\n  cdn: z.object({\n    enabled: z.boolean().default(true),\n    baseUrl: z.string().optional(),\n    cacheControl: z.string().default('public, max-age=300'),\n    compression: z.boolean().default(true)\n  }),\n  monitoring: z.object({\n    metricsInterval: z.number().default(60000), // 1 minute\n    alertThresholds: z.object({\n      searchLatency: z.number().default(1000), // 1 second\n      errorRate: z.number().default(0.05), // 5%\n      cacheHitRate: z.number().default(0.8) // 80%\n    })\n  })\n});\n\nexport type PerformanceConfig = z.infer<typeof PerformanceConfigSchema>;\n\n// Cache key patterns\nconst CACHE_KEYS = {\n  PLUGIN: (id: string) => `plugin:${id}`,\n  PLUGINS_LIST: (filters: string) => `plugins:list:${createHash('md5').update(filters).digest('hex')}`,\n  SEARCH_RESULTS: (query: string, filters: string) => `search:${createHash('md5').update(`${query}:${filters}`).digest('hex')}`,\n  PLUGIN_METADATA: (id: string) => `plugin:metadata:${id}`,\n  CATEGORY_STATS: () => 'stats:categories',\n  USER_PREFERENCES: (userId: string) => `user:prefs:${userId}`,\n  TRENDING: () => 'plugins:trending',\n  FEATURED: () => 'plugins:featured'\n};\n\n// Search index configuration\nconst SEARCH_CONFIG = {\n  keys: [\n    { name: 'name', weight: 2.0 },\n    { name: 'displayName', weight: 1.8 },\n    { name: 'description', weight: 1.2 },\n    { name: 'tags', weight: 1.0 },\n    { name: 'author', weight: 0.8 },\n    { name: 'keywords', weight: 0.6 }\n  ],\n  threshold: 0.4,\n  distance: 100,\n  minMatchCharLength: 2,\n  includeScore: true,\n  includeMatches: true\n};\n\nexport class MarketplacePerformanceOptimizer {\n  private config: PerformanceConfig;\n  private redis: Redis;\n  private searchIndex: Fuse<any> | null = null;\n  private metrics: PerformanceMetrics;\n  private isInitialized = false;\n\n  constructor(config: Partial<PerformanceConfig> = {}) {\n    this.config = PerformanceConfigSchema.parse(config);\n    this.redis = new Redis({\n      host: this.config.cache.redis.host,\n      port: this.config.cache.redis.port,\n      password: this.config.cache.redis.password,\n      db: this.config.cache.redis.db,\n      retryDelayOnFailover: 100,\n      maxRetriesPerRequest: 3,\n      lazyConnect: true\n    });\n    \n    this.metrics = {\n      searchLatency: [],\n      cacheHits: 0,\n      cacheMisses: 0,\n      errors: 0,\n      totalRequests: 0,\n      lastReset: Date.now()\n    };\n\n    this.initializePerformanceMonitoring();\n  }\n\n  // 1. INITIALIZATION AND SETUP\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      await this.redis.connect();\n      await this.buildSearchIndex();\n      await this.warmCache();\n      \n      this.isInitialized = true;\n      console.log('Marketplace Performance Optimizer initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize Performance Optimizer:', error);\n      throw error;\n    }\n  }\n\n  // 2. SEARCH OPTIMIZATION\n  async optimizedSearch(query: string, filters: SearchFilters = {}): Promise<OptimizedSearchResult> {\n    const startTime = Date.now();\n    const cacheKey = CACHE_KEYS.SEARCH_RESULTS(query, JSON.stringify(filters));\n\n    try {\n      // Try cache first\n      const cachedResult = await this.getFromCache<OptimizedSearchResult>(cacheKey);\n      if (cachedResult) {\n        this.recordMetric('cache_hit');\n        this.recordSearchLatency(Date.now() - startTime);\n        return cachedResult;\n      }\n\n      this.recordMetric('cache_miss');\n\n      // Perform search with optimized index\n      const searchResult = await this.performOptimizedSearch(query, filters);\n      \n      // Cache the result\n      await this.setCache(cacheKey, searchResult, this.config.cache.ttl.search);\n      \n      this.recordSearchLatency(Date.now() - startTime);\n      return searchResult;\n\n    } catch (error) {\n      this.recordMetric('error');\n      console.error('Search optimization error:', error);\n      \n      // Fallback to database search\n      return await this.fallbackSearch(query, filters);\n    }\n  }\n\n  // 3. PLUGIN DATA OPTIMIZATION\n  async getOptimizedPluginData(pluginId: string, includeAnalytics = false): Promise<OptimizedPluginData | null> {\n    const cacheKey = CACHE_KEYS.PLUGIN(pluginId);\n\n    try {\n      // Try cache first\n      const cachedPlugin = await this.getFromCache<OptimizedPluginData>(cacheKey);\n      if (cachedPlugin && !includeAnalytics) {\n        this.recordMetric('cache_hit');\n        return cachedPlugin;\n      }\n\n      this.recordMetric('cache_miss');\n\n      // Fetch from database with optimized query\n      const plugin = await this.fetchOptimizedPluginData(pluginId, includeAnalytics);\n      \n      if (plugin) {\n        // Cache the plugin data\n        await this.setCache(cacheKey, plugin, this.config.cache.ttl.plugins);\n      }\n      \n      return plugin;\n\n    } catch (error) {\n      this.recordMetric('error');\n      console.error('Plugin data optimization error:', error);\n      return null;\n    }\n  }\n\n  // 4. BULK OPERATIONS OPTIMIZATION\n  async getOptimizedPluginsList(filters: SearchFilters = {}, pagination: PaginationOptions = {}): Promise<OptimizedPluginsList> {\n    const cacheKey = CACHE_KEYS.PLUGINS_LIST(JSON.stringify({ filters, pagination }));\n\n    try {\n      // Try cache first\n      const cachedList = await this.getFromCache<OptimizedPluginsList>(cacheKey);\n      if (cachedList) {\n        this.recordMetric('cache_hit');\n        return cachedList;\n      }\n\n      this.recordMetric('cache_miss');\n\n      // Fetch with optimized bulk query\n      const pluginsList = await this.fetchOptimizedPluginsList(filters, pagination);\n      \n      // Cache the result\n      await this.setCache(cacheKey, pluginsList, this.config.cache.ttl.plugins);\n      \n      return pluginsList;\n\n    } catch (error) {\n      this.recordMetric('error');\n      console.error('Plugins list optimization error:', error);\n      throw error;\n    }\n  }\n\n  // 5. CACHE MANAGEMENT\n  async invalidatePluginCache(pluginId: string): Promise<void> {\n    const keys = [\n      CACHE_KEYS.PLUGIN(pluginId),\n      CACHE_KEYS.PLUGIN_METADATA(pluginId)\n    ];\n\n    // Also invalidate related cached lists\n    const patternKeys = await this.redis.keys('plugins:list:*');\n    keys.push(...patternKeys);\n\n    // Invalidate search results that might include this plugin\n    const searchKeys = await this.redis.keys('search:*');\n    keys.push(...searchKeys);\n\n    await this.redis.del(...keys);\n    \n    // Rebuild search index\n    await this.updateSearchIndex(pluginId);\n  }\n\n  async invalidateAllCaches(): Promise<void> {\n    await this.redis.flushdb();\n    await this.buildSearchIndex();\n  }\n\n  // 6. SEARCH INDEX MANAGEMENT\n  async buildSearchIndex(): Promise<void> {\n    console.log('Building search index...');\n    \n    const plugins = await prisma.plugin.findMany({\n      where: { status: 'ACTIVE' },\n      select: {\n        id: true,\n        name: true,\n        displayName: true,\n        description: true,\n        category: true,\n        keywords: true,\n        author: true,\n        downloadCount: true,\n        starCount: true,\n        isFeatured: true,\n        isPremium: true,\n        updatedAt: true\n      },\n      take: 10000 // Limit for performance\n    });\n\n    const searchData = plugins.map(plugin => ({\n      id: plugin.id,\n      name: plugin.name,\n      displayName: plugin.displayName,\n      description: plugin.description,\n      category: plugin.category.toLowerCase().replace('_', '-'),\n      tags: plugin.keywords,\n      author: plugin.author,\n      keywords: plugin.keywords,\n      downloads: plugin.downloadCount || 0,\n      stars: plugin.starCount || 0,\n      featured: plugin.isFeatured,\n      premium: plugin.isPremium,\n      lastUpdated: plugin.updatedAt.toISOString()\n    }));\n\n    this.searchIndex = new Fuse(searchData, SEARCH_CONFIG);\n    \n    // Cache the search index data\n    await this.setCache('search:index:data', searchData, this.config.cache.ttl.metadata);\n    \n    console.log(`Search index built with ${plugins.length} plugins`);\n  }\n\n  async updateSearchIndex(pluginId: string): Promise<void> {\n    if (!this.searchIndex) return;\n\n    // Fetch updated plugin data\n    const plugin = await prisma.plugin.findUnique({\n      where: { id: pluginId },\n      select: {\n        id: true,\n        name: true,\n        displayName: true,\n        description: true,\n        category: true,\n        keywords: true,\n        author: true,\n        downloadCount: true,\n        starCount: true,\n        isFeatured: true,\n        isPremium: true,\n        updatedAt: true\n      }\n    });\n\n    if (!plugin) return;\n\n    // For Fuse.js, we need to rebuild the entire index\n    // In production, consider using a more sophisticated search engine\n    await this.buildSearchIndex();\n  }\n\n  // 7. PERFORMANCE MONITORING\n  private initializePerformanceMonitoring(): void {\n    setInterval(() => {\n      this.analyzePerformanceMetrics();\n    }, this.config.monitoring.metricsInterval);\n  }\n\n  private recordMetric(type: 'cache_hit' | 'cache_miss' | 'error'): void {\n    this.metrics.totalRequests++;\n    \n    switch (type) {\n      case 'cache_hit':\n        this.metrics.cacheHits++;\n        break;\n      case 'cache_miss':\n        this.metrics.cacheMisses++;\n        break;\n      case 'error':\n        this.metrics.errors++;\n        break;\n    }\n  }\n\n  private recordSearchLatency(latency: number): void {\n    this.metrics.searchLatency.push(latency);\n    \n    // Keep only last 1000 measurements\n    if (this.metrics.searchLatency.length > 1000) {\n      this.metrics.searchLatency = this.metrics.searchLatency.slice(-1000);\n    }\n  }\n\n  private analyzePerformanceMetrics(): void {\n    const cacheHitRate = this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses);\n    const errorRate = this.metrics.errors / this.metrics.totalRequests;\n    const avgSearchLatency = this.metrics.searchLatency.reduce((sum, lat) => sum + lat, 0) / this.metrics.searchLatency.length;\n\n    // Check against thresholds\n    if (avgSearchLatency > this.config.monitoring.alertThresholds.searchLatency) {\n      console.warn(`High search latency detected: ${avgSearchLatency}ms`);\n    }\n\n    if (errorRate > this.config.monitoring.alertThresholds.errorRate) {\n      console.warn(`High error rate detected: ${(errorRate * 100).toFixed(2)}%`);\n    }\n\n    if (cacheHitRate < this.config.monitoring.alertThresholds.cacheHitRate) {\n      console.warn(`Low cache hit rate detected: ${(cacheHitRate * 100).toFixed(2)}%`);\n    }\n\n    // Reset metrics periodically\n    const now = Date.now();\n    if (now - this.metrics.lastReset > 3600000) { // 1 hour\n      this.resetMetrics();\n    }\n  }\n\n  async getPerformanceMetrics(): Promise<PerformanceReport> {\n    const cacheHitRate = this.metrics.cacheHits / (this.metrics.cacheHits + this.metrics.cacheMisses) || 0;\n    const errorRate = this.metrics.errors / this.metrics.totalRequests || 0;\n    const avgSearchLatency = this.metrics.searchLatency.length > 0 \n      ? this.metrics.searchLatency.reduce((sum, lat) => sum + lat, 0) / this.metrics.searchLatency.length \n      : 0;\n    \n    const p95SearchLatency = this.calculatePercentile(this.metrics.searchLatency, 95);\n    const p99SearchLatency = this.calculatePercentile(this.metrics.searchLatency, 99);\n\n    // Get cache statistics\n    const cacheInfo = await this.redis.info('memory');\n    const cacheSize = await this.redis.dbsize();\n\n    return {\n      timestamp: new Date().toISOString(),\n      search: {\n        averageLatency: avgSearchLatency,\n        p95Latency: p95SearchLatency,\n        p99Latency: p99SearchLatency,\n        totalSearches: this.metrics.searchLatency.length\n      },\n      cache: {\n        hitRate: cacheHitRate,\n        hits: this.metrics.cacheHits,\n        misses: this.metrics.cacheMisses,\n        size: cacheSize,\n        memory: this.parseCacheMemory(cacheInfo)\n      },\n      errors: {\n        rate: errorRate,\n        count: this.metrics.errors\n      },\n      system: {\n        totalRequests: this.metrics.totalRequests,\n        uptime: Date.now() - this.metrics.lastReset,\n        indexSize: this.searchIndex ? this.searchIndex.getIndex().size : 0\n      }\n    };\n  }\n\n  // 8. PRIVATE HELPER METHODS\n  private async performOptimizedSearch(query: string, filters: SearchFilters): Promise<OptimizedSearchResult> {\n    if (!this.searchIndex) {\n      throw new Error('Search index not initialized');\n    }\n\n    let results = this.searchIndex.search(query);\n    \n    // Apply filters\n    if (filters.category) {\n      results = results.filter(result => result.item.category === filters.category);\n    }\n    \n    if (filters.featured) {\n      results = results.filter(result => result.item.featured);\n    }\n    \n    if (filters.premium !== undefined) {\n      results = results.filter(result => result.item.premium === filters.premium);\n    }\n    \n    if (filters.minRating) {\n      // Would need to fetch rating data from cache or database\n    }\n\n    // Sort results\n    const sortBy = filters.sortBy || 'relevance';\n    if (sortBy !== 'relevance') {\n      results.sort((a, b) => {\n        switch (sortBy) {\n          case 'downloads':\n            return b.item.downloads - a.item.downloads;\n          case 'stars':\n            return b.item.stars - a.item.stars;\n          case 'recent':\n            return new Date(b.item.lastUpdated).getTime() - new Date(a.item.lastUpdated).getTime();\n          case 'name':\n            return a.item.displayName.localeCompare(b.item.displayName);\n          default:\n            return 0;\n        }\n      });\n    }\n\n    // Paginate\n    const page = filters.page || 1;\n    const limit = Math.min(filters.limit || 20, this.config.search.maxResultsPerPage);\n    const offset = (page - 1) * limit;\n    const paginatedResults = results.slice(offset, offset + limit);\n\n    return {\n      plugins: paginatedResults.map(result => ({\n        ...result.item,\n        score: result.score,\n        matches: result.matches\n      })),\n      pagination: {\n        page,\n        limit,\n        total: results.length,\n        totalPages: Math.ceil(results.length / limit),\n        hasNext: offset + limit < results.length,\n        hasPrev: page > 1\n      },\n      searchTime: 0, // Will be set by caller\n      fromCache: false\n    };\n  }\n\n  private async fallbackSearch(query: string, filters: SearchFilters): Promise<OptimizedSearchResult> {\n    // Fallback to database search if search index fails\n    const where: any = {\n      status: 'ACTIVE',\n      OR: [\n        { name: { contains: query, mode: 'insensitive' } },\n        { displayName: { contains: query, mode: 'insensitive' } },\n        { description: { contains: query, mode: 'insensitive' } },\n        { keywords: { hasSome: [query] } }\n      ]\n    };\n\n    if (filters.category) {\n      where.category = filters.category.toUpperCase().replace('-', '_');\n    }\n\n    const plugins = await prisma.plugin.findMany({\n      where,\n      select: {\n        id: true,\n        name: true,\n        displayName: true,\n        description: true,\n        category: true,\n        keywords: true,\n        author: true,\n        downloadCount: true,\n        starCount: true,\n        isFeatured: true,\n        isPremium: true,\n        updatedAt: true\n      },\n      take: filters.limit || 20,\n      skip: ((filters.page || 1) - 1) * (filters.limit || 20)\n    });\n\n    return {\n      plugins: plugins.map(plugin => ({\n        id: plugin.id,\n        name: plugin.name,\n        displayName: plugin.displayName,\n        description: plugin.description,\n        category: plugin.category.toLowerCase().replace('_', '-'),\n        tags: plugin.keywords,\n        author: plugin.author,\n        downloads: plugin.downloadCount || 0,\n        stars: plugin.starCount || 0,\n        featured: plugin.isFeatured,\n        premium: plugin.isPremium,\n        lastUpdated: plugin.updatedAt.toISOString(),\n        score: 1.0 // Default score for fallback\n      })),\n      pagination: {\n        page: filters.page || 1,\n        limit: filters.limit || 20,\n        total: plugins.length,\n        totalPages: 1,\n        hasNext: false,\n        hasPrev: false\n      },\n      searchTime: 0,\n      fromCache: false\n    };\n  }\n\n  private async fetchOptimizedPluginData(pluginId: string, includeAnalytics: boolean): Promise<OptimizedPluginData | null> {\n    const plugin = await prisma.plugin.findUnique({\n      where: { id: pluginId },\n      include: {\n        marketplacePlugin: {\n          include: {\n            reviews: {\n              select: {\n                rating: true,\n                isVerifiedPurchase: true\n              },\n              take: 100 // Limit for performance\n            }\n          }\n        },\n        versions: {\n          orderBy: { createdAt: 'desc' },\n          take: 10\n        },\n        metrics: includeAnalytics ? {\n          where: {\n            timestamp: {\n              gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days\n            }\n          },\n          orderBy: { timestamp: 'desc' },\n          take: 100\n        } : undefined\n      }\n    });\n\n    if (!plugin) return null;\n\n    const reviews = plugin.marketplacePlugin?.reviews || [];\n    const averageRating = reviews.length > 0 \n      ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length \n      : 0;\n\n    return {\n      id: plugin.id,\n      name: plugin.name,\n      displayName: plugin.displayName,\n      description: plugin.description,\n      category: plugin.category.toLowerCase().replace('_', '-'),\n      author: plugin.author,\n      version: plugin.versions[0]?.version || '0.0.0',\n      versions: plugin.versions.map(v => ({\n        version: v.version,\n        status: v.status,\n        createdAt: v.createdAt.toISOString()\n      })),\n      downloads: Number(plugin.downloadCount) || 0,\n      stars: plugin.starCount || 0,\n      rating: averageRating,\n      reviewCount: reviews.length,\n      featured: plugin.isFeatured,\n      premium: plugin.isPremium,\n      installed: plugin.isInstalled,\n      enabled: plugin.isEnabled,\n      tags: plugin.keywords,\n      lastUpdated: plugin.updatedAt.toISOString(),\n      metrics: includeAnalytics && plugin.metrics ? plugin.metrics.map(m => ({\n        name: m.metricName,\n        value: m.value,\n        timestamp: m.timestamp.toISOString()\n      })) : undefined\n    };\n  }\n\n  private async fetchOptimizedPluginsList(filters: SearchFilters, pagination: PaginationOptions): Promise<OptimizedPluginsList> {\n    const where: any = { status: 'ACTIVE' };\n    \n    if (filters.category) {\n      where.category = filters.category.toUpperCase().replace('-', '_');\n    }\n    \n    if (filters.featured) {\n      where.isFeatured = true;\n    }\n    \n    if (filters.premium !== undefined) {\n      where.isPremium = filters.premium;\n    }\n\n    const orderBy: any = [];\n    switch (filters.sortBy) {\n      case 'downloads':\n        orderBy.push({ downloadCount: 'desc' });\n        break;\n      case 'stars':\n        orderBy.push({ starCount: 'desc' });\n        break;\n      case 'recent':\n        orderBy.push({ updatedAt: 'desc' });\n        break;\n      case 'name':\n        orderBy.push({ displayName: 'asc' });\n        break;\n      default:\n        orderBy.push({ isFeatured: 'desc' });\n        orderBy.push({ downloadCount: 'desc' });\n    }\n\n    const [plugins, total] = await Promise.all([\n      prisma.plugin.findMany({\n        where,\n        orderBy,\n        skip: ((pagination.page || 1) - 1) * (pagination.limit || 20),\n        take: pagination.limit || 20,\n        select: {\n          id: true,\n          name: true,\n          displayName: true,\n          description: true,\n          category: true,\n          author: true,\n          downloadCount: true,\n          starCount: true,\n          isFeatured: true,\n          isPremium: true,\n          isInstalled: true,\n          keywords: true,\n          updatedAt: true\n        }\n      }),\n      prisma.plugin.count({ where })\n    ]);\n\n    return {\n      plugins: plugins.map(plugin => ({\n        id: plugin.id,\n        name: plugin.name,\n        displayName: plugin.displayName,\n        description: plugin.description,\n        category: plugin.category.toLowerCase().replace('_', '-'),\n        author: plugin.author,\n        downloads: Number(plugin.downloadCount) || 0,\n        stars: plugin.starCount || 0,\n        featured: plugin.isFeatured,\n        premium: plugin.isPremium,\n        installed: plugin.isInstalled,\n        tags: plugin.keywords,\n        lastUpdated: plugin.updatedAt.toISOString()\n      })),\n      pagination: {\n        page: pagination.page || 1,\n        limit: pagination.limit || 20,\n        total,\n        totalPages: Math.ceil(total / (pagination.limit || 20)),\n        hasNext: ((pagination.page || 1) * (pagination.limit || 20)) < total,\n        hasPrev: (pagination.page || 1) > 1\n      }\n    };\n  }\n\n  private async warmCache(): Promise<void> {\n    console.log('Warming up cache...');\n    \n    // Pre-cache featured plugins\n    const featuredPlugins = await prisma.plugin.findMany({\n      where: { isFeatured: true },\n      select: { id: true },\n      take: 20\n    });\n\n    for (const plugin of featuredPlugins) {\n      await this.getOptimizedPluginData(plugin.id);\n    }\n\n    // Pre-cache category statistics\n    const categoryStats = await prisma.plugin.groupBy({\n      by: ['category'],\n      where: { status: 'ACTIVE' },\n      _count: { category: true }\n    });\n\n    await this.setCache(CACHE_KEYS.CATEGORY_STATS(), categoryStats, this.config.cache.ttl.metadata);\n\n    console.log('Cache warmed up successfully');\n  }\n\n  private async getFromCache<T>(key: string): Promise<T | null> {\n    try {\n      const data = await this.redis.get(key);\n      return data ? JSON.parse(data) : null;\n    } catch (error) {\n      console.warn('Cache read error:', error);\n      return null;\n    }\n  }\n\n  private async setCache(key: string, data: any, ttl: number): Promise<void> {\n    try {\n      await this.redis.setex(key, ttl, JSON.stringify(data));\n    } catch (error) {\n      console.warn('Cache write error:', error);\n    }\n  }\n\n  private calculatePercentile(values: number[], percentile: number): number {\n    if (values.length === 0) return 0;\n    \n    const sorted = [...values].sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n    return sorted[index] || 0;\n  }\n\n  private parseCacheMemory(info: string): number {\n    const match = info.match(/used_memory:(\\d+)/);\n    return match ? parseInt(match[1], 10) : 0;\n  }\n\n  private resetMetrics(): void {\n    this.metrics = {\n      searchLatency: [],\n      cacheHits: 0,\n      cacheMisses: 0,\n      errors: 0,\n      totalRequests: 0,\n      lastReset: Date.now()\n    };\n  }\n\n  // Cleanup\n  async dispose(): Promise<void> {\n    await this.redis.quit();\n    await prisma.$disconnect();\n  }\n}\n\n// Type definitions\ninterface SearchFilters {\n  category?: string;\n  featured?: boolean;\n  premium?: boolean;\n  minRating?: number;\n  sortBy?: 'relevance' | 'downloads' | 'stars' | 'recent' | 'name';\n  page?: number;\n  limit?: number;\n}\n\ninterface PaginationOptions {\n  page?: number;\n  limit?: number;\n}\n\ninterface OptimizedSearchResult {\n  plugins: any[];\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n    hasNext: boolean;\n    hasPrev: boolean;\n  };\n  searchTime: number;\n  fromCache: boolean;\n}\n\ninterface OptimizedPluginData {\n  id: string;\n  name: string;\n  displayName: string;\n  description: string;\n  category: string;\n  author: string;\n  version: string;\n  versions: any[];\n  downloads: number;\n  stars: number;\n  rating: number;\n  reviewCount: number;\n  featured: boolean;\n  premium: boolean;\n  installed: boolean;\n  enabled: boolean;\n  tags: string[];\n  lastUpdated: string;\n  metrics?: any[];\n}\n\ninterface OptimizedPluginsList {\n  plugins: any[];\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n    hasNext: boolean;\n    hasPrev: boolean;\n  };\n}\n\ninterface PerformanceMetrics {\n  searchLatency: number[];\n  cacheHits: number;\n  cacheMisses: number;\n  errors: number;\n  totalRequests: number;\n  lastReset: number;\n}\n\ninterface PerformanceReport {\n  timestamp: string;\n  search: {\n    averageLatency: number;\n    p95Latency: number;\n    p99Latency: number;\n    totalSearches: number;\n  };\n  cache: {\n    hitRate: number;\n    hits: number;\n    misses: number;\n    size: number;\n    memory: number;\n  };\n  errors: {\n    rate: number;\n    count: number;\n  };\n  system: {\n    totalRequests: number;\n    uptime: number;\n    indexSize: number;\n  };\n}\n\n// Singleton instance\nlet optimizerInstance: MarketplacePerformanceOptimizer | null = null;\n\nexport function getPerformanceOptimizer(config?: Partial<PerformanceConfig>): MarketplacePerformanceOptimizer {\n  if (!optimizerInstance) {\n    optimizerInstance = new MarketplacePerformanceOptimizer(config);\n  }\n  return optimizerInstance;\n}\n\nexport function resetPerformanceOptimizer(): void {\n  if (optimizerInstance) {\n    optimizerInstance.dispose();\n    optimizerInstance = null;\n  }\n}