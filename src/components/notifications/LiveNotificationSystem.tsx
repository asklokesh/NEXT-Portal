'use client'; import React, { useState, useEffect, useCallback } from 'react'; import { AnimatePresence, motion } from 'framer-motion'; import { Bell, X, Check, AlertTriangle, Info, Shield, Package, Activity, Eye, EyeOff, Settings, Volume2, VolumeX } from 'lucide-react'; import { useWebSocket } from '@/lib/websocket/client'; import { toast } from 'react-hot-toast'; export interface LiveNotification { id: string; type: 'success' | 'info' | 'warning' | 'error'; category: 'plugin' | 'security' | 'system' | 'quality' | 'deployment'; title: string; message: string; timestamp: string; priority: 'low' | 'normal' | 'high' | 'critical'; read: boolean; persistent?: boolean; actions?: NotificationAction[]; data?: Record<string, any>; } export interface NotificationAction { id: string; label: string; type: 'primary' | 'secondary' | 'danger'; action: () => void; } interface NotificationPreferences { enabled: boolean; soundEnabled: boolean; categories: { plugin: boolean; security: boolean; system: boolean; quality: boolean; deployment: boolean; }; priorities: { low: boolean; normal: boolean; high: boolean; critical: boolean; }; toastEnabled: boolean; persistentEnabled: boolean; } interface LiveNotificationSystemProps { maxNotifications?: number; autoHideDelay?: number; showSettings?: boolean; } export function LiveNotificationSystem({ maxNotifications = 50, autoHideDelay = 5000, showSettings = true }: LiveNotificationSystemProps) { const { isConnected, client } = useWebSocket(); const [notifications, setNotifications] = useState<LiveNotification[]>([]); const [isOpen, setIsOpen] = useState(false); const [preferences, setPreferences] = useState<NotificationPreferences>({ enabled: true, soundEnabled: true, categories: { plugin: true, security: true, system: true, quality: true, deployment: true }, priorities: { low: true, normal: true, high: true, critical: true }, toastEnabled: true, persistentEnabled: true }); const [showPreferences, setShowPreferences] = useState(false); // Load preferences from localStorage useEffect(() => { const saved = localStorage.getItem('notification-preferences'); if (saved) { try { setPreferences({ ...preferences, ...JSON.parse(saved) }); } catch (error) { console.warn('Failed to load notification preferences:', error); } } }, []); // Save preferences to localStorage const savePreferences = useCallback((newPrefs: NotificationPreferences) => { setPreferences(newPrefs); localStorage.setItem('notification-preferences', JSON.stringify(newPrefs)); }, []); // Check if notification should be shown based on preferences const shouldShowNotification = useCallback((notification: LiveNotification) => { if (!preferences.enabled) return false; if (!preferences.categories[notification.category]) return false; if (!preferences.priorities[notification.priority]) return false; return true; }, [preferences]); // Play notification sound const playNotificationSound = useCallback(() => { if (!preferences.soundEnabled) return; // Create a simple beep sound try { const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)(); const oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain(); oscillator.connect(gainNode); gainNode.connect(audioContext.destination); oscillator.frequency.value = 800; oscillator.type = 'sine'; gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5); } catch (error) { console.warn('Failed to play notification sound:', error); } }, [preferences.soundEnabled]); // Add new notification const addNotification = useCallback((notification: Omit<LiveNotification, 'id' | 'timestamp' | 'read'>) => { const newNotification: LiveNotification = { ...notification, id: `notification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, timestamp: new Date().toISOString(), read: false }; if (!shouldShowNotification(newNotification)) { return; } setNotifications(prev => { const updated = [newNotification, ...prev.slice(0, maxNotifications - 1)]; return updated; }); // Show toast notification if (preferences.toastEnabled) { const toastIcon = getNotificationIcon(newNotification.type); switch (newNotification.type) { case 'success': toast.success(newNotification.title, { description: newNotification.message, duration: newNotification.priority === 'critical' ? 0 : autoHideDelay }); break; case 'error': toast.error(newNotification.title, { description: newNotification.message, duration: newNotification.priority === 'critical' ? 0 : autoHideDelay * 2 }); break; case 'warning': toast(newNotification.title, { description: newNotification.message, icon: '', duration: autoHideDelay * 1.5 }); break; default: toast(newNotification.title, { description: newNotification.message, duration: autoHideDelay }); } } // Play sound for high priority notifications if (newNotification.priority === 'high' || newNotification.priority === 'critical') { playNotificationSound(); } }, [shouldShowNotification, maxNotifications, preferences.toastEnabled, autoHideDelay, playNotificationSound]); // WebSocket event listeners useEffect(() => { if (!client || !isConnected) return; // Plugin events client.on('plugin.installed', (data: any) => { addNotification({ type: 'success', category: 'plugin', title: 'Plugin Installed', message: `${data.name} has been successfully installed`, priority: 'normal', data }); }); client.on('plugin.installation.failed', (data: any) => { addNotification({ type: 'error', category: 'plugin', title: 'Installation Failed', message: `Failed to install ${data.name}: ${data.error}`, priority: 'high', persistent: true, data }); }); client.on('plugin.updated', (data: any) => { addNotification({ type: 'success', category: 'plugin', title: 'Plugin Updated', message: `${data.name} updated to version ${data.version}`, priority: 'normal', data }); }); client.on('plugin.health.degraded', (data: any) => { addNotification({ type: 'warning', category: 'plugin', title: 'Plugin Health Warning', message: `${data.name} health dropped to ${data.health}%`, priority: data.health < 30 ? 'high' : 'normal', persistent: data.health < 30, data }); }); // Security events client.on('security.vulnerability.detected', (data: any) => { addNotification({ type: 'error', category: 'security', title: 'Security Vulnerability', message: `${data.severity} vulnerability found in ${data.package}`, priority: data.severity === 'critical' ? 'critical' : 'high', persistent: true, actions: [ { id: 'view-details', label: 'View Details', type: 'primary', action: () => { // Open security dashboard window.open(`/security/vulnerabilities/${data.id}`, '_blank'); } } ], data }); }); client.on('security.scan.completed', (data: any) => { if (data.issues > 0) { addNotification({ type: 'warning', category: 'security', title: 'Security Scan Results', message: `Found ${data.issues} security issues in ${data.scannedPackages} packages`, priority: data.critical > 0 ? 'high' : 'normal', data }); } else { addNotification({ type: 'success', category: 'security', title: 'Security Scan Clean', message: `No security issues found in ${data.scannedPackages} packages`, priority: 'low', data }); } }); // Quality events client.on('quality.evaluation.completed', (data: any) => { const grade = data.grade; const isImprovement = data.previousGrade && grade > data.previousGrade; addNotification({ type: isImprovement ? 'success' : grade >= 'B' ? 'info' : 'warning', category: 'quality', title: 'Quality Evaluation', message: `${data.repository} received grade ${grade} (${data.score}/100)`, priority: grade <= 'D' ? 'high' : 'normal', data }); }); // System events client.on('system.health.changed', (data: any) => { addNotification({ type: data.status === 'healthy' ? 'success' : data.status === 'degraded' ? 'warning' : 'error', category: 'system', title: 'System Health Update', message: `System status: ${data.status}`, priority: data.status === 'critical' ? 'critical' : data.status === 'degraded' ? 'high' : 'normal', persistent: data.status === 'critical', data }); }); // Deployment events client.on('deployment.completed', (data: any) => { addNotification({ type: data.status === 'success' ? 'success' : 'error', category: 'deployment', title: 'Deployment Complete', message: `${data.service} deployment ${data.status === 'success' ? 'succeeded' : 'failed'}`, priority: data.status === 'success' ? 'normal' : 'high', persistent: data.status !== 'success', data }); }); // Cleanup return () => { const events = [ 'plugin.installed', 'plugin.installation.failed', 'plugin.updated', 'plugin.health.degraded', 'security.vulnerability.detected', 'security.scan.completed', 'quality.evaluation.completed', 'system.health.changed', 'deployment.completed' ]; events.forEach(event => client.off(event)); }; }, [client, isConnected, addNotification]); // Get notification icon const getNotificationIcon = (type: string) => { switch (type) { case 'success': return <Check className="w-5 h-5 text-green-600" />; case 'warning': return <AlertTriangle className="w-5 h-5 text-yellow-600" />; case 'error': return <X className="w-5 h-5 text-red-600" />; default: return <Info className="w-5 h-5 text-blue-600" />; } }; // Get category icon const getCategoryIcon = (category: string) => { switch (category) { case 'plugin': return <Package className="w-4 h-4" />; case 'security': return <Shield className="w-4 h-4" />; case 'system': return <Activity className="w-4 h-4" />; default: return <Bell className="w-4 h-4" />; } }; // Mark notification as read const markAsRead = useCallback((notificationId: string) => { setNotifications(prev => prev.map(n => n.id === notificationId ? { ...n, read: true } : n) ); }, []); // Remove notification const removeNotification = useCallback((notificationId: string) => { setNotifications(prev => prev.filter(n => n.id !== notificationId)); }, []); // Clear all notifications const clearAll = useCallback(() => { setNotifications([]); }, []); // Mark all as read const markAllAsRead = useCallback(() => { setNotifications(prev => prev.map(n => ({ ...n, read: true }))); }, []); const unreadCount = notifications.filter(n => !n.read).length; return ( <> {/* Notification Bell */} <div className="relative"> <button onClick={() => setIsOpen(!isOpen)} className="relative p-2 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-lg" > <Bell className="w-6 h-6" /> {unreadCount > 0 && ( <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center"> {unreadCount > 99 ? '99+' : unreadCount} </span> )} <span className={`absolute top-1 right-1 w-2 h-2 rounded-full ${ isConnected ? 'bg-green-400' : 'bg-red-400' }`} /> </button> {/* Notification Panel */} <AnimatePresence> {isOpen && ( <motion.div initial={{ opacity: 0, scale: 0.95, y: -10 }} animate={{ opacity: 1, scale: 1, y: 0 }} exit={{ opacity: 0, scale: 0.95, y: -10 }} className="absolute right-0 mt-2 w-96 bg-white dark:bg-gray-800 rounded-lg shadow-xl border border-gray-200 dark:border-gray-700 z-50" > {/* Header */} <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700"> <h3 className="text-lg font-semibold text-gray-900 dark:text-white"> Notifications </h3> <div className="flex items-center gap-2"> {showSettings && ( <button onClick={() => setShowPreferences(!showPreferences)} className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 rounded" > <Settings className="w-4 h-4" /> </button> )} {unreadCount > 0 && ( <button onClick={markAllAsRead} className="text-sm text-blue-600 hover:text-blue-700 dark:text-blue-400" > Mark all read </button> )} <button onClick={clearAll} className="text-sm text-gray-500 hover:text-gray-700 dark:text-gray-400" > Clear all </button> </div> </div> {/* Preferences Panel */} {showPreferences && ( <div className="p-4 border-b border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-700"> <div className="space-y-3"> <div className="flex items-center justify-between"> <span className="text-sm font-medium">Notifications</span> <button onClick={() => savePreferences({ ...preferences, enabled: !preferences.enabled })} className={`w-8 h-4 rounded-full transition-colors ${ preferences.enabled ? 'bg-blue-600' : 'bg-gray-300' }`} > <div className={`w-4 h-4 rounded-full bg-white transition-transform ${ preferences.enabled ? 'translate-x-4' : '' }`} /> </button> </div> <div className="flex items-center justify-between"> <span className="text-sm">Sound</span> <button onClick={() => savePreferences({ ...preferences, soundEnabled: !preferences.soundEnabled })} > {preferences.soundEnabled ? <Volume2 className="w-4 h-4" /> : <VolumeX className="w-4 h-4" />} </button> </div> <div className="flex items-center justify-between"> <span className="text-sm">Toast notifications</span> <button onClick={() => savePreferences({ ...preferences, toastEnabled: !preferences.toastEnabled })} > {preferences.toastEnabled ? <Eye className="w-4 h-4" /> : <EyeOff className="w-4 h-4" />} </button> </div> </div> </div> )} {/* Notifications List */} <div className="max-h-96 overflow-y-auto"> {notifications.length === 0 ? ( <div className="text-center py-8 text-gray-500 dark:text-gray-400"> <Bell className="w-12 h-12 mx-auto mb-4 opacity-50" /> <p>No notifications</p> <p className="text-sm mt-1">You're all caught up!</p> </div> ) : ( <div className="divide-y divide-gray-200 dark:divide-gray-700"> {notifications.map((notification) => ( <motion.div key={notification.id} initial={{ opacity: 0, x: 20 }} animate={{ opacity: 1, x: 0 }} exit={{ opacity: 0, x: -20 }} className={`p-4 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors ${ !notification.read ? 'bg-blue-50 dark:bg-blue-900/20' : '' }`} onClick={() => markAsRead(notification.id)} > <div className="flex items-start gap-3"> <div className="flex-shrink-0"> {getNotificationIcon(notification.type)} </div> <div className="flex-1 min-w-0"> <div className="flex items-center justify-between"> <p className="text-sm font-medium text-gray-900 dark:text-white"> {notification.title} </p> <div className="flex items-center gap-2"> {getCategoryIcon(notification.category)} <button onClick={(e) => { e.stopPropagation(); removeNotification(notification.id); }} className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300" > <X className="w-4 h-4" /> </button> </div> </div> <p className="text-sm text-gray-600 dark:text-gray-400 mt-1"> {notification.message} </p> <p className="text-xs text-gray-500 dark:text-gray-400 mt-2"> {new Date(notification.timestamp).toLocaleTimeString()} </p> {/* Actions */} {notification.actions && notification.actions.length > 0 && ( <div className="flex gap-2 mt-3"> {notification.actions.map((action) => ( <button key={action.id} onClick={(e) => { e.stopPropagation(); action.action(); }} className={`px-3 py-1 text-xs rounded transition-colors ${ action.type === 'primary' ? 'bg-blue-600 text-white hover:bg-blue-700' : action.type === 'danger' ? 'bg-red-600 text-white hover:bg-red-700' : 'bg-gray-200 text-gray-800 hover:bg-gray-300 dark:bg-gray-600 dark:text-gray-200' }`} > {action.label} </button> ))} </div> )} </div> </div> </motion.div> ))} </div> )} </div> {/* Connection Status */} <div className="p-3 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-700"> <div className="flex items-center justify-between text-xs text-gray-600 dark:text-gray-400"> <span>Live updates: {isConnected ? 'Connected' : 'Disconnected'}</span> <span>{notifications.length} notifications</span> </div> </div> </motion.div> )} </AnimatePresence> </div> {/* Click outside to close */} {isOpen && ( <div className="fixed inset-0 z-40" onClick={() => setIsOpen(false)} /> )} </> ); }