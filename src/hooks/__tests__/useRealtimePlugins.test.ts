/**
 * Comprehensive test suite for useRealtimePlugins hook
 * Focuses on the critical WebSocket listener cleanup bug fix
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { renderHook, act, waitFor } from '@testing-library/react';
import { useRealtimePlugins, RealtimePlugin, PluginEvent } from '../useRealtimePlugins';

// Mock dependencies
jest.mock('@/lib/websocket/client');
jest.mock('../useRealtimePerformance');
jest.mock('react-hot-toast');

describe('useRealtimePlugins Hook', () => {
  let mockClient: any;
  let mockPerformance: any;
  let mockUseWebSocket: jest.Mock;
  let mockUseRealtimePerformance: jest.Mock;
  let mockToast: any;

  beforeEach(() => {
    // Mock WebSocket client
    mockClient = {
      on: jest.fn(),
      off: jest.fn(),
      subscribe: jest.fn(),
      unsubscribe: jest.fn(),
      emit: jest.fn(),
    };

    // Mock performance hook
    mockPerformance = {
      throttledUpdate: jest.fn((fn) => fn()),
      getMetrics: jest.fn(() => ({})),
      isHighLoad: jest.fn(() => false),
      queueSize: 0,
      settings: {},
      clearPendingUpdates: jest.fn(),
    };

    // Mock hooks
    mockUseWebSocket = jest.fn(() => ({
      isConnected: true,
      client: mockClient,
    }));

    mockUseRealtimePerformance = jest.fn(() => mockPerformance);

    // Mock toast
    mockToast = {\n      success: jest.fn(),\n      error: jest.fn(),\n      loading: jest.fn(),\n    };\n\n    // Apply mocks\n    const webSocketModule = require('@/lib/websocket/client');\n    webSocketModule.useWebSocket = mockUseWebSocket;\n\n    const performanceModule = require('../useRealtimePerformance');\n    performanceModule.useRealtimePerformance = mockUseRealtimePerformance;\n\n    const toastModule = require('react-hot-toast');\n    toastModule.toast = mockToast;\n\n    // Mock fetch\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve({\n          success: true,\n          plugins: [\n            {\n              id: 'test-plugin-1',\n              name: 'test-plugin-1',\n              displayName: 'Test Plugin 1',\n              description: 'A test plugin',\n              category: 'open-source',\n              version: '1.0.0',\n              status: 'active',\n              health: 95,\n              qualityGrade: 'A',\n              lastUpdated: '2024-01-01T00:00:00Z',\n              downloads: 1000,\n              stars: 50,\n              isInstalled: true,\n              isEnabled: true,\n              isPremium: false,\n              maintainer: 'test-maintainer',\n              tags: ['test'],\n            } as RealtimePlugin,\n          ],\n        }),\n      })\n    ) as jest.Mock;\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n    jest.resetModules();\n  });\n\n  describe('WebSocket Listener Cleanup - Critical Bug Fix', () => {\n    it('should properly store and cleanup event listeners without TypeError', async () => {\n      const { unmount } = renderHook(() => useRealtimePlugins());\n\n      // Verify listeners were added\n      expect(mockClient.on).toHaveBeenCalledTimes(8); // 8 event types\n      expect(mockClient.subscribe).toHaveBeenCalledWith('plugins');\n\n      // Verify all event types are registered\n      const expectedEventTypes = [\n        'plugin.installed',\n        'plugin.updated',\n        'plugin.removed',\n        'plugin.health.changed',\n        'plugin.quality.updated',\n        'plugin.status.changed',\n        'plugin.installation.progress',\n        'quality.evaluation.completed',\n      ];\n\n      expectedEventTypes.forEach(eventType => {\n        expect(mockClient.on).toHaveBeenCalledWith(eventType, expect.any(Function));\n      });\n\n      // Unmount should not throw TypeError\n      expect(() => unmount()).not.toThrow();\n\n      // Verify cleanup was attempted (cleanup manager should handle the details)\n      // Since we're using the cleanup manager, the specific off calls are handled internally\n    });\n\n    it('should handle undefined listeners gracefully during cleanup', async () => {\n      // Simulate a scenario where client.off might receive undefined listeners\n      mockClient.off = jest.fn((eventType, listener) => {\n        if (typeof listener !== 'function') {\n          throw new TypeError('The \"listener\" argument must be of type Function. Received type undefined');\n        }\n      });\n\n      const { unmount } = renderHook(() => useRealtimePlugins());\n\n      // This should not throw the TypeError anymore due to our fix\n      expect(() => unmount()).not.toThrow();\n    });\n\n    it('should handle client disconnection during cleanup', () => {\n      const { rerender, unmount } = renderHook(() => useRealtimePlugins());\n\n      // Simulate client becoming null\n      mockUseWebSocket.mockReturnValue({\n        isConnected: false,\n        client: null,\n      });\n\n      rerender();\n\n      // Cleanup should handle null client gracefully\n      expect(() => unmount()).not.toThrow();\n    });\n\n    it('should validate WebSocket client before operations', () => {\n      // Mock invalid client\n      mockUseWebSocket.mockReturnValue({\n        isConnected: true,\n        client: { invalid: 'client' }, // Missing required methods\n      });\n\n      const { result } = renderHook(() => useRealtimePlugins());\n\n      // Should handle invalid client gracefully\n      expect(result.current.isConnected).toBe(false);\n    });\n  });\n\n  describe('Component Mount/Unmount Cycles', () => {\n    it('should handle multiple mount/unmount cycles without memory leaks', () => {\n      // Mount and unmount multiple times\n      for (let i = 0; i < 5; i++) {\n        const { unmount } = renderHook(() => useRealtimePlugins());\n        expect(() => unmount()).not.toThrow();\n      }\n\n      // Should not accumulate event listeners\n      expect(mockClient.on).toHaveBeenCalledTimes(40); // 8 events Ã— 5 mounts\n    });\n\n    it('should clean up subscriptions on unmount', () => {\n      const { unmount } = renderHook(() => useRealtimePlugins());\n\n      expect(mockClient.subscribe).toHaveBeenCalledWith('plugins');\n      \n      unmount();\n      \n      // Cleanup should be handled by the cleanup manager\n      // The exact implementation is encapsulated in the utility\n    });\n  });\n\n  describe('Event Handling with Error Boundaries', () => {\n    it('should handle plugin events without crashing on malformed data', async () => {\n      renderHook(() => useRealtimePlugins());\n\n      // Get the listener function for plugin.installed\n      const installedListener = mockClient.on.mock.calls.find(\n        call => call[0] === 'plugin.installed'\n      )?.[1];\n\n      expect(installedListener).toBeDefined();\n\n      // Send malformed data - should not crash\n      expect(() => {\n        installedListener({ invalid: 'data' });\n      }).not.toThrow();\n\n      expect(() => {\n        installedListener(null);\n      }).not.toThrow();\n\n      expect(() => {\n        installedListener(undefined);\n      }).not.toThrow();\n    });\n\n    it('should handle errors in event processing gracefully', async () => {\n      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();\n      \n      renderHook(() => useRealtimePlugins());\n\n      // Get the listener that would cause an error\n      const listener = mockClient.on.mock.calls[0][1];\n      \n      // This should log error but not crash\n      listener({ malformed: 'data that causes processing error' });\n      \n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe('Connection State Management', () => {\n    it('should handle connection state changes correctly', () => {\n      const { result, rerender } = renderHook(() => useRealtimePlugins());\n\n      // Initially connected\n      expect(result.current.isConnected).toBe(true);\n\n      // Disconnect\n      mockUseWebSocket.mockReturnValue({\n        isConnected: false,\n        client: mockClient,\n      });\n\n      rerender();\n\n      expect(result.current.isConnected).toBe(false);\n    });\n\n    it('should handle reconnection scenarios', () => {\n      // Start disconnected\n      mockUseWebSocket.mockReturnValue({\n        isConnected: false,\n        client: null,\n      });\n\n      const { result, rerender } = renderHook(() => useRealtimePlugins());\n      expect(result.current.isConnected).toBe(false);\n\n      // Reconnect\n      mockUseWebSocket.mockReturnValue({\n        isConnected: true,\n        client: mockClient,\n      });\n\n      rerender();\n\n      expect(result.current.isConnected).toBe(true);\n      expect(mockClient.subscribe).toHaveBeenCalledWith('plugins');\n    });\n  });\n\n  describe('Plugin Actions', () => {\n    it('should handle plugin installation with proper error handling', async () => {\n      const { result } = renderHook(() => useRealtimePlugins());\n\n      await act(async () => {\n        await result.current.actions.installPlugin('test-plugin');\n      });\n\n      expect(fetch).toHaveBeenCalledWith('/api/plugins/install', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ pluginId: 'test-plugin' }),\n      });\n    });\n\n    it('should handle plugin installation errors gracefully', async () => {\n      // Mock fetch to reject\n      (global.fetch as jest.Mock).mockImplementationOnce(() =>\n        Promise.resolve({\n          ok: false,\n          statusText: 'Server Error',\n        })\n      );\n\n      const { result } = renderHook(() => useRealtimePlugins());\n\n      await act(async () => {\n        try {\n          await result.current.actions.installPlugin('test-plugin');\n        } catch (error) {\n          expect(error).toBeInstanceOf(Error);\n        }\n      });\n    });\n  });\n\n  describe('Performance Integration', () => {\n    it('should integrate with performance monitoring', () => {\n      renderHook(() => useRealtimePlugins());\n\n      expect(mockUseRealtimePerformance).toHaveBeenCalledWith({\n        throttleInterval: 200,\n        maxUpdatesPerSecond: 20,\n        batchSize: 3,\n        enableMetrics: true,\n        autoAdjust: true,\n      });\n    });\n\n    it('should clean up performance monitoring on unmount', () => {\n      const { unmount } = renderHook(() => useRealtimePlugins());\n\n      unmount();\n\n      expect(mockPerformance.clearPendingUpdates).toHaveBeenCalled();\n    });\n  });\n\n  describe('Error Recovery', () => {\n    it('should recover from WebSocket errors without breaking the component', () => {\n      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();\n      \n      // Mock subscribe to throw error\n      mockClient.subscribe.mockImplementationOnce(() => {\n        throw new Error('Connection failed');\n      });\n\n      const { result } = renderHook(() => useRealtimePlugins());\n\n      // Component should still be functional\n      expect(result.current).toBeDefined();\n      expect(result.current.actions).toBeDefined();\n      \n      consoleSpy.mockRestore();\n    });\n\n    it('should handle fetch errors during initial load', async () => {\n      (global.fetch as jest.Mock).mockImplementationOnce(() =>\n        Promise.reject(new Error('Network error'))\n      );\n\n      const { result } = renderHook(() => useRealtimePlugins());\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n        expect(result.current.error).toBeTruthy();\n      });\n    });\n  });\n});