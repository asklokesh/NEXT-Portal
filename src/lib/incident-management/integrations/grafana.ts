import { GrafanaDashboardConfig } from '../types'; interface GrafanaConfig { enabled: boolean; url: string; apiKey: string; dashboards: GrafanaDashboardConfig[]; } interface GrafanaDashboard { id: number; uid: string; title: string; tags: string[]; type: string; uri: string; url: string; slug: string; folderId: number; folderTitle: string; folderUid: string; folderUrl: string; isStarred: boolean; } interface GrafanaAnnotation { id?: number; dashboardId?: number; panelId?: number; time: number; timeEnd?: number; tags: string[]; text: string; userId?: number; login?: string; email?: string; avatarUrl?: string; } interface GrafanaAlert { id: number; dashboardId: number; dashboardUid: string; dashboardSlug: string; panelId: number; name: string; state: 'alerting' | 'ok' | 'no_data' | 'paused' | 'pending'; newStateDate: string; evalDate: string; evalData: any; executionError: string; url: string; } export class GrafanaClient { private config: GrafanaConfig; constructor(config: GrafanaConfig) { this.config = config; } async getDashboards(): Promise<GrafanaDashboard[]> { if (!this.config.enabled) return []; try { const response = await fetch(`${this.config.url}/api/search?type=dash-db`, { headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } const dashboards = await response.json(); return dashboards || []; } catch (error) { console.error('Failed to fetch Grafana dashboards:', error); return []; } } async getDashboard(uid: string): Promise<any> { if (!this.config.enabled) return null; try { const response = await fetch(`${this.config.url}/api/dashboards/uid/${uid}`, { headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } const result = await response.json(); return result; } catch (error) { console.error('Failed to fetch Grafana dashboard:', error); return null; } } async createAnnotation(annotation: Omit<GrafanaAnnotation, 'id'>): Promise<GrafanaAnnotation | null> { if (!this.config.enabled) return null; try { const response = await fetch(`${this.config.url}/api/annotations`, { method: 'POST', headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' }, body: JSON.stringify(annotation) }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } const result = await response.json(); return { ...annotation, id: result.id }; } catch (error) { console.error('Failed to create Grafana annotation:', error); return null; } } async updateAnnotation(id: number, annotation: Partial<GrafanaAnnotation>): Promise<void> { if (!this.config.enabled) return; try { const response = await fetch(`${this.config.url}/api/annotations/${id}`, { method: 'PUT', headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' }, body: JSON.stringify(annotation) }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } } catch (error) { console.error('Failed to update Grafana annotation:', error); } } async deleteAnnotation(id: number): Promise<void> { if (!this.config.enabled) return; try { const response = await fetch(`${this.config.url}/api/annotations/${id}`, { method: 'DELETE', headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } } catch (error) { console.error('Failed to delete Grafana annotation:', error); } } async getAnnotations(from?: number, to?: number, tags?: string[]): Promise<GrafanaAnnotation[]> { if (!this.config.enabled) return []; const params = new URLSearchParams(); if (from) params.append('from', from.toString()); if (to) params.append('to', to.toString()); if (tags && tags.length > 0) { tags.forEach(tag => params.append('tags', tag)); } try { const response = await fetch(`${this.config.url}/api/annotations?${params}`, { headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } const annotations = await response.json(); return annotations || []; } catch (error) { console.error('Failed to fetch Grafana annotations:', error); return []; } } async getAlerts(): Promise<GrafanaAlert[]> { if (!this.config.enabled) return []; try { const response = await fetch(`${this.config.url}/api/alerts`, { headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } const alerts = await response.json(); return alerts || []; } catch (error) { console.error('Failed to fetch Grafana alerts:', error); return []; } } async pauseAlert(alertId: number): Promise<void> { if (!this.config.enabled) return; try { const response = await fetch(`${this.config.url}/api/alerts/${alertId}/pause`, { method: 'POST', headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ paused: true }) }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } } catch (error) { console.error('Failed to pause Grafana alert:', error); } } async unpauseAlert(alertId: number): Promise<void> { if (!this.config.enabled) return; try { const response = await fetch(`${this.config.url}/api/alerts/${alertId}/pause`, { method: 'POST', headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ paused: false }) }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } } catch (error) { console.error('Failed to unpause Grafana alert:', error); } } async testAlert(alertId: number): Promise<any> { if (!this.config.enabled) return null; try { const response = await fetch(`${this.config.url}/api/alerts/test`, { method: 'POST', headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' }, body: JSON.stringify({ alertId }) }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } const result = await response.json(); return result; } catch (error) { console.error('Failed to test Grafana alert:', error); return null; } } // Incident-specific methods async createIncidentAnnotation(incident: any, dashboardUid?: string): Promise<GrafanaAnnotation | null> { const annotation: Omit<GrafanaAnnotation, 'id'> = { time: incident.createdAt.getTime(), timeEnd: incident.resolvedAt ? incident.resolvedAt.getTime() : undefined, tags: [ 'incident', incident.severity, incident.priority, ...incident.affectedServices, 'backstage' ], text: ` Incident: ${incident.title}\n\nSeverity: ${incident.severity}\nStatus: ${incident.status}\nServices: ${incident.affectedServices.join(', ')}\n\nDescription: ${incident.description}` }; // If specific dashboard is provided, add it if (dashboardUid) { const dashboard = await this.getDashboard(dashboardUid); if (dashboard) { annotation.dashboardId = dashboard.dashboard.id; } } return this.createAnnotation(annotation); } async updateIncidentAnnotation(annotationId: number, incident: any): Promise<void> { await this.updateAnnotation(annotationId, { timeEnd: incident.resolvedAt ? incident.resolvedAt.getTime() : undefined, tags: [ 'incident', incident.severity, incident.priority, ...incident.affectedServices, 'backstage' ], text: ` Incident: ${incident.title}\n\nSeverity: ${incident.severity}\nStatus: ${incident.status}\nServices: ${incident.affectedServices.join(', ')}\n\nDescription: ${incident.description}\n\n${incident.resolution ? `Resolution: ${incident.resolution}` : ''}` }); } async getDashboardUrl(uid: string, params?: Record<string, string>): Promise<string> { let url = `${this.config.url}/d/${uid}`; if (params && Object.keys(params).length > 0) { const searchParams = new URLSearchParams(params); url += `?${searchParams.toString()}`; } return url; } async generateIncidentDashboardUrl(incident: any): Promise<string> { const params: Record<string, string> = { 'from': incident.createdAt.getTime().toString(), 'to': incident.resolvedAt ? incident.resolvedAt.getTime().toString() : Date.now().toString(), 'var-service': incident.affectedServices.join(','), 'orgId': '1' }; // Try to find a relevant dashboard for the affected services const dashboards = await this.getDashboards(); const relevantDashboard = dashboards.find(d => incident.affectedServices.some((service: string) => d.title.toLowerCase().includes(service.toLowerCase()) || d.tags.includes(service.toLowerCase()) ) ); const dashboardUid = relevantDashboard?.uid || 'general'; // Fallback to general dashboard return this.getDashboardUrl(dashboardUid, params); } async searchDashboards(query: string, tags?: string[]): Promise<GrafanaDashboard[]> { if (!this.config.enabled) return []; const params = new URLSearchParams({ query, type: 'dash-db' }); if (tags && tags.length > 0) { tags.forEach(tag => params.append('tag', tag)); } try { const response = await fetch(`${this.config.url}/api/search?${params}`, { headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } const dashboards = await response.json(); return dashboards || []; } catch (error) { console.error('Failed to search Grafana dashboards:', error); return []; } } async getDataSources(): Promise<any[]> { if (!this.config.enabled) return []; try { const response = await fetch(`${this.config.url}/api/datasources`, { headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } const datasources = await response.json(); return datasources || []; } catch (error) { console.error('Failed to fetch Grafana datasources:', error); return []; } } async testDataSource(id: number): Promise<any> { if (!this.config.enabled) return null; try { const response = await fetch(`${this.config.url}/api/datasources/${id}/proxy`, { method: 'GET', headers: { 'Authorization': `Bearer ${this.config.apiKey}`, 'Content-Type': 'application/json' } }); if (!response.ok) { throw new Error(`Grafana API error: ${response.status} ${response.statusText}`); } const result = await response.json(); return result; } catch (error) { console.error('Failed to test Grafana datasource:', error); return null; } } isEnabled(): boolean { return this.config.enabled && !!this.config.url && !!this.config.apiKey; } getConfig(): GrafanaConfig { return { ...this.config }; } getUrl(): string { return this.config.url; } }