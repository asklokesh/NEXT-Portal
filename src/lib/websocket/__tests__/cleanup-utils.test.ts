/**
 * Test suite for WebSocket cleanup utilities
 * Critical for preventing WebSocket listener cleanup issues
 */

import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import {
  createWebSocketCleanupManager,
  safeRemoveListener,
  safeUnsubscribe,
  validateWebSocketClient,
  createWebSocketHookCleanup,
  withWebSocketErrorBoundary,
} from '../cleanup-utils';
import { EventEmitter } from 'events';\n\ndescribe('WebSocket Cleanup Utilities', () => {\n  let mockClient: EventEmitter;\n  let consoleSpy: jest.SpyInstance;\n\n  beforeEach(() => {\n    mockClient = new EventEmitter();\n    consoleSpy = jest.spyOn(console, 'error').mockImplementation();\n  });\n\n  afterEach(() => {\n    consoleSpy.mockRestore();\n    mockClient.removeAllListeners();\n  });\n\n  describe('createWebSocketCleanupManager', () => {\n    it('should create a cleanup manager with all required methods', () => {\n      const manager = createWebSocketCleanupManager();\n      \n      expect(manager.addListener).toBeInstanceOf(Function);\n      expect(manager.removeListener).toBeInstanceOf(Function);\n      expect(manager.removeAllListeners).toBeInstanceOf(Function);\n      expect(manager.getListenerCount).toBeInstanceOf(Function);\n      expect(manager.clear).toBeInstanceOf(Function);\n    });\n\n    it('should add and track listeners correctly', () => {\n      const manager = createWebSocketCleanupManager();\n      const testListener = jest.fn();\n      \n      manager.addListener(mockClient, 'test-event', testListener);\n      \n      expect(manager.getListenerCount()).toBe(1);\n      expect(mockClient.listenerCount('test-event')).toBe(1);\n    });\n\n    it('should remove individual listeners safely', () => {\n      const manager = createWebSocketCleanupManager();\n      const testListener = jest.fn();\n      \n      manager.addListener(mockClient, 'test-event', testListener);\n      expect(manager.getListenerCount()).toBe(1);\n      \n      const removed = manager.removeListener(mockClient, 'test-event');\n      \n      expect(removed).toBe(true);\n      expect(manager.getListenerCount()).toBe(0);\n      expect(mockClient.listenerCount('test-event')).toBe(0);\n    });\n\n    it('should remove all listeners safely', () => {\n      const manager = createWebSocketCleanupManager();\n      const listener1 = jest.fn();\n      const listener2 = jest.fn();\n      \n      manager.addListener(mockClient, 'event1', listener1);\n      manager.addListener(mockClient, 'event2', listener2);\n      \n      expect(manager.getListenerCount()).toBe(2);\n      \n      const allRemoved = manager.removeAllListeners(mockClient);\n      \n      expect(allRemoved).toBe(true);\n      expect(manager.getListenerCount()).toBe(0);\n      expect(mockClient.listenerCount('event1')).toBe(0);\n      expect(mockClient.listenerCount('event2')).toBe(0);\n    });\n\n    it('should handle errors in listener execution gracefully', () => {\n      const manager = createWebSocketCleanupManager();\n      const errorListener = jest.fn(() => {\n        throw new Error('Listener error');\n      });\n      \n      manager.addListener(mockClient, 'test-event', errorListener);\n      \n      // Emit event that will cause listener to throw\n      mockClient.emit('test-event', 'test-data');\n      \n      // Should have logged the error but not crashed\n      expect(consoleSpy).toHaveBeenCalledWith(\n        expect.stringContaining('Error in WebSocket listener for test-event:'),\n        expect.any(Error)\n      );\n    });\n\n    it('should handle invalid client gracefully', () => {\n      const manager = createWebSocketCleanupManager();\n      const warnSpy = jest.spyOn(console, 'warn').mockImplementation();\n      \n      // Try to add listener with null client\n      manager.addListener(null as any, 'test-event', jest.fn());\n      \n      expect(warnSpy).toHaveBeenCalledWith('Invalid WebSocket client provided to cleanup manager');\n      expect(manager.getListenerCount()).toBe(0);\n      \n      warnSpy.mockRestore();\n    });\n\n    it('should handle invalid event types gracefully', () => {\n      const manager = createWebSocketCleanupManager();\n      const warnSpy = jest.spyOn(console, 'warn').mockImplementation();\n      \n      manager.addListener(mockClient, '', jest.fn());\n      manager.addListener(mockClient, null as any, jest.fn());\n      \n      expect(warnSpy).toHaveBeenCalledWith('Invalid event type provided to cleanup manager');\n      expect(manager.getListenerCount()).toBe(0);\n      \n      warnSpy.mockRestore();\n    });\n\n    it('should handle invalid listeners gracefully', () => {\n      const manager = createWebSocketCleanupManager();\n      const warnSpy = jest.spyOn(console, 'warn').mockImplementation();\n      \n      manager.addListener(mockClient, 'test-event', null as any);\n      manager.addListener(mockClient, 'test-event', undefined as any);\n      \n      expect(warnSpy).toHaveBeenCalledWith('Invalid listener function provided to cleanup manager');\n      expect(manager.getListenerCount()).toBe(0);\n      \n      warnSpy.mockRestore();\n    });\n\n    it('should support once listeners', () => {\n      const manager = createWebSocketCleanupManager();\n      const testListener = jest.fn();\n      \n      manager.addListener(mockClient, 'test-event', testListener, { once: true });\n      \n      // Emit twice, listener should only be called once\n      mockClient.emit('test-event', 'data1');\n      mockClient.emit('test-event', 'data2');\n      \n      expect(testListener).toHaveBeenCalledTimes(1);\n      expect(testListener).toHaveBeenCalledWith('data1');\n    });\n  });\n\n  describe('safeRemoveListener', () => {\n    it('should safely remove valid listeners', () => {\n      const testListener = jest.fn();\n      mockClient.on('test-event', testListener);\n      \n      const result = safeRemoveListener(mockClient, 'test-event', testListener);\n      \n      expect(result).toBe(true);\n      expect(mockClient.listenerCount('test-event')).toBe(0);\n    });\n\n    it('should handle null client safely', () => {\n      const result = safeRemoveListener(null, 'test-event', jest.fn());\n      expect(result).toBe(false);\n    });\n\n    it('should handle invalid event type safely', () => {\n      const result = safeRemoveListener(mockClient, '', jest.fn());\n      expect(result).toBe(false);\n    });\n\n    it('should handle null listener safely', () => {\n      const result = safeRemoveListener(mockClient, 'test-event', null);\n      expect(result).toBe(false);\n    });\n\n    it('should handle removal errors gracefully', () => {\n      const mockClientWithError = {\n        off: jest.fn(() => {\n          throw new Error('Removal failed');\n        })\n      };\n      \n      const result = safeRemoveListener(mockClientWithError as any, 'test-event', jest.fn());\n      \n      expect(result).toBe(false);\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Safe remove listener failed for test-event:',\n        expect.any(Error)\n      );\n    });\n  });\n\n  describe('safeUnsubscribe', () => {\n    it('should safely unsubscribe from valid topics', () => {\n      const mockClientWithUnsubscribe = {\n        unsubscribe: jest.fn()\n      };\n      \n      const result = safeUnsubscribe(mockClientWithUnsubscribe, 'test-topic');\n      \n      expect(result).toBe(true);\n      expect(mockClientWithUnsubscribe.unsubscribe).toHaveBeenCalledWith('test-topic');\n    });\n\n    it('should handle null client safely', () => {\n      const result = safeUnsubscribe(null, 'test-topic');\n      expect(result).toBe(false);\n    });\n\n    it('should handle missing unsubscribe method safely', () => {\n      const result = safeUnsubscribe({}, 'test-topic');\n      expect(result).toBe(false);\n    });\n\n    it('should handle invalid topic safely', () => {\n      const mockClientWithUnsubscribe = {\n        unsubscribe: jest.fn()\n      };\n      \n      const result = safeUnsubscribe(mockClientWithUnsubscribe, '');\n      expect(result).toBe(false);\n    });\n\n    it('should handle unsubscribe errors gracefully', () => {\n      const mockClientWithError = {\n        unsubscribe: jest.fn(() => {\n          throw new Error('Unsubscribe failed');\n        })\n      };\n      \n      const result = safeUnsubscribe(mockClientWithError, 'test-topic');\n      \n      expect(result).toBe(false);\n      expect(consoleSpy).toHaveBeenCalledWith(\n        'Safe unsubscribe failed for test-topic:',\n        expect.any(Error)\n      );\n    });\n  });\n\n  describe('validateWebSocketClient', () => {\n    it('should validate proper EventEmitter instances', () => {\n      expect(validateWebSocketClient(mockClient)).toBe(true);\n    });\n\n    it('should reject null/undefined clients', () => {\n      expect(validateWebSocketClient(null)).toBe(false);\n      expect(validateWebSocketClient(undefined)).toBe(false);\n    });\n\n    it('should reject objects missing required methods', () => {\n      expect(validateWebSocketClient({})).toBe(false);\n      expect(validateWebSocketClient({ on: jest.fn() })).toBe(false);\n      expect(validateWebSocketClient({ on: jest.fn(), off: jest.fn() })).toBe(false);\n    });\n\n    it('should validate objects with all required methods', () => {\n      const validClient = {\n        on: jest.fn(),\n        off: jest.fn(),\n        emit: jest.fn(),\n      };\n      \n      expect(validateWebSocketClient(validClient)).toBe(true);\n    });\n  });\n\n  describe('createWebSocketHookCleanup', () => {\n    it('should create a hook cleanup utility', () => {\n      const hookCleanup = createWebSocketHookCleanup();\n      \n      expect(hookCleanup.getManager).toBeInstanceOf(Function);\n      expect(hookCleanup.createCleanupFunction).toBeInstanceOf(Function);\n    });\n\n    it('should provide consistent manager instance', () => {\n      const hookCleanup = createWebSocketHookCleanup();\n      \n      const manager1 = hookCleanup.getManager();\n      const manager2 = hookCleanup.getManager();\n      \n      expect(manager1).toBe(manager2);\n    });\n\n    it('should create cleanup function that removes all listeners', () => {\n      const hookCleanup = createWebSocketHookCleanup();\n      const manager = hookCleanup.getManager();\n      \n      // Add some listeners\n      manager.addListener(mockClient, 'event1', jest.fn());\n      manager.addListener(mockClient, 'event2', jest.fn());\n      \n      expect(manager.getListenerCount()).toBe(2);\n      \n      // Create and execute cleanup function\n      const cleanup = hookCleanup.createCleanupFunction(mockClient);\n      cleanup();\n      \n      // Manager should be reset\n      const newManager = hookCleanup.getManager();\n      expect(newManager.getListenerCount()).toBe(0);\n    });\n\n    it('should handle null client in cleanup function', () => {\n      const hookCleanup = createWebSocketHookCleanup();\n      const cleanup = hookCleanup.createCleanupFunction(null);\n      \n      // Should not throw\n      expect(() => cleanup()).not.toThrow();\n    });\n  });\n\n  describe('withWebSocketErrorBoundary', () => {\n    it('should execute operation normally when no error occurs', () => {\n      const operation = jest.fn((a: number, b: number) => a + b);\n      const wrappedOperation = withWebSocketErrorBoundary(operation);\n      \n      const result = wrappedOperation(2, 3);\n      \n      expect(result).toBe(5);\n      expect(operation).toHaveBeenCalledWith(2, 3);\n    });\n\n    it('should catch errors and return fallback', () => {\n      const operation = jest.fn(() => {\n        throw new Error('Operation failed');\n      });\n      const wrappedOperation = withWebSocketErrorBoundary(operation, 'fallback');\n      \n      const result = wrappedOperation();\n      \n      expect(result).toBe('fallback');\n      expect(consoleSpy).toHaveBeenCalledWith('WebSocket operation error:', expect.any(Error));\n    });\n\n    it('should return undefined when no fallback provided', () => {\n      const operation = jest.fn(() => {\n        throw new Error('Operation failed');\n      });\n      const wrappedOperation = withWebSocketErrorBoundary(operation);\n      \n      const result = wrappedOperation();\n      \n      expect(result).toBeUndefined();\n    });\n\n    it('should preserve function signature', () => {\n      const operation = (a: string, b: number): string => `${a}-${b}`;\n      const wrappedOperation = withWebSocketErrorBoundary(operation, 'error');\n      \n      const result = wrappedOperation('test', 123);\n      \n      expect(result).toBe('test-123');\n    });\n  });\n\n  describe('Integration Tests', () => {\n    it('should handle complete WebSocket lifecycle without errors', () => {\n      const hookCleanup = createWebSocketHookCleanup();\n      const manager = hookCleanup.getManager();\n      \n      // Add multiple listeners\n      const listeners = [\n        jest.fn(),\n        jest.fn(),\n        jest.fn(),\n      ];\n      \n      listeners.forEach((listener, index) => {\n        manager.addListener(mockClient, `event-${index}`, listener);\n      });\n      \n      expect(manager.getListenerCount()).toBe(3);\n      \n      // Emit events\n      mockClient.emit('event-0', 'data0');\n      mockClient.emit('event-1', 'data1');\n      mockClient.emit('event-2', 'data2');\n      \n      expect(listeners[0]).toHaveBeenCalledWith('data0');\n      expect(listeners[1]).toHaveBeenCalledWith('data1');\n      expect(listeners[2]).toHaveBeenCalledWith('data2');\n      \n      // Clean up\n      const cleanup = hookCleanup.createCleanupFunction(mockClient);\n      expect(() => cleanup()).not.toThrow();\n      \n      // Verify no listeners remain\n      expect(mockClient.listenerCount('event-0')).toBe(0);\n      expect(mockClient.listenerCount('event-1')).toBe(0);\n      expect(mockClient.listenerCount('event-2')).toBe(0);\n    });\n  });\n});