import { Octokit } from '@octokit/rest';
import * as yaml from 'js-yaml';
import { z } from 'zod';

// Types for GitHub scanning
export interface GitHubConfig {
  token?: string;
  appId?: number;
  privateKey?: string;
  installationId?: number;
  baseUrl?: string;
}

export interface Repository {
  id: number;
  name: string;
  full_name: string;
  description: string | null;
  private: boolean;
  html_url: string;
  clone_url: string;
  ssh_url: string;
  default_branch: string;
  language: string | null;
  languages: Record<string, number>;
  topics: string[];
  created_at: string;
  updated_at: string;
  pushed_at: string;
  stargazers_count: number;
  forks_count: number;
  size: number;
  archived: boolean;
  disabled: boolean;
  has_catalog_info: boolean;
  catalog_info?: CatalogEntity;
  auto_generated_catalog?: CatalogEntity;
  dependencies: DependencyInfo;
  team_ownership?: TeamOwnership;
  framework_detection: FrameworkDetection;
}

export interface CatalogEntity {
  apiVersion: string;
  kind: string;
  metadata: {
    name: string;
    namespace?: string;
    title?: string;
    description?: string;
    labels?: Record<string, string>;
    annotations?: Record<string, string>;
    tags?: string[];
    links?: Array<{
      url: string;
      title?: string;
      icon?: string;
    }>;
  };
  spec?: Record<string, any>;
  relations?: Array<{
    type: string;
    targetRef: string;
  }>;
}

export interface DependencyInfo {
  package_json?: {
    dependencies?: Record<string, string>;
    devDependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
  };
  requirements_txt?: string[];
  go_mod?: {
    module: string;
    dependencies: Array<{
      path: string;
      version: string;
    }>;
  };
  pom_xml?: {
    groupId: string;
    artifactId: string;
    version: string;
    dependencies: Array<{
      groupId: string;
      artifactId: string;
      version: string;
      scope?: string;
    }>;
  };
  gemfile?: {
    gems: Array<{
      name: string;
      version?: string;
    }>;
  };
}

export interface TeamOwnership {
  teams: string[];
  codeowners: CodeOwner[];
  maintainers: string[];
}

export interface CodeOwner {
  pattern: string;
  owners: string[];
}

export interface FrameworkDetection {
  framework: string | null;
  version?: string;
  confidence: number;
  indicators: string[];
}

export interface ScanOptions {
  organizations?: string[];
  users?: string[];
  repositories?: string[];
  includePrivate?: boolean;
  includeArchived?: boolean;
  includeForks?: boolean;
  batchSize?: number;
  rateLimitDelay?: number;
  maxConcurrent?: number;
  dryRun?: boolean;
}

export interface ScanResult {
  repositories: Repository[];
  totalScanned: number;
  rateLimitInfo: {
    limit: number;
    remaining: number;
    resetTime: Date;
  };
  errors: Array<{
    repository?: string;
    error: string;
    details?: any;
  }>;
  summary: {
    withCatalogInfo: number;
    autoGenerated: number;
    private: number;
    archived: number;
    byLanguage: Record<string, number>;
    byFramework: Record<string, number>;
  };
}

// Validation schema for catalog-info.yaml
const CatalogEntitySchema = z.object({
  apiVersion: z.string(),
  kind: z.string(),
  metadata: z.object({
    name: z.string(),
    namespace: z.string().optional(),
    title: z.string().optional(),
    description: z.string().optional(),
    labels: z.record(z.string()).optional(),
    annotations: z.record(z.string()).optional(),
    tags: z.array(z.string()).optional(),
    links: z.array(z.object({
      url: z.string(),
      title: z.string().optional(),
      icon: z.string().optional(),
    })).optional(),
  }),
  spec: z.record(z.any()).optional(),
  relations: z.array(z.object({
    type: z.string(),
    targetRef: z.string(),
  })).optional(),
});

export class GitHubScanner {
  private octokit: Octokit;
  private config: GitHubConfig;

  constructor(config: GitHubConfig) {
    this.config = config;
    
    if (config.appId && config.privateKey && config.installationId) {
      // GitHub App authentication
      this.octokit = new Octokit({
        auth: {
          appId: config.appId,
          privateKey: config.privateKey,
          installationId: config.installationId,
        },
        baseUrl: config.baseUrl,
      });
    } else if (config.token) {
      // Personal Access Token authentication
      this.octokit = new Octokit({
        auth: config.token,
        baseUrl: config.baseUrl,
      });
    } else {
      throw new Error('GitHub authentication configuration is required');
    }
  }

  /**
   * Scan repositories based on the provided options
   */
  async scanRepositories(options: ScanOptions = {}): Promise<ScanResult> {
    const {
      organizations = [],
      users = [],
      repositories = [],
      includePrivate = false,
      includeArchived = false,
      includeForks = true,
      batchSize = 50,
      rateLimitDelay = 1000,
      maxConcurrent = 5,
      dryRun = false,
    } = options;

    const allRepos: Repository[] = [];
    const errors: Array<{ repository?: string; error: string; details?: any }> = [];

    try {
      // Collect repositories from different sources
      const repoSources: Array<() => Promise<any[]>> = [];

      // Add organization repositories
      for (const org of organizations) {
        repoSources.push(() => this.getOrganizationRepositories(org, {
          includePrivate,
          includeArchived,
          includeForks,
        }));
      }

      // Add user repositories
      for (const user of users) {
        repoSources.push(() => this.getUserRepositories(user, {
          includePrivate,
          includeArchived,
          includeForks,
        }));
      }

      // Add specific repositories
      if (repositories.length > 0) {
        repoSources.push(() => Promise.resolve(
          repositories.map(repo => ({ full_name: repo }))
        ));
      }

      // Fetch repositories with concurrency control
      const repoPromises = repoSources.map(source => 
        this.executeWithRetry(source, 3, rateLimitDelay)
      );

      const repoResults = await Promise.allSettled(repoPromises);
      const flatRepos = repoResults
        .filter((result): result is PromiseFulfilledResult<any[]> => 
          result.status === 'fulfilled'
        )
        .flatMap(result => result.value);

      // Process repositories in batches
      const batches = this.createBatches(flatRepos, batchSize);
      
      for (const batch of batches) {
        const batchPromises = batch.map(repo => 
          this.processRepository(repo.full_name || repo.name, dryRun)
            .catch(error => {
              errors.push({
                repository: repo.full_name || repo.name,
                error: error.message,
                details: error,
              });
              return null;
            })
        );

        const batchResults = await Promise.all(batchPromises);
        const validResults = batchResults.filter((repo): repo is Repository => repo !== null);
        allRepos.push(...validResults);

        // Rate limiting delay between batches
        if (rateLimitDelay > 0) {
          await this.delay(rateLimitDelay);
        }
      }

      // Get rate limit information
      const rateLimitInfo = await this.getRateLimitInfo();

      // Generate summary
      const summary = this.generateSummary(allRepos);

      return {
        repositories: allRepos,
        totalScanned: allRepos.length,
        rateLimitInfo,
        errors,
        summary,
      };

    } catch (error) {
      throw new Error(`GitHub scanning failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Process a single repository
   */
  private async processRepository(fullName: string, dryRun: boolean = false): Promise<Repository> {
    const [owner, repo] = fullName.split('/');
    
    if (!owner || !repo) {
      throw new Error(`Invalid repository name format: ${fullName}`);
    }

    // Get repository information
    const { data: repoData } = await this.octokit.rest.repos.get({
      owner,
      repo,
    });

    // Get languages
    const { data: languages } = await this.octokit.rest.repos.listLanguages({
      owner,
      repo,
    });

    // Get topics
    const { data: topicsData } = await this.octokit.rest.repos.getAllTopics({
      owner,
      repo,
    });

    // Check for catalog-info.yaml
    const catalogInfo = await this.getCatalogInfo(owner, repo);
    
    // Get dependencies
    const dependencies = await this.scanDependencies(owner, repo);
    
    // Get team ownership
    const teamOwnership = await this.getTeamOwnership(owner, repo);
    
    // Detect framework
    const frameworkDetection = await this.detectFramework(owner, repo, languages);

    // Generate auto catalog if none exists
    let autoGeneratedCatalog: CatalogEntity | undefined;
    if (!catalogInfo && !dryRun) {
      autoGeneratedCatalog = this.generateCatalogEntity(repoData, {
        languages,
        topics: topicsData.names,
        dependencies,
        frameworkDetection,
      });
    }

    const repository: Repository = {
      id: repoData.id,
      name: repoData.name,
      full_name: repoData.full_name,
      description: repoData.description,
      private: repoData.private,
      html_url: repoData.html_url,
      clone_url: repoData.clone_url,
      ssh_url: repoData.ssh_url,
      default_branch: repoData.default_branch,
      language: repoData.language,
      languages,
      topics: topicsData.names,
      created_at: repoData.created_at,
      updated_at: repoData.updated_at,
      pushed_at: repoData.pushed_at || repoData.updated_at,
      stargazers_count: repoData.stargazers_count,
      forks_count: repoData.forks_count,
      size: repoData.size,
      archived: repoData.archived,
      disabled: repoData.disabled,
      has_catalog_info: !!catalogInfo,
      catalog_info: catalogInfo,
      auto_generated_catalog: autoGeneratedCatalog,
      dependencies,
      team_ownership: teamOwnership,
      framework_detection: frameworkDetection,
    };

    return repository;
  }

  /**
   * Get organization repositories
   */
  private async getOrganizationRepositories(
    org: string, 
    options: { includePrivate?: boolean; includeArchived?: boolean; includeForks?: boolean }
  ): Promise<any[]> {
    const repos: any[] = [];
    let page = 1;
    const perPage = 100;

    while (true) {
      const { data } = await this.octokit.rest.repos.listForOrg({
        org,
        type: options.includePrivate ? 'all' : 'public',
        page,
        per_page: perPage,
      });

      if (data.length === 0) break;

      const filteredRepos = data.filter(repo => {
        if (!options.includeArchived && repo.archived) return false;
        if (!options.includeForks && repo.fork) return false;
        return true;
      });

      repos.push(...filteredRepos);
      
      if (data.length < perPage) break;
      page++;
    }

    return repos;
  }

  /**
   * Get user repositories
   */
  private async getUserRepositories(
    username: string,
    options: { includePrivate?: boolean; includeArchived?: boolean; includeForks?: boolean }
  ): Promise<any[]> {
    const repos: any[] = [];
    let page = 1;
    const perPage = 100;

    while (true) {
      const { data } = await this.octokit.rest.repos.listForUser({
        username,
        type: options.includePrivate ? 'all' : 'public',
        page,
        per_page: perPage,
      });

      if (data.length === 0) break;

      const filteredRepos = data.filter(repo => {
        if (!options.includeArchived && repo.archived) return false;
        if (!options.includeForks && repo.fork) return false;
        return true;
      });

      repos.push(...filteredRepos);
      
      if (data.length < perPage) break;
      page++;
    }

    return repos;
  }

  /**
   * Get catalog-info.yaml from repository
   */
  private async getCatalogInfo(owner: string, repo: string): Promise<CatalogEntity | null> {
    const possiblePaths = [
      'catalog-info.yaml',
      'catalog-info.yml',
      '.backstage/catalog-info.yaml',
      '.backstage/catalog-info.yml',
      'backstage/catalog-info.yaml',
      'backstage/catalog-info.yml',
    ];

    for (const path of possiblePaths) {
      try {
        const { data } = await this.octokit.rest.repos.getContent({
          owner,
          repo,
          path,
        });

        if ('content' in data && data.content) {
          const content = Buffer.from(data.content, 'base64').toString('utf-8');
          const parsed = yaml.load(content) as any;
          
          // Validate the catalog entity
          const validated = CatalogEntitySchema.parse(parsed);
          return validated;
        }
      } catch (error) {
        // File doesn't exist or is invalid, continue to next path
        continue;
      }
    }

    return null;
  }

  /**
   * Scan repository dependencies
   */
  private async scanDependencies(owner: string, repo: string): Promise<DependencyInfo> {
    const dependencies: DependencyInfo = {};

    // Scan package.json (Node.js)
    try {
      const { data } = await this.octokit.rest.repos.getContent({
        owner,
        repo,
        path: 'package.json',
      });

      if ('content' in data && data.content) {
        const content = Buffer.from(data.content, 'base64').toString('utf-8');
        const packageJson = JSON.parse(content);
        dependencies.package_json = {
          dependencies: packageJson.dependencies,
          devDependencies: packageJson.devDependencies,
          peerDependencies: packageJson.peerDependencies,
        };
      }
    } catch (error) {
      // File doesn't exist
    }

    // Scan requirements.txt (Python)
    try {
      const { data } = await this.octokit.rest.repos.getContent({
        owner,
        repo,
        path: 'requirements.txt',
      });

      if ('content' in data && data.content) {
        const content = Buffer.from(data.content, 'base64').toString('utf-8');
        dependencies.requirements_txt = content
          .split('\n')
          .filter(line => line.trim() && !line.startsWith('#'))
          .map(line => line.trim());
      }
    } catch (error) {
      // File doesn't exist
    }

    // Scan go.mod (Go)
    try {
      const { data } = await this.octokit.rest.repos.getContent({
        owner,
        repo,
        path: 'go.mod',
      });

      if ('content' in data && data.content) {
        const content = Buffer.from(data.content, 'base64').toString('utf-8');
        const goMod = this.parseGoMod(content);
        dependencies.go_mod = goMod;
      }
    } catch (error) {
      // File doesn't exist
    }

    // Scan pom.xml (Java/Maven)
    try {
      const { data } = await this.octokit.rest.repos.getContent({
        owner,
        repo,
        path: 'pom.xml',
      });

      if ('content' in data && data.content) {
        const content = Buffer.from(data.content, 'base64').toString('utf-8');
        const pomXml = this.parsePomXml(content);
        dependencies.pom_xml = pomXml;
      }
    } catch (error) {
      // File doesn't exist
    }

    // Scan Gemfile (Ruby)
    try {
      const { data } = await this.octokit.rest.repos.getContent({
        owner,
        repo,
        path: 'Gemfile',
      });

      if ('content' in data && data.content) {
        const content = Buffer.from(data.content, 'base64').toString('utf-8');
        const gemfile = this.parseGemfile(content);
        dependencies.gemfile = gemfile;
      }
    } catch (error) {
      // File doesn't exist
    }

    return dependencies;
  }

  /**
   * Get team ownership information
   */
  private async getTeamOwnership(owner: string, repo: string): Promise<TeamOwnership | undefined> {
    const ownership: TeamOwnership = {
      teams: [],
      codeowners: [],
      maintainers: [],
    };

    // Get CODEOWNERS file
    const codeownersPaths = [
      'CODEOWNERS',
      '.github/CODEOWNERS',
      'docs/CODEOWNERS',
    ];

    for (const path of codeownersPaths) {
      try {
        const { data } = await this.octokit.rest.repos.getContent({
          owner,
          repo,
          path,
        });

        if ('content' in data && data.content) {
          const content = Buffer.from(data.content, 'base64').toString('utf-8');
          ownership.codeowners = this.parseCodeowners(content);
          break;
        }
      } catch (error) {
        // File doesn't exist
        continue;
      }
    }

    // Try to get team information (requires organization membership)
    try {
      const { data: teams } = await this.octokit.rest.repos.listTeams({
        owner,
        repo,
      });
      
      ownership.teams = teams.map(team => team.name);
    } catch (error) {
      // No access to team information
    }

    return ownership.teams.length > 0 || ownership.codeowners.length > 0 
      ? ownership 
      : undefined;
  }

  /**
   * Detect framework and technology stack
   */
  private async detectFramework(
    owner: string, 
    repo: string, 
    languages: Record<string, number>
  ): Promise<FrameworkDetection> {
    const indicators: string[] = [];
    let framework: string | null = null;
    let version: string | undefined;
    let confidence = 0;

    // Primary language
    const primaryLanguage = Object.keys(languages)[0];
    if (primaryLanguage) {
      indicators.push(`Primary language: ${primaryLanguage}`);
    }

    // Framework detection based on files and dependencies
    const detectionRules = [
      // React
      {
        framework: 'React',
        files: ['package.json'],
        patterns: ['"react":', '"@types/react":'],
        confidence: 90,
      },
      // Next.js
      {
        framework: 'Next.js',
        files: ['package.json', 'next.config.js', 'next.config.ts'],
        patterns: ['"next":', 'next.config'],
        confidence: 95,
      },
      // Vue.js
      {
        framework: 'Vue.js',
        files: ['package.json'],
        patterns: ['"vue":', '"@vue/'],
        confidence: 90,
      },
      // Angular
      {
        framework: 'Angular',
        files: ['package.json', 'angular.json'],
        patterns: ['"@angular/', 'angular.json'],
        confidence: 95,
      },
      // Spring Boot
      {
        framework: 'Spring Boot',
        files: ['pom.xml', 'build.gradle'],
        patterns: ['spring-boot-starter', 'org.springframework.boot'],
        confidence: 95,
      },
      // Django
      {
        framework: 'Django',
        files: ['requirements.txt', 'manage.py'],
        patterns: ['Django==', 'django>=', 'manage.py'],
        confidence: 95,
      },
      // Flask
      {
        framework: 'Flask',
        files: ['requirements.txt'],
        patterns: ['Flask==', 'flask>='],
        confidence: 85,
      },
      // Express.js
      {
        framework: 'Express.js',
        files: ['package.json'],
        patterns: ['"express":'],
        confidence: 80,
      },
      // Laravel
      {
        framework: 'Laravel',
        files: ['composer.json', 'artisan'],
        patterns: ['laravel/framework', 'artisan'],
        confidence: 95,
      },
      // Ruby on Rails
      {
        framework: 'Ruby on Rails',
        files: ['Gemfile', 'config/application.rb'],
        patterns: ['gem "rails"', 'Rails.application'],
        confidence: 95,
      },
    ];

    for (const rule of detectionRules) {
      let ruleScore = 0;
      const ruleIndicators: string[] = [];

      for (const file of rule.files) {
        try {
          const { data } = await this.octokit.rest.repos.getContent({
            owner,
            repo,
            path: file,
          });

          if ('content' in data && data.content) {
            const content = Buffer.from(data.content, 'base64').toString('utf-8');
            
            for (const pattern of rule.patterns) {
              if (content.includes(pattern)) {
                ruleScore += 20;
                ruleIndicators.push(`Found ${pattern} in ${file}`);
              }
            }
          }
        } catch (error) {
          // File doesn't exist
        }
      }

      if (ruleScore > 0 && ruleScore > confidence) {
        confidence = Math.min(rule.confidence, ruleScore);
        framework = rule.framework;
        indicators.push(...ruleIndicators);
      }
    }

    return {
      framework,
      version,
      confidence,
      indicators,
    };
  }

  /**
   * Generate a catalog entity for a repository
   */
  private generateCatalogEntity(
    repoData: any,
    context: {
      languages: Record<string, number>;
      topics: string[];
      dependencies: DependencyInfo;
      frameworkDetection: FrameworkDetection;
    }
  ): CatalogEntity {
    const { languages, topics, dependencies, frameworkDetection } = context;
    
    // Determine entity kind based on repository characteristics
    let kind = 'Component';
    let entityType = 'service';

    // Detect if it's a library or tool
    if (dependencies.package_json?.name?.includes('lib') || 
        topics.includes('library') || 
        topics.includes('package')) {
      entityType = 'library';
    }

    // Detect if it's a website or documentation
    if (topics.includes('website') || 
        topics.includes('documentation') || 
        topics.includes('docs')) {
      entityType = 'website';
    }

    // Generate labels
    const labels: Record<string, string> = {};
    
    if (frameworkDetection.framework) {
      labels['backstage.io/framework'] = frameworkDetection.framework.toLowerCase().replace(/\s+/g, '-');
    }
    
    const primaryLanguage = Object.keys(languages)[0];
    if (primaryLanguage) {
      labels['backstage.io/language'] = primaryLanguage.toLowerCase();
    }

    // Generate annotations
    const annotations: Record<string, string> = {
      'github.com/project-slug': repoData.full_name,
      'backstage.io/source-location': `url:${repoData.html_url}`,
    };

    if (repoData.homepage) {
      annotations['backstage.io/view-url'] = repoData.homepage;
    }

    // Generate links
    const links = [
      {
        url: repoData.html_url,
        title: 'Repository',
        icon: 'github',
      },
    ];

    if (repoData.homepage) {
      links.push({
        url: repoData.homepage,
        title: 'Website',
        icon: 'web',
      });
    }

    const entity: CatalogEntity = {
      apiVersion: 'backstage.io/v1alpha1',
      kind,
      metadata: {
        name: repoData.name.toLowerCase().replace(/[^a-z0-9-]/g, '-'),
        title: repoData.name,
        description: repoData.description || `Auto-generated catalog entry for ${repoData.name}`,
        labels,
        annotations,
        tags: [...topics, 'auto-generated'],
        links,
      },
      spec: {
        type: entityType,
        lifecycle: 'experimental',
        owner: 'unknown',
      },
    };

    return entity;
  }

  /**
   * Utility methods
   */
  private async getRateLimitInfo() {
    const { data } = await this.octokit.rest.rateLimit.get();
    return {
      limit: data.rate.limit,
      remaining: data.rate.remaining,
      resetTime: new Date(data.rate.reset * 1000),
    };
  }

  private generateSummary(repositories: Repository[]) {
    const summary = {
      withCatalogInfo: 0,
      autoGenerated: 0,
      private: 0,
      archived: 0,
      byLanguage: {} as Record<string, number>,
      byFramework: {} as Record<string, number>,
    };

    for (const repo of repositories) {
      if (repo.has_catalog_info) summary.withCatalogInfo++;
      if (repo.auto_generated_catalog) summary.autoGenerated++;
      if (repo.private) summary.private++;
      if (repo.archived) summary.archived++;

      // Count by language
      if (repo.language) {
        summary.byLanguage[repo.language] = (summary.byLanguage[repo.language] || 0) + 1;
      }

      // Count by framework
      if (repo.framework_detection.framework) {
        const framework = repo.framework_detection.framework;
        summary.byFramework[framework] = (summary.byFramework[framework] || 0) + 1;
      }
    }

    return summary;
  }

  private createBatches<T>(items: T[], batchSize: number): T[][] {
    const batches: T[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  private async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private async executeWithRetry<T>(
    fn: () => Promise<T>,
    maxRetries: number,
    delay: number
  ): Promise<T> {
    let lastError: Error;
    
    for (let i = 0; i <= maxRetries; i++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        
        if (i < maxRetries) {
          await this.delay(delay * Math.pow(2, i)); // Exponential backoff
        }
      }
    }
    
    throw lastError!;
  }

  /**
   * Parsers for different dependency files
   */
  private parseGoMod(content: string): DependencyInfo['go_mod'] {
    const lines = content.split('\n');
    const result: DependencyInfo['go_mod'] = {
      module: '',
      dependencies: [],
    };

    let inRequireBlock = false;
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      if (trimmed.startsWith('module ')) {
        result.module = trimmed.substring(7);
      } else if (trimmed === 'require (') {
        inRequireBlock = true;
      } else if (trimmed === ')' && inRequireBlock) {
        inRequireBlock = false;
      } else if (inRequireBlock || trimmed.startsWith('require ')) {
        const requireLine = trimmed.replace('require ', '');
        const match = requireLine.match(/^(\S+)\s+(\S+)/);
        if (match) {
          result.dependencies.push({
            path: match[1],
            version: match[2],
          });
        }
      }
    }

    return result;
  }

  private parsePomXml(content: string): DependencyInfo['pom_xml'] {
    // Basic XML parsing - in production, use a proper XML parser
    const result: DependencyInfo['pom_xml'] = {
      groupId: '',
      artifactId: '',
      version: '',
      dependencies: [],
    };

    // Extract basic project information
    const groupIdMatch = content.match(/<groupId>([^<]+)<\/groupId>/);
    const artifactIdMatch = content.match(/<artifactId>([^<]+)<\/artifactId>/);
    const versionMatch = content.match(/<version>([^<]+)<\/version>/);

    if (groupIdMatch) result.groupId = groupIdMatch[1];
    if (artifactIdMatch) result.artifactId = artifactIdMatch[1];
    if (versionMatch) result.version = versionMatch[1];

    // Extract dependencies (simplified)
    const dependencyRegex = /<dependency>([\s\S]*?)<\/dependency>/g;
    let match;
    
    while ((match = dependencyRegex.exec(content)) !== null) {
      const depContent = match[1];
      const depGroupId = depContent.match(/<groupId>([^<]+)<\/groupId>/)?.[1];
      const depArtifactId = depContent.match(/<artifactId>([^<]+)<\/artifactId>/)?.[1];
      const depVersion = depContent.match(/<version>([^<]+)<\/version>/)?.[1];
      const depScope = depContent.match(/<scope>([^<]+)<\/scope>/)?.[1];

      if (depGroupId && depArtifactId) {
        result.dependencies.push({
          groupId: depGroupId,
          artifactId: depArtifactId,
          version: depVersion || '',
          scope: depScope,
        });
      }
    }

    return result;
  }

  private parseGemfile(content: string): DependencyInfo['gemfile'] {
    const result: DependencyInfo['gemfile'] = {
      gems: [],
    };

    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      // Match gem declarations
      const gemMatch = trimmed.match(/^gem\s+['"]([^'"]+)['"](?:\s*,\s*['"]([^'"]+)['"])?/);
      if (gemMatch) {
        result.gems.push({
          name: gemMatch[1],
          version: gemMatch[2],
        });
      }
    }

    return result;
  }

  private parseCodeowners(content: string): CodeOwner[] {
    const codeowners: CodeOwner[] = [];
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      
      // Skip comments and empty lines
      if (!trimmed || trimmed.startsWith('#')) continue;
      
      const parts = trimmed.split(/\s+/);
      if (parts.length >= 2) {
        const pattern = parts[0];
        const owners = parts.slice(1);
        
        codeowners.push({
          pattern,
          owners,
        });
      }
    }

    return codeowners;
  }
}

// Export types for use in other modules
export type {
  GitHubConfig,
  Repository,
  CatalogEntity,
  DependencyInfo,
  TeamOwnership,
  FrameworkDetection,
  ScanOptions,
  ScanResult,
};