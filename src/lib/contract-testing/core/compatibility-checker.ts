import { PactContract, OpenAPISpec, CompatibilityResult, BreakingChange, Warning } from '../types'; import { ContractValidator } from './contract-validator'; import { SemanticVersionManager } from '../versioning/semantic-version'; import { Logger } from 'winston'; export interface CompatibilityCheckOptions { checkBackwardCompatibility?: boolean; checkForwardCompatibility?: boolean; strictMode?: boolean; ignoreOptionalFields?: boolean; checkResponseHeaders?: boolean; validateExamples?: boolean; customRules?: CompatibilityRule[]; } export interface CompatibilityRule { name: string; description: string; severity: 'major' | 'minor' | 'patch'; check: (oldContract: any, newContract: any) => boolean; message?: string; } export class CompatibilityChecker { private logger: Logger; private validator: ContractValidator; private versionManager: SemanticVersionManager; constructor(logger: Logger) { this.logger = logger; this.validator = new ContractValidator(logger); this.versionManager = new SemanticVersionManager(); } /** * Check compatibility between two Pact contracts */ async checkPactCompatibility( oldContract: PactContract, newContract: PactContract, options: CompatibilityCheckOptions = {} ): Promise<CompatibilityResult> { this.logger.info('Starting Pact compatibility check', { oldConsumer: oldContract.consumer.name, oldProvider: oldContract.provider.name, newConsumer: newContract.consumer.name, newProvider: newContract.provider.name }); const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Validate both contracts first const oldValidation = this.validator.validateContract(oldContract); const newValidation = this.validator.validateContract(newContract); if (!oldValidation.isValid) { breakingChanges.push({ type: 'schema', severity: 'major', description: `Old contract validation failed: ${oldValidation.errors.join(', ')}`, path: 'contract' }); } if (!newValidation.isValid) { breakingChanges.push({ type: 'schema', severity: 'major', description: `New contract validation failed: ${newValidation.errors.join(', ')}`, path: 'contract' }); } // Check consumer/provider compatibility if (oldContract.consumer.name !== newContract.consumer.name) { warnings.push({ type: 'schema', description: 'Consumer name changed', path: 'consumer.name', recommendation: 'Ensure this is intentional' }); } if (oldContract.provider.name !== newContract.provider.name) { breakingChanges.push({ type: 'schema', severity: 'major', description: 'Provider name changed', path: 'provider.name', oldValue: oldContract.provider.name, newValue: newContract.provider.name }); } // Check interactions compatibility const interactionChanges = this.checkInteractionsCompatibility( oldContract.interactions, newContract.interactions, options ); breakingChanges.push(...interactionChanges.breakingChanges); warnings.push(...interactionChanges.warnings); // Apply custom rules if provided if (options.customRules) { const customRuleResults = this.applyCustomRules( oldContract, newContract, options.customRules ); breakingChanges.push(...customRuleResults.breakingChanges); warnings.push(...customRuleResults.warnings); } const compatibilityScore = this.calculateCompatibilityScore(breakingChanges, warnings); const result: CompatibilityResult = { isCompatible: breakingChanges.length === 0, breakingChanges, warnings, compatibilityScore }; this.logger.info('Pact compatibility check completed', { isCompatible: result.isCompatible, breakingChanges: breakingChanges.length, warnings: warnings.length, score: compatibilityScore }); return result; } /** * Check compatibility between two OpenAPI specifications */ async checkOpenAPICompatibility( oldSpec: OpenAPISpec, newSpec: OpenAPISpec, options: CompatibilityCheckOptions = {} ): Promise<CompatibilityResult> { this.logger.info('Starting OpenAPI compatibility check', { oldTitle: oldSpec.info.title, oldVersion: oldSpec.info.version, newTitle: newSpec.info.title, newVersion: newSpec.info.version }); const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Check basic info compatibility if (oldSpec.info.title !== newSpec.info.title) { warnings.push({ type: 'schema', description: 'API title changed', path: 'info.title', recommendation: 'Consider maintaining consistent naming' }); } // Check version compatibility const versionCompatibility = this.checkVersionCompatibility( oldSpec.info.version, newSpec.info.version ); if (!versionCompatibility.isCompatible) { breakingChanges.push(...versionCompatibility.breakingChanges); warnings.push(...versionCompatibility.warnings); } // Check paths compatibility const pathChanges = this.checkPathsCompatibility( oldSpec.paths, newSpec.paths, options ); breakingChanges.push(...pathChanges.breakingChanges); warnings.push(...pathChanges.warnings); // Check components compatibility if (oldSpec.components && newSpec.components) { const componentChanges = this.checkComponentsCompatibility( oldSpec.components, newSpec.components, options ); breakingChanges.push(...componentChanges.breakingChanges); warnings.push(...componentChanges.warnings); } // Check security schemes compatibility const securityChanges = this.checkSecurityCompatibility( oldSpec.security, newSpec.security, oldSpec.components?.securitySchemes, newSpec.components?.securitySchemes ); breakingChanges.push(...securityChanges.breakingChanges); warnings.push(...securityChanges.warnings); const compatibilityScore = this.calculateCompatibilityScore(breakingChanges, warnings); const result: CompatibilityResult = { isCompatible: breakingChanges.length === 0, breakingChanges, warnings, compatibilityScore }; this.logger.info('OpenAPI compatibility check completed', { isCompatible: result.isCompatible, breakingChanges: breakingChanges.length, warnings: warnings.length, score: compatibilityScore }); return result; } /** * Generate compatibility report */ generateCompatibilityReport(result: CompatibilityResult): string { const report = []; report.push('# Contract Compatibility Report'); report.push(''); report.push(`**Compatibility Status:** ${result.isCompatible ? ' Compatible' : ' Incompatible'}`); report.push(`**Compatibility Score:** ${result.compatibilityScore}%`); report.push(''); if (result.breakingChanges.length > 0) { report.push('## Breaking Changes'); report.push(''); result.breakingChanges.forEach((change, index) => { report.push(`### ${index + 1}. ${change.description}`); report.push(`- **Type:** ${change.type}`); report.push(`- **Severity:** ${change.severity}`); report.push(`- **Path:** ${change.path}`); if (change.oldValue !== undefined && change.newValue !== undefined) { report.push(`- **Old Value:** \`${JSON.stringify(change.oldValue)}\``); report.push(`- **New Value:** \`${JSON.stringify(change.newValue)}\``); } report.push(''); }); } if (result.warnings.length > 0) { report.push('## Warnings'); report.push(''); result.warnings.forEach((warning, index) => { report.push(`### ${index + 1}. ${warning.description}`); report.push(`- **Type:** ${warning.type}`); report.push(`- **Path:** ${warning.path}`); if (warning.recommendation) { report.push(`- **Recommendation:** ${warning.recommendation}`); } report.push(''); }); } if (result.isCompatible) { report.push('## Summary'); report.push(''); report.push(' The contracts are compatible. No breaking changes detected.'); if (result.warnings.length > 0) { report.push(` However, there are ${result.warnings.length} warnings that should be reviewed.`); } } else { report.push('## Summary'); report.push(''); report.push(` The contracts are incompatible due to ${result.breakingChanges.length} breaking changes.`); report.push('These changes must be addressed before the new version can be released.'); } return report.join('\n'); } private checkInteractionsCompatibility( oldInteractions: any[], newInteractions: any[], options: CompatibilityCheckOptions ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Create maps for easier comparison const oldInteractionMap = new Map(); const newInteractionMap = new Map(); oldInteractions.forEach(interaction => { const key = `${interaction.request.method}:${interaction.request.path}`; oldInteractionMap.set(key, interaction); }); newInteractions.forEach(interaction => { const key = `${interaction.request.method}:${interaction.request.path}`; newInteractionMap.set(key, interaction); }); // Check for removed interactions oldInteractionMap.forEach((oldInteraction, key) => { if (!newInteractionMap.has(key)) { breakingChanges.push({ type: 'endpoint', severity: 'major', description: `Interaction removed: ${oldInteraction.description}`, path: key, oldValue: oldInteraction }); } }); // Check for modified interactions newInteractionMap.forEach((newInteraction, key) => { const oldInteraction = oldInteractionMap.get(key); if (oldInteraction) { const interactionChanges = this.compareInteractions(oldInteraction, newInteraction, options); breakingChanges.push(...interactionChanges.breakingChanges.map(change => ({ ...change, path: `${key}.${change.path}` }))); warnings.push(...interactionChanges.warnings.map(warning => ({ ...warning, path: `${key}.${warning.path}` }))); } else { // New interaction added warnings.push({ type: 'schema', description: `New interaction added: ${newInteraction.description}`, path: key, recommendation: 'Ensure consumers can handle this new interaction' }); } }); return { breakingChanges, warnings }; } private compareInteractions( oldInteraction: any, newInteraction: any, options: CompatibilityCheckOptions ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Compare request changes const requestChanges = this.compareRequests( oldInteraction.request, newInteraction.request, options ); breakingChanges.push(...requestChanges.breakingChanges); warnings.push(...requestChanges.warnings); // Compare response changes const responseChanges = this.compareResponses( oldInteraction.response, newInteraction.response, options ); breakingChanges.push(...responseChanges.breakingChanges); warnings.push(...responseChanges.warnings); // Compare provider states if (oldInteraction.providerStates || newInteraction.providerStates) { const stateChanges = this.compareProviderStates( oldInteraction.providerStates || [], newInteraction.providerStates || [] ); breakingChanges.push(...stateChanges.breakingChanges); warnings.push(...stateChanges.warnings); } return { breakingChanges, warnings }; } private compareRequests( oldRequest: any, newRequest: any, options: CompatibilityCheckOptions ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Method and path should already be the same (used as key) // Compare headers if (this.hasNewRequiredHeaders(oldRequest.headers, newRequest.headers)) { breakingChanges.push({ type: 'request', severity: 'major', description: 'New required headers added to request', path: 'request.headers', oldValue: oldRequest.headers, newValue: newRequest.headers }); } // Compare query parameters if (this.hasNewRequiredQueryParams(oldRequest.query, newRequest.query)) { breakingChanges.push({ type: 'request', severity: 'minor', description: 'New required query parameters added', path: 'request.query', oldValue: oldRequest.query, newValue: newRequest.query }); } // Compare request body if (this.hasIncompatibleRequestBody(oldRequest.body, newRequest.body, options)) { breakingChanges.push({ type: 'request', severity: 'major', description: 'Request body structure changed incompatibly', path: 'request.body', oldValue: oldRequest.body, newValue: newRequest.body }); } return { breakingChanges, warnings }; } private compareResponses( oldResponse: any, newResponse: any, options: CompatibilityCheckOptions ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Compare status code if (oldResponse.status !== newResponse.status) { breakingChanges.push({ type: 'response', severity: 'major', description: 'Response status code changed', path: 'response.status', oldValue: oldResponse.status, newValue: newResponse.status }); } // Compare headers if (this.hasMissingResponseHeaders(oldResponse.headers, newResponse.headers)) { breakingChanges.push({ type: 'response', severity: 'minor', description: 'Response headers removed', path: 'response.headers', oldValue: oldResponse.headers, newValue: newResponse.headers }); } // Compare response body if (this.hasIncompatibleResponseBody(oldResponse.body, newResponse.body, options)) { breakingChanges.push({ type: 'response', severity: 'major', description: 'Response body structure changed incompatibly', path: 'response.body', oldValue: oldResponse.body, newValue: newResponse.body }); } return { breakingChanges, warnings }; } private compareProviderStates( oldStates: any[], newStates: any[] ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; const oldStateNames = new Set(oldStates.map(state => state.name)); const newStateNames = new Set(newStates.map(state => state.name)); // Check for removed states oldStateNames.forEach(stateName => { if (!newStateNames.has(stateName)) { breakingChanges.push({ type: 'schema', severity: 'major', description: `Provider state removed: ${stateName}`, path: 'providerStates', oldValue: stateName }); } }); // Check for new states (not breaking, but worth noting) newStateNames.forEach(stateName => { if (!oldStateNames.has(stateName)) { warnings.push({ type: 'schema', description: `New provider state added: ${stateName}`, path: 'providerStates', recommendation: 'Ensure provider can handle this new state' }); } }); return { breakingChanges, warnings }; } private checkPathsCompatibility( oldPaths: Record<string, any>, newPaths: Record<string, any>, options: CompatibilityCheckOptions ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Check for removed paths Object.keys(oldPaths).forEach(path => { if (!newPaths[path]) { breakingChanges.push({ type: 'endpoint', severity: 'major', description: `Path removed: ${path}`, path, oldValue: oldPaths[path] }); } }); // Check for modified paths Object.keys(newPaths).forEach(path => { const oldPath = oldPaths[path]; const newPath = newPaths[path]; if (oldPath) { // Compare operations within the path const pathChanges = this.comparePathOperations(oldPath, newPath, path, options); breakingChanges.push(...pathChanges.breakingChanges); warnings.push(...pathChanges.warnings); } else { // New path added warnings.push({ type: 'schema', description: `New path added: ${path}`, path, recommendation: 'Ensure clients can handle this new endpoint' }); } }); return { breakingChanges, warnings }; } private comparePathOperations( oldPath: any, newPath: any, pathName: string, options: CompatibilityCheckOptions ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; const methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace']; methods.forEach(method => { const oldOperation = oldPath[method]; const newOperation = newPath[method]; if (oldOperation && !newOperation) { breakingChanges.push({ type: 'endpoint', severity: 'major', description: `HTTP method removed: ${method.toUpperCase()} ${pathName}`, path: `${pathName}.${method}`, oldValue: oldOperation }); } else if (oldOperation && newOperation) { // Compare operations const operationChanges = this.compareOperations( oldOperation, newOperation, `${pathName}.${method}`, options ); breakingChanges.push(...operationChanges.breakingChanges); warnings.push(...operationChanges.warnings); } else if (!oldOperation && newOperation) { warnings.push({ type: 'schema', description: `New HTTP method added: ${method.toUpperCase()} ${pathName}`, path: `${pathName}.${method}`, recommendation: 'Ensure clients can handle this new method' }); } }); return { breakingChanges, warnings }; } private compareOperations( oldOperation: any, newOperation: any, operationPath: string, options: CompatibilityCheckOptions ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Compare parameters if (oldOperation.parameters && newOperation.parameters) { const paramChanges = this.compareParameters( oldOperation.parameters, newOperation.parameters, `${operationPath}.parameters` ); breakingChanges.push(...paramChanges.breakingChanges); warnings.push(...paramChanges.warnings); } else if (oldOperation.parameters && !newOperation.parameters) { breakingChanges.push({ type: 'request', severity: 'major', description: 'All parameters removed', path: `${operationPath}.parameters`, oldValue: oldOperation.parameters }); } // Compare request body if (oldOperation.requestBody && newOperation.requestBody) { const bodyChanges = this.compareRequestBodies( oldOperation.requestBody, newOperation.requestBody, `${operationPath}.requestBody` ); breakingChanges.push(...bodyChanges.breakingChanges); warnings.push(...bodyChanges.warnings); } // Compare responses const responseChanges = this.compareResponseSchemas( oldOperation.responses, newOperation.responses, `${operationPath}.responses` ); breakingChanges.push(...responseChanges.breakingChanges); warnings.push(...responseChanges.warnings); return { breakingChanges, warnings }; } private compareParameters( oldParams: any[], newParams: any[], basePath: string ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; const oldParamMap = new Map(oldParams.map(p => [`${p.name}-${p.in}`, p])); const newParamMap = new Map(newParams.map(p => [`${p.name}-${p.in}`, p])); // Check for removed parameters oldParamMap.forEach((oldParam, key) => { if (!newParamMap.has(key)) { const severity = oldParam.required ? 'major' : 'minor'; breakingChanges.push({ type: 'request', severity, description: `Parameter removed: ${oldParam.name} (${oldParam.in})`, path: `${basePath}.${key}`, oldValue: oldParam }); } }); // Check for new required parameters newParamMap.forEach((newParam, key) => { const oldParam = oldParamMap.get(key); if (!oldParam && newParam.required) { breakingChanges.push({ type: 'request', severity: 'major', description: `New required parameter added: ${newParam.name} (${newParam.in})`, path: `${basePath}.${key}`, newValue: newParam }); } else if (oldParam && !oldParam.required && newParam.required) { breakingChanges.push({ type: 'request', severity: 'major', description: `Parameter became required: ${newParam.name} (${newParam.in})`, path: `${basePath}.${key}`, oldValue: oldParam, newValue: newParam }); } }); return { breakingChanges, warnings }; } private compareRequestBodies( oldBody: any, newBody: any, basePath: string ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Compare required status if (!oldBody.required && newBody.required) { breakingChanges.push({ type: 'request', severity: 'major', description: 'Request body became required', path: `${basePath}.required`, oldValue: oldBody.required, newValue: newBody.required }); } // Compare content types const oldContentTypes = Object.keys(oldBody.content || {}); const newContentTypes = Object.keys(newBody.content || {}); oldContentTypes.forEach(contentType => { if (!newContentTypes.includes(contentType)) { breakingChanges.push({ type: 'request', severity: 'major', description: `Content type removed: ${contentType}`, path: `${basePath}.content.${contentType}`, oldValue: oldBody.content[contentType] }); } }); return { breakingChanges, warnings }; } private compareResponseSchemas( oldResponses: any, newResponses: any, basePath: string ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Check for removed response status codes Object.keys(oldResponses).forEach(statusCode => { if (!newResponses[statusCode]) { breakingChanges.push({ type: 'response', severity: 'major', description: `Response status code removed: ${statusCode}`, path: `${basePath}.${statusCode}`, oldValue: oldResponses[statusCode] }); } }); // Check for modified response schemas Object.keys(newResponses).forEach(statusCode => { const oldResponse = oldResponses[statusCode]; const newResponse = newResponses[statusCode]; if (oldResponse && newResponse) { // Compare response content if (oldResponse.content && newResponse.content) { const contentChanges = this.compareResponseContent( oldResponse.content, newResponse.content, `${basePath}.${statusCode}.content` ); breakingChanges.push(...contentChanges.breakingChanges); warnings.push(...contentChanges.warnings); } } }); return { breakingChanges, warnings }; } private compareResponseContent( oldContent: any, newContent: any, basePath: string ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Check for removed content types Object.keys(oldContent).forEach(contentType => { if (!newContent[contentType]) { breakingChanges.push({ type: 'response', severity: 'major', description: `Response content type removed: ${contentType}`, path: `${basePath}.${contentType}`, oldValue: oldContent[contentType] }); } }); return { breakingChanges, warnings }; } private checkComponentsCompatibility( oldComponents: any, newComponents: any, options: CompatibilityCheckOptions ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Check schemas if (oldComponents.schemas && newComponents.schemas) { const schemaChanges = this.compareSchemas( oldComponents.schemas, newComponents.schemas, 'components.schemas' ); breakingChanges.push(...schemaChanges.breakingChanges); warnings.push(...schemaChanges.warnings); } return { breakingChanges, warnings }; } private compareSchemas( oldSchemas: any, newSchemas: any, basePath: string ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Check for removed schemas Object.keys(oldSchemas).forEach(schemaName => { if (!newSchemas[schemaName]) { breakingChanges.push({ type: 'schema', severity: 'major', description: `Schema removed: ${schemaName}`, path: `${basePath}.${schemaName}`, oldValue: oldSchemas[schemaName] }); } }); // Check for modified schemas Object.keys(newSchemas).forEach(schemaName => { const oldSchema = oldSchemas[schemaName]; const newSchema = newSchemas[schemaName]; if (oldSchema && newSchema) { const schemaChanges = this.compareIndividualSchema( oldSchema, newSchema, `${basePath}.${schemaName}` ); breakingChanges.push(...schemaChanges.breakingChanges); warnings.push(...schemaChanges.warnings); } }); return { breakingChanges, warnings }; } private compareIndividualSchema( oldSchema: any, newSchema: any, basePath: string ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Check required properties const oldRequired = oldSchema.required || []; const newRequired = newSchema.required || []; // New required properties are breaking newRequired.forEach((prop: string) => { if (!oldRequired.includes(prop)) { breakingChanges.push({ type: 'schema', severity: 'major', description: `Property became required: ${prop}`, path: `${basePath}.required`, oldValue: oldRequired, newValue: newRequired }); } }); // Check for removed properties if (oldSchema.properties && newSchema.properties) { Object.keys(oldSchema.properties).forEach(prop => { if (!newSchema.properties[prop]) { breakingChanges.push({ type: 'schema', severity: 'major', description: `Property removed: ${prop}`, path: `${basePath}.properties.${prop}`, oldValue: oldSchema.properties[prop] }); } }); } return { breakingChanges, warnings }; } private checkSecurityCompatibility( oldSecurity: any, newSecurity: any, oldSchemes: any, newSchemes: any ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; // Basic security scheme comparison if (oldSecurity && !newSecurity) { breakingChanges.push({ type: 'schema', severity: 'major', description: 'Security requirements removed', path: 'security', oldValue: oldSecurity }); } else if (!oldSecurity && newSecurity) { breakingChanges.push({ type: 'schema', severity: 'major', description: 'Security requirements added', path: 'security', newValue: newSecurity }); } return { breakingChanges, warnings }; } private checkVersionCompatibility( oldVersion: string, newVersion: string ): { isCompatible: boolean; breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; try { const comparison = this.versionManager.compareVersions(oldVersion, newVersion); if (comparison === 0) { // Same version warnings.push({ type: 'schema', description: 'Version unchanged', path: 'info.version', recommendation: 'Consider bumping version for new changes' }); } else if (comparison > 0) { // New version is lower than old version breakingChanges.push({ type: 'schema', severity: 'major', description: 'Version downgrade detected', path: 'info.version', oldValue: oldVersion, newValue: newVersion }); } } catch (error) { warnings.push({ type: 'schema', description: 'Invalid version format', path: 'info.version', recommendation: 'Use semantic versioning format' }); } return { isCompatible: breakingChanges.length === 0, breakingChanges, warnings }; } private applyCustomRules( oldContract: any, newContract: any, customRules: CompatibilityRule[] ): { breakingChanges: BreakingChange[]; warnings: Warning[] } { const breakingChanges: BreakingChange[] = []; const warnings: Warning[] = []; customRules.forEach(rule => { try { const ruleResult = rule.check(oldContract, newContract); if (!ruleResult) { const change: BreakingChange = { type: 'schema', severity: rule.severity, description: rule.message || rule.description, path: rule.name }; if (rule.severity === 'major' || rule.severity === 'minor') { breakingChanges.push(change); } else { warnings.push({ type: 'schema', description: change.description, path: change.path, recommendation: `Custom rule: ${rule.name}` }); } } } catch (error) { warnings.push({ type: 'schema', description: `Custom rule execution failed: ${rule.name}`, path: rule.name, recommendation: 'Check custom rule implementation' }); } }); return { breakingChanges, warnings }; } private calculateCompatibilityScore( breakingChanges: BreakingChange[], warnings: Warning[] ): number { let score = 100; // Deduct points for breaking changes breakingChanges.forEach(change => { switch (change.severity) { case 'major': score -= 25; break; case 'minor': score -= 10; break; case 'patch': score -= 5; break; } }); // Deduct points for warnings warnings.forEach(() => { score -= 2; }); return Math.max(0, score); } // Helper methods for specific compatibility checks private hasNewRequiredHeaders(oldHeaders: any, newHeaders: any): boolean { if (!newHeaders) return false; if (!oldHeaders) return Object.keys(newHeaders).length > 0; const oldHeaderNames = Object.keys(oldHeaders); const newHeaderNames = Object.keys(newHeaders); return newHeaderNames.some(name => !oldHeaderNames.includes(name)); } private hasNewRequiredQueryParams(oldQuery: any, newQuery: any): boolean { if (!newQuery) return false; if (!oldQuery) return Object.keys(newQuery).length > 0; const oldQueryNames = Object.keys(oldQuery); const newQueryNames = Object.keys(newQuery); return newQueryNames.some(name => !oldQueryNames.includes(name)); } private hasIncompatibleRequestBody( oldBody: any, newBody: any, options: CompatibilityCheckOptions ): boolean { if (!oldBody && !newBody) return false; if (!oldBody && newBody) return true; if (oldBody && !newBody) return true; // Simple structural comparison - in practice, this would be more sophisticated return JSON.stringify(oldBody) !== JSON.stringify(newBody); } private hasIncompatibleResponseBody( oldBody: any, newBody: any, options: CompatibilityCheckOptions ): boolean { if (!oldBody && !newBody) return false; if (oldBody && !newBody) return true; // Response body changes are generally less strict than request body changes // New fields can be added, but existing fields shouldn't be removed return false; // Simplified for now } private hasMissingResponseHeaders(oldHeaders: any, newHeaders: any): boolean { if (!oldHeaders) return false; if (!newHeaders) return true; const oldHeaderNames = Object.keys(oldHeaders); const newHeaderNames = Object.keys(newHeaders); return oldHeaderNames.some(name => !newHeaderNames.includes(name)); } }