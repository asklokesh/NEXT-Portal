/** * Enterprise Database Connection Manager * * Features: * - Connection pooling with circuit breaker pattern * - Automatic retry logic with exponential backoff * - Health monitoring and metrics collection * - Read/Write replica support * - Connection pooling for high concurrency * - Graceful degradation and fallback mechanisms */ import { PrismaClient } from '@prisma/client'; import { createPool, Pool } from 'generic-pool'; import { EventEmitter } from 'events'; interface DatabaseConfig { url: string; poolMin?: number; poolMax?: number; acquireTimeoutMillis?: number; idleTimeoutMillis?: number; reapIntervalMillis?: number; maxRetries?: number; retryDelay?: number; healthCheckInterval?: number; slowQueryThreshold?: number; enableLogging?: boolean; enableMetrics?: boolean; } interface ConnectionMetrics { totalConnections: number; activeConnections: number; idleConnections: number; waitingConnections: number; totalQueries: number; failedQueries: number; slowQueries: number; averageQueryTime: number; connectionErrors: number; lastHealthCheck: Date; isHealthy: boolean; } class CircuitBreaker { private failures = 0; private nextAttempt = 0; private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED'; constructor( private failureThreshold = 5, private timeout = 60000 // 1 minute ) {} async call<T>(fn: () => Promise<T>): Promise<T> { if (this.state === 'OPEN') { if (Date.now() < this.nextAttempt) { throw new Error('Circuit breaker is OPEN'); } this.state = 'HALF_OPEN'; } try { const result = await fn(); this.onSuccess(); return result; } catch (error) { this.onFailure(); throw error; } } private onSuccess() { this.failures = 0; this.state = 'CLOSED'; } private onFailure() { this.failures++; if (this.failures >= this.failureThreshold) { this.state = 'OPEN'; this.nextAttempt = Date.now() + this.timeout; } } getState() { return { state: this.state, failures: this.failures, nextAttempt: this.nextAttempt }; } } export class DatabaseConnectionManager extends EventEmitter { private pool: Pool<PrismaClient>; private readPool?: Pool<PrismaClient>; private circuitBreaker: CircuitBreaker; private metrics: ConnectionMetrics; private healthCheckInterval: NodeJS.Timeout | null = null; private config: Required<DatabaseConfig>; constructor(config: DatabaseConfig) { super(); this.config = { poolMin: 10, poolMax: 50, acquireTimeoutMillis: 30000, idleTimeoutMillis: 300000, // 5 minutes reapIntervalMillis: 10000, // 10 seconds maxRetries: 3, retryDelay: 1000, healthCheckInterval: 30000, // 30 seconds slowQueryThreshold: 1000, // 1 second enableLogging: process.env.NODE_ENV !== 'production', enableMetrics: true, ...config }; this.circuitBreaker = new CircuitBreaker(5, 60000); this.metrics = this.initializeMetrics(); this.initializePool(); this.startHealthCheck(); } private initializeMetrics(): ConnectionMetrics { return { totalConnections: 0, activeConnections: 0, idleConnections: 0, waitingConnections: 0, totalQueries: 0, failedQueries: 0, slowQueries: 0, averageQueryTime: 0, connectionErrors: 0, lastHealthCheck: new Date(), isHealthy: true }; } private initializePool() { const factory = { create: async (): Promise<PrismaClient> => { const client = new PrismaClient({ datasources: { db: { url: this.config.url } }, log: this.config.enableLogging ? ['query', 'info', 'warn', 'error'] : ['error'] }); await client.$connect(); this.metrics.totalConnections++; if (this.config.enableLogging) { console.log(' Database connection established'); } return client; }, destroy: async (client: PrismaClient): Promise<void> => { await client.$disconnect(); this.metrics.totalConnections--; } }; this.pool = createPool(factory, { min: this.config.poolMin, max: this.config.poolMax, acquireTimeoutMillis: this.config.acquireTimeoutMillis, idleTimeoutMillis: this.config.idleTimeoutMillis, reapIntervalMillis: this.config.reapIntervalMillis }); this.pool.on('factoryCreateError', (err) => { this.metrics.connectionErrors++; this.emit('connectionError', err); console.error(' Database connection factory error:', err); }); this.pool.on('factoryDestroyError', (err) => { this.emit('connectionError', err); console.error(' Database connection destroy error:', err); }); // Initialize read replica pool if configured const readReplicaUrl = process.env.DATABASE_READ_URL; if (readReplicaUrl) { this.initializeReadPool(readReplicaUrl); } } private initializeReadPool(readUrl: string) { const readFactory = { create: async (): Promise<PrismaClient> => { const client = new PrismaClient({ datasources: { db: { url: readUrl } }, log: this.config.enableLogging ? ['query', 'info', 'warn', 'error'] : ['error'] }); await client.$connect(); return client; }, destroy: async (client: PrismaClient): Promise<void> => { await client.$disconnect(); } }; this.readPool = createPool(readFactory, { min: Math.ceil(this.config.poolMin / 2), max: Math.ceil(this.config.poolMax / 2), acquireTimeoutMillis: this.config.acquireTimeoutMillis, idleTimeoutMillis: this.config.idleTimeoutMillis, reapIntervalMillis: this.config.reapIntervalMillis }); console.log(' Read replica pool initialized'); } async getConnection(readonly = false): Promise<PrismaClient> { const targetPool = readonly && this.readPool ? this.readPool : this.pool; return await this.circuitBreaker.call(async () => { return await this.retryOperation(async () => { const client = await targetPool.acquire(); this.updatePoolMetrics(); return client; }); }); } async releaseConnection(client: PrismaClient, readonly = false): Promise<void> { const targetPool = readonly && this.readPool ? this.readPool : this.pool; await targetPool.release(client); this.updatePoolMetrics(); } async executeQuery<T>( queryFn: (client: PrismaClient) => Promise<T>, readonly = false ): Promise<T> { const startTime = Date.now(); const client = await this.getConnection(readonly); try { const result = await queryFn(client); const duration = Date.now() - startTime; this.updateQueryMetrics(duration, false); if (duration > this.config.slowQueryThreshold) { this.metrics.slowQueries++; this.emit('slowQuery', { duration, query: queryFn.toString() }); } return result; } catch (error) { this.metrics.failedQueries++; this.emit('queryError', error); throw error; } finally { await this.releaseConnection(client, readonly); } } private async retryOperation<T>(operation: () => Promise<T>): Promise<T> { let lastError: Error; for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) { try { return await operation(); } catch (error) { lastError = error as Error; if (attempt === this.config.maxRetries) { break; } const delay = this.config.retryDelay * Math.pow(2, attempt - 1); // Exponential backoff console.warn(`Database operation failed, retrying in ${delay}ms (attempt ${attempt}/${this.config.maxRetries})`); await new Promise(resolve => setTimeout(resolve, delay)); } } throw lastError!; } private updatePoolMetrics() { if (!this.config.enableMetrics) return; this.metrics.activeConnections = this.pool.borrowed; this.metrics.idleConnections = this.pool.available; this.metrics.waitingConnections = this.pool.pending; } private updateQueryMetrics(duration: number, failed: boolean) { if (!this.config.enableMetrics) return; this.metrics.totalQueries++; if (failed) { this.metrics.failedQueries++; } // Update rolling average const totalTime = this.metrics.averageQueryTime * (this.metrics.totalQueries - 1) + duration; this.metrics.averageQueryTime = totalTime / this.metrics.totalQueries; } private startHealthCheck() { if (this.healthCheckInterval) { clearInterval(this.healthCheckInterval); } this.healthCheckInterval = setInterval(async () => { await this.performHealthCheck(); }, this.config.healthCheckInterval); // Initial health check this.performHealthCheck(); } private async performHealthCheck(): Promise<boolean> { try { const isHealthy = await this.executeQuery(async (client) => { const result = await client.$queryRaw`SELECT 1 as health_check`; return Array.isArray(result) && result.length > 0; }); this.metrics.isHealthy = isHealthy; this.metrics.lastHealthCheck = new Date(); if (isHealthy) { this.emit('healthCheckPassed'); } else { this.emit('healthCheckFailed'); } return isHealthy; } catch (error) { this.metrics.isHealthy = false; this.metrics.lastHealthCheck = new Date(); this.emit('healthCheckError', error); console.error(' Database health check failed:', error); return false; } } getMetrics(): ConnectionMetrics { this.updatePoolMetrics(); return { ...this.metrics }; } getCircuitBreakerState() { return this.circuitBreaker.getState(); } async close(): Promise<void> { if (this.healthCheckInterval) { clearInterval(this.healthCheckInterval); } await this.pool.drain(); await this.pool.clear(); if (this.readPool) { await this.readPool.drain(); await this.readPool.clear(); } console.log(' Database connections closed gracefully'); } } // Singleton instance let dbManager: DatabaseConnectionManager; export function getDatabaseManager(): DatabaseConnectionManager { if (!dbManager) { const config: DatabaseConfig = { url: process.env.DATABASE_URL!, poolMin: parseInt(process.env.DB_POOL_MIN || '10'), poolMax: parseInt(process.env.DB_POOL_MAX || '50'), acquireTimeoutMillis: parseInt(process.env.DB_ACQUIRE_TIMEOUT || '30000'), idleTimeoutMillis: parseInt(process.env.DB_IDLE_TIMEOUT || '300000'), maxRetries: parseInt(process.env.DB_MAX_RETRIES || '3'), retryDelay: parseInt(process.env.DB_RETRY_DELAY || '1000'), healthCheckInterval: parseInt(process.env.DB_HEALTH_CHECK_INTERVAL || '30000'), slowQueryThreshold: parseInt(process.env.DB_SLOW_QUERY_THRESHOLD || '1000'), enableLogging: process.env.DB_ENABLE_LOGGING === 'true', enableMetrics: process.env.DB_ENABLE_METRICS !== 'false' }; dbManager = new DatabaseConnectionManager(config); } return dbManager; } // Graceful shutdown handling process.on('SIGTERM', async () => { if (dbManager) { await dbManager.close(); } }); process.on('SIGINT', async () => { if (dbManager) { await dbManager.close(); } });