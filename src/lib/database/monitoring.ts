/** * Database Monitoring and Health Check System * * Features: * - Real-time performance monitoring * - Health status tracking * - Alert generation for issues * - Performance metrics collection * - Database diagnostics */ import { EventEmitter } from 'events'; import { getDatabaseManager } from './connection'; import type { ConnectionMetrics } from './connection'; export interface DatabaseHealth { status: 'healthy' | 'degraded' | 'unhealthy'; uptime: number; lastCheck: Date; responseTime: number; connections: ConnectionMetrics; queries: { averageTime: number; slowQueries: number; failedQueries: number; totalQueries: number; }; alerts: Alert[]; issues: Issue[]; } export interface Alert { id: string; type: 'performance' | 'connection' | 'error' | 'capacity'; severity: 'low' | 'medium' | 'high' | 'critical'; message: string; timestamp: Date; acknowledged: boolean; resolvedAt?: Date; metadata?: Record<string, any>; } export interface Issue { id: string; category: string; description: string; severity: 'low' | 'medium' | 'high' | 'critical'; timestamp: Date; resolved: boolean; recommendations: string[]; } export interface PerformanceMetrics { timestamp: Date; queryCount: number; averageQueryTime: number; slowQueries: number; connectionUtilization: number; memoryUsage?: number; cpuUsage?: number; } export class DatabaseMonitor extends EventEmitter { private dbManager = getDatabaseManager(); private alerts: Map<string, Alert> = new Map(); private issues: Map<string, Issue> = new Map(); private performanceHistory: PerformanceMetrics[] = []; private startTime = Date.now(); private monitoringInterval: NodeJS.Timeout | null = null; private isMonitoring = false; constructor( private config = { checkInterval: 30000, // 30 seconds maxPerformanceHistory: 1000, alertThresholds: { slowQueryTime: 2000, // 2 seconds highConnectionUsage: 0.8, // 80% highFailureRate: 0.05, // 5% responseTimeThreshold: 1000 // 1 second } } ) { super(); } start(): void { if (this.isMonitoring) return; this.isMonitoring = true; this.monitoringInterval = setInterval(() => { this.performHealthCheck(); }, this.config.checkInterval); // Listen to database manager events this.dbManager.on('healthCheckFailed', () => { this.createAlert({ type: 'connection', severity: 'critical', message: 'Database health check failed', metadata: { source: 'healthCheck' } }); }); this.dbManager.on('connectionError', (error) => { this.createAlert({ type: 'connection', severity: 'high', message: `Database connection error: ${error.message}`, metadata: { error: error.message, source: 'connection' } }); }); this.dbManager.on('slowQuery', ({ duration, query }) => { this.createAlert({ type: 'performance', severity: 'medium', message: `Slow query detected: ${duration}ms`, metadata: { duration, query, source: 'slowQuery' } }); }); console.log(' Database monitoring started'); } stop(): void { if (!this.isMonitoring) return; this.isMonitoring = false; if (this.monitoringInterval) { clearInterval(this.monitoringInterval); } console.log(' Database monitoring stopped'); } private async performHealthCheck(): Promise<void> { const startTime = Date.now(); try { const metrics = this.dbManager.getMetrics(); const responseTime = Date.now() - startTime; // Record performance metrics const performanceMetric: PerformanceMetrics = { timestamp: new Date(), queryCount: metrics.totalQueries, averageQueryTime: metrics.averageQueryTime, slowQueries: metrics.slowQueries, connectionUtilization: metrics.activeConnections / (metrics.activeConnections + metrics.idleConnections), }; this.addPerformanceMetric(performanceMetric); // Check for issues this.checkPerformanceIssues(metrics, responseTime); this.checkConnectionIssues(metrics); this.checkCapacityIssues(metrics); this.emit('healthCheck', { status: this.getOverallHealthStatus(), metrics, responseTime, issues: Array.from(this.issues.values()), alerts: Array.from(this.alerts.values()) }); } catch (error) { this.createAlert({ type: 'error', severity: 'critical', message: `Health check failed: ${(error as Error).message}`, metadata: { error: (error as Error).message } }); } } private checkPerformanceIssues(metrics: ConnectionMetrics, responseTime: number): void { // Check response time if (responseTime > this.config.alertThresholds.responseTimeThreshold) { this.createIssue({ category: 'performance', description: `High database response time: ${responseTime}ms`, severity: responseTime > 5000 ? 'critical' : 'high', recommendations: [ 'Check for long-running queries', 'Consider connection pooling optimization', 'Review database indexing strategy' ] }); } // Check average query time if (metrics.averageQueryTime > this.config.alertThresholds.slowQueryTime) { this.createIssue({ category: 'performance', description: `High average query time: ${metrics.averageQueryTime}ms`, severity: metrics.averageQueryTime > 5000 ? 'critical' : 'medium', recommendations: [ 'Analyze slow query logs', 'Optimize database queries', 'Add missing database indexes' ] }); } // Check failure rate const failureRate = metrics.totalQueries > 0 ? metrics.failedQueries / metrics.totalQueries : 0; if (failureRate > this.config.alertThresholds.highFailureRate) { this.createIssue({ category: 'reliability', description: `High query failure rate: ${(failureRate * 100).toFixed(2)}%`, severity: failureRate > 0.1 ? 'critical' : 'high', recommendations: [ 'Check database error logs', 'Review connection stability', 'Investigate query patterns' ] }); } } private checkConnectionIssues(metrics: ConnectionMetrics): void { const totalConnections = metrics.activeConnections + metrics.idleConnections; const maxConnections = 50; // From config const connectionUtilization = totalConnections / maxConnections; if (connectionUtilization > this.config.alertThresholds.highConnectionUsage) { this.createIssue({ category: 'capacity', description: `High connection pool utilization: ${(connectionUtilization * 100).toFixed(1)}%`, severity: connectionUtilization > 0.95 ? 'critical' : 'high', recommendations: [ 'Increase connection pool size', 'Optimize connection usage patterns', 'Check for connection leaks' ] }); } // Check for too many waiting connections if (metrics.waitingConnections > 10) { this.createIssue({ category: 'capacity', description: `High number of waiting connections: ${metrics.waitingConnections}`, severity: metrics.waitingConnections > 20 ? 'critical' : 'medium', recommendations: [ 'Increase connection pool size', 'Optimize query performance', 'Consider read replicas' ] }); } } private checkCapacityIssues(metrics: ConnectionMetrics): void { // Check if we're approaching connection limits const activeRatio = metrics.activeConnections / (metrics.activeConnections + metrics.idleConnections); if (activeRatio > 0.8) { this.createAlert({ type: 'capacity', severity: 'medium', message: `High active connection ratio: ${(activeRatio * 100).toFixed(1)}%`, metadata: { activeConnections: metrics.activeConnections, totalConnections: metrics.activeConnections + metrics.idleConnections } }); } } private createAlert(alertData: Omit<Alert, 'id' | 'timestamp' | 'acknowledged'>): Alert { const alert: Alert = { id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, timestamp: new Date(), acknowledged: false, ...alertData }; this.alerts.set(alert.id, alert); this.emit('alert', alert); // Auto-acknowledge low severity alerts after 5 minutes if (alert.severity === 'low') { setTimeout(() => { this.acknowledgeAlert(alert.id); }, 5 * 60 * 1000); } return alert; } private createIssue(issueData: Omit<Issue, 'id' | 'timestamp' | 'resolved'>): Issue { const issueKey = `${issueData.category}_${issueData.description}`; // Don't create duplicate issues const existingIssue = Array.from(this.issues.values()).find( issue => issue.category === issueData.category && issue.description === issueData.description && !issue.resolved ); if (existingIssue) { return existingIssue; } const issue: Issue = { id: `issue_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, timestamp: new Date(), resolved: false, ...issueData }; this.issues.set(issue.id, issue); this.emit('issue', issue); return issue; } private addPerformanceMetric(metric: PerformanceMetrics): void { this.performanceHistory.push(metric); // Keep only the last N metrics if (this.performanceHistory.length > this.config.maxPerformanceHistory) { this.performanceHistory.shift(); } } private getOverallHealthStatus(): 'healthy' | 'degraded' | 'unhealthy' { const criticalAlerts = Array.from(this.alerts.values()).filter( alert => alert.severity === 'critical' && !alert.acknowledged ); const criticalIssues = Array.from(this.issues.values()).filter( issue => issue.severity === 'critical' && !issue.resolved ); if (criticalAlerts.length > 0 || criticalIssues.length > 0) { return 'unhealthy'; } const highSeverityItems = [ ...Array.from(this.alerts.values()).filter(alert => alert.severity === 'high' && !alert.acknowledged), ...Array.from(this.issues.values()).filter(issue => issue.severity === 'high' && !issue.resolved) ]; if (highSeverityItems.length > 0) { return 'degraded'; } return 'healthy'; } // Public methods getHealthStatus(): DatabaseHealth { const metrics = this.dbManager.getMetrics(); return { status: this.getOverallHealthStatus(), uptime: Date.now() - this.startTime, lastCheck: metrics.lastHealthCheck, responseTime: metrics.averageQueryTime, connections: metrics, queries: { averageTime: metrics.averageQueryTime, slowQueries: metrics.slowQueries, failedQueries: metrics.failedQueries, totalQueries: metrics.totalQueries }, alerts: Array.from(this.alerts.values()).filter(alert => !alert.acknowledged), issues: Array.from(this.issues.values()).filter(issue => !issue.resolved) }; } getPerformanceHistory(limit?: number): PerformanceMetrics[] { const history = [...this.performanceHistory]; return limit ? history.slice(-limit) : history; } acknowledgeAlert(alertId: string): boolean { const alert = this.alerts.get(alertId); if (alert) { alert.acknowledged = true; this.emit('alertAcknowledged', alert); return true; } return false; } resolveIssue(issueId: string): boolean { const issue = this.issues.get(issueId); if (issue) { issue.resolved = true; this.emit('issueResolved', issue); return true; } return false; } getAlerts(severity?: Alert['severity']): Alert[] { const alerts = Array.from(this.alerts.values()); return severity ? alerts.filter(alert => alert.severity === severity) : alerts; } getIssues(category?: string): Issue[] { const issues = Array.from(this.issues.values()); return category ? issues.filter(issue => issue.category === category) : issues; } // Diagnostic methods async runDiagnostics(): Promise<{ connectionTest: boolean; queryPerformance: number; indexUsage: any[]; tableStats: any[]; lockInfo: any[]; recommendations: string[]; }> { const diagnostics = { connectionTest: false, queryPerformance: 0, indexUsage: [] as any[], tableStats: [] as any[], lockInfo: [] as any[], recommendations: [] as string[] }; try { // Test connection const startTime = Date.now(); await this.dbManager.executeQuery(async (client) => { await client.$queryRaw`SELECT 1`; }); diagnostics.connectionTest = true; diagnostics.queryPerformance = Date.now() - startTime; // Get table statistics diagnostics.tableStats = await this.dbManager.executeQuery(async (client) => { return await client.$queryRaw` SELECT schemaname, tablename, attname, n_distinct, correlation FROM pg_stats WHERE schemaname = 'public' ORDER BY tablename `; }, true); // Get index usage diagnostics.indexUsage = await this.dbManager.executeQuery(async (client) => { return await client.$queryRaw` SELECT t.tablename, indexname, c.reltuples AS num_rows, pg_size_pretty(pg_relation_size(indexrelid)) AS index_size, idx_scan as index_scans, idx_tup_read as tuples_read, idx_tup_fetch as tuples_fetched FROM pg_tables t LEFT OUTER JOIN pg_class c ON c.relname=t.tablename LEFT OUTER JOIN pg_indexes i ON i.tablename=t.tablename LEFT OUTER JOIN pg_stat_user_indexes psui ON psui.indexrelname=i.indexname WHERE t.schemaname='public' ORDER BY pg_relation_size(indexrelid) DESC `; }, true); // Generate recommendations if (diagnostics.queryPerformance > 100) { diagnostics.recommendations.push('Consider optimizing slow queries'); } if (diagnostics.indexUsage.some((idx: any) => idx.index_scans === 0)) { diagnostics.recommendations.push('Review unused indexes'); } } catch (error) { console.error('Diagnostics failed:', error); diagnostics.recommendations.push('Database connection issues detected'); } return diagnostics; } } // Export singleton instance export const databaseMonitor = new DatabaseMonitor();