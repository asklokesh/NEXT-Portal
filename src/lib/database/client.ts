/** * Enterprise Prisma Client Wrapper * * Features: * - Automatic connection management * - Query performance monitoring * - Transaction management with retry * - Read/Write splitting * - Audit logging integration * - Error handling and recovery */ import { PrismaClient, Prisma } from '@prisma/client'; import { getDatabaseManager } from './connection'; import { AuditLogger } from './audit'; export interface QueryOptions { readonly?: boolean; timeout?: number; retries?: number; auditLog?: boolean; userId?: string; metadata?: Record<string, any>; } export interface TransactionOptions { maxWait?: number; timeout?: number; isolationLevel?: Prisma.TransactionIsolationLevel; } class PrismaClientWrapper { private dbManager = getDatabaseManager(); private auditLogger = new AuditLogger(); async findMany<T extends keyof PrismaClient>( model: T, args?: any, options: QueryOptions = {} ): Promise<any> { return this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.findMany(args); }, { ...options, readonly: true } ); } async findUnique<T extends keyof PrismaClient>( model: T, args?: any, options: QueryOptions = {} ): Promise<any> { return this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.findUnique(args); }, { ...options, readonly: true } ); } async findFirst<T extends keyof PrismaClient>( model: T, args?: any, options: QueryOptions = {} ): Promise<any> { return this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.findFirst(args); }, { ...options, readonly: true } ); } async create<T extends keyof PrismaClient>( model: T, args: any, options: QueryOptions = {} ): Promise<any> { const result = await this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.create(args); }, { ...options, readonly: false } ); if (options.auditLog) { await this.auditLogger.logCreate(model as string, result, options); } return result; } async update<T extends keyof PrismaClient>( model: T, args: any, options: QueryOptions = {} ): Promise<any> { const result = await this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.update(args); }, { ...options, readonly: false } ); if (options.auditLog) { await this.auditLogger.logUpdate(model as string, result, options); } return result; } async upsert<T extends keyof PrismaClient>( model: T, args: any, options: QueryOptions = {} ): Promise<any> { const result = await this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.upsert(args); }, { ...options, readonly: false } ); if (options.auditLog) { await this.auditLogger.logUpsert(model as string, result, options); } return result; } async delete<T extends keyof PrismaClient>( model: T, args: any, options: QueryOptions = {} ): Promise<any> { const result = await this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.delete(args); }, { ...options, readonly: false } ); if (options.auditLog) { await this.auditLogger.logDelete(model as string, result, options); } return result; } async deleteMany<T extends keyof PrismaClient>( model: T, args?: any, options: QueryOptions = {} ): Promise<any> { const result = await this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.deleteMany(args); }, { ...options, readonly: false } ); if (options.auditLog) { await this.auditLogger.logDeleteMany(model as string, result, options); } return result; } async count<T extends keyof PrismaClient>( model: T, args?: any, options: QueryOptions = {} ): Promise<number> { return this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.count(args); }, { ...options, readonly: true } ); } async aggregate<T extends keyof PrismaClient>( model: T, args: any, options: QueryOptions = {} ): Promise<any> { return this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.aggregate(args); }, { ...options, readonly: true } ); } async groupBy<T extends keyof PrismaClient>( model: T, args: any, options: QueryOptions = {} ): Promise<any> { return this.executeQuery( async (client) => { const modelDelegate = client[model] as any; return await modelDelegate.groupBy(args); }, { ...options, readonly: true } ); } async executeRawQuery<T = any>( query: string | Prisma.Sql, options: QueryOptions = {} ): Promise<T> { return this.executeQuery( async (client) => { if (typeof query === 'string') { return await client.$queryRawUnsafe(query); } else { return await client.$queryRaw(query); } }, options ); } async executeRawCommand( command: string | Prisma.Sql, options: QueryOptions = {} ): Promise<number> { return this.executeQuery( async (client) => { if (typeof command === 'string') { return await client.$executeRawUnsafe(command); } else { return await client.$executeRaw(command); } }, { ...options, readonly: false } ); } async transaction<T>( fn: (client: PrismaClient) => Promise<T>, options: TransactionOptions = {} ): Promise<T> { return this.executeQuery( async (client) => { return await client.$transaction( async (tx) => await fn(tx), { maxWait: options.maxWait || 5000, timeout: options.timeout || 30000, isolationLevel: options.isolationLevel } ); }, { readonly: false } ); } async batchTransaction(operations: Array<() => Promise<any>>): Promise<any[]> { return this.executeQuery( async (client) => { return await client.$transaction( operations.map(op => op()) ); }, { readonly: false } ); } private async executeQuery<T>( queryFn: (client: PrismaClient) => Promise<T>, options: QueryOptions = {} ): Promise<T> { const startTime = Date.now(); try { const result = await this.dbManager.executeQuery(queryFn, options.readonly); if (process.env.NODE_ENV === 'development') { const duration = Date.now() - startTime; console.log(` Query executed in ${duration}ms`); } return result; } catch (error) { console.error(' Database query failed:', error); // Log error for monitoring this.dbManager.emit('queryError', { error, duration: Date.now() - startTime, options }); throw error; } } // Health check method async healthCheck(): Promise<boolean> { try { await this.executeQuery( async (client) => await client.$queryRaw`SELECT 1`, { readonly: true } ); return true; } catch (error) { console.error('Database health check failed:', error); return false; } } // Get connection metrics getMetrics() { return this.dbManager.getMetrics(); } // Get circuit breaker state getCircuitBreakerState() { return this.dbManager.getCircuitBreakerState(); } // Graceful shutdown async close() { await this.dbManager.close(); } } // Export singleton instance export const db = new PrismaClientWrapper(); export { PrismaClientWrapper };