/** * Quality Gates for CI/CD Pipelines * Implements comprehensive quality checks and gates */ export interface QualityGateConfig { // Code Quality codeCoverage?: { threshold: number; excludePaths?: string[]; perFile?: boolean; }; // Code Duplication duplicateCode?: { threshold: number; minTokens?: number; excludePaths?: string[]; }; // Complexity Metrics complexity?: { cyclomatic?: number; cognitive?: number; maxMethodLength?: number; maxFileLength?: number; }; // Maintainability maintainability?: { index?: number; technicalDebt?: number; codeSmells?: number; }; // Security security?: { vulnerabilities?: { critical: number; high: number; medium: number; low: number; }; hotspots?: number; }; // Performance performance?: { buildTime?: number; bundleSize?: number; loadTime?: number; memoryUsage?: number; }; // Testing testing?: { minTests?: number; testCoverage?: number; mutationScore?: number; flakyTestThreshold?: number; }; // Documentation documentation?: { coverage?: number; apiDocs?: boolean; readme?: boolean; changelog?: boolean; }; } export interface QualityGateResult { passed: boolean; score: number; failures: QualityGateFailure[]; warnings: QualityGateWarning[]; metrics: QualityMetrics; } export interface QualityGateFailure { gate: string; expected: any; actual: any; message: string; severity: 'critical' | 'high' | 'medium'; } export interface QualityGateWarning { gate: string; message: string; suggestion?: string; } export interface QualityMetrics { codeCoverage?: number; duplicatePercentage?: number; cyclomaticComplexity?: number; maintainabilityIndex?: number; securityScore?: number; performanceScore?: number; testingScore?: number; documentationScore?: number; } /** * Quality Gate Evaluator */ export class QualityGateEvaluator { private config: QualityGateConfig; constructor(config: QualityGateConfig) { this.config = config; } async evaluate(metrics: QualityMetrics): Promise<QualityGateResult> { const failures: QualityGateFailure[] = []; const warnings: QualityGateWarning[] = []; let score = 100; // Evaluate code coverage if (this.config.codeCoverage) { const result = this.evaluateCodeCoverage(metrics.codeCoverage); if (result.failure) failures.push(result.failure); if (result.warning) warnings.push(result.warning); score -= result.penalty; } // Evaluate duplicate code if (this.config.duplicateCode) { const result = this.evaluateDuplicateCode(metrics.duplicatePercentage); if (result.failure) failures.push(result.failure); if (result.warning) warnings.push(result.warning); score -= result.penalty; } // Evaluate complexity if (this.config.complexity) { const result = this.evaluateComplexity(metrics.cyclomaticComplexity); if (result.failure) failures.push(result.failure); if (result.warning) warnings.push(result.warning); score -= result.penalty; } // Evaluate maintainability if (this.config.maintainability) { const result = this.evaluateMaintainability(metrics.maintainabilityIndex); if (result.failure) failures.push(result.failure); if (result.warning) warnings.push(result.warning); score -= result.penalty; } // Evaluate security if (this.config.security) { const result = this.evaluateSecurity(metrics.securityScore); if (result.failure) failures.push(result.failure); if (result.warning) warnings.push(result.warning); score -= result.penalty; } // Evaluate performance if (this.config.performance) { const result = this.evaluatePerformance(metrics.performanceScore); if (result.failure) failures.push(result.failure); if (result.warning) warnings.push(result.warning); score -= result.penalty; } const passed = failures.filter(f => f.severity === 'critical').length === 0; return { passed, score: Math.max(0, score), failures, warnings, metrics }; } private evaluateCodeCoverage(actual?: number): { failure?: QualityGateFailure; warning?: QualityGateWarning; penalty: number; } { if (actual === undefined) { return { warning: { gate: 'codeCoverage', message: 'Code coverage metrics not available' }, penalty: 5 }; } const threshold = this.config.codeCoverage!.threshold; if (actual < threshold) { return { failure: { gate: 'codeCoverage', expected: threshold, actual, message: `Code coverage ${actual}% is below threshold ${threshold}%`, severity: actual < threshold - 20 ? 'critical' : 'high' }, penalty: Math.ceil((threshold - actual) / 2) }; } if (actual < threshold + 10) { return { warning: { gate: 'codeCoverage', message: `Code coverage ${actual}% is close to threshold ${threshold}%`, suggestion: 'Consider adding more tests to improve coverage' }, penalty: 0 }; } return { penalty: 0 }; } private evaluateDuplicateCode(actual?: number): { failure?: QualityGateFailure; warning?: QualityGateWarning; penalty: number; } { if (actual === undefined) { return { warning: { gate: 'duplicateCode', message: 'Duplicate code metrics not available' }, penalty: 3 }; } const threshold = this.config.duplicateCode!.threshold; if (actual > threshold) { return { failure: { gate: 'duplicateCode', expected: threshold, actual, message: `Duplicate code ${actual}% exceeds threshold ${threshold}%`, severity: actual > threshold * 2 ? 'high' : 'medium' }, penalty: Math.ceil(actual - threshold) }; } return { penalty: 0 }; } private evaluateComplexity(actual?: number): { failure?: QualityGateFailure; warning?: QualityGateWarning; penalty: number; } { if (actual === undefined) { return { warning: { gate: 'complexity', message: 'Complexity metrics not available' }, penalty: 3 }; } const threshold = this.config.complexity!.cyclomatic || 10; if (actual > threshold) { return { failure: { gate: 'complexity', expected: threshold, actual, message: `Cyclomatic complexity ${actual} exceeds threshold ${threshold}`, severity: actual > threshold * 1.5 ? 'high' : 'medium' }, penalty: Math.ceil((actual - threshold) * 2) }; } return { penalty: 0 }; } private evaluateMaintainability(actual?: number): { failure?: QualityGateFailure; warning?: QualityGateWarning; penalty: number; } { if (actual === undefined) { return { warning: { gate: 'maintainability', message: 'Maintainability metrics not available' }, penalty: 2 }; } const threshold = this.config.maintainability!.index || 20; if (actual < threshold) { return { failure: { gate: 'maintainability', expected: threshold, actual, message: `Maintainability index ${actual} is below threshold ${threshold}`, severity: 'medium' }, penalty: Math.ceil((threshold - actual) / 2) }; } return { penalty: 0 }; } private evaluateSecurity(actual?: number): { failure?: QualityGateFailure; warning?: QualityGateWarning; penalty: number; } { if (actual === undefined) { return { warning: { gate: 'security', message: 'Security metrics not available' }, penalty: 10 }; } // Security score is 0-100, higher is better const threshold = 80; if (actual < threshold) { return { failure: { gate: 'security', expected: threshold, actual, message: `Security score ${actual} is below threshold ${threshold}`, severity: actual < 60 ? 'critical' : 'high' }, penalty: Math.ceil((threshold - actual) / 2) }; } return { penalty: 0 }; } private evaluatePerformance(actual?: number): { failure?: QualityGateFailure; warning?: QualityGateWarning; penalty: number; } { if (actual === undefined) { return { warning: { gate: 'performance', message: 'Performance metrics not available' }, penalty: 5 }; } // Performance score is 0-100, higher is better const threshold = 70; if (actual < threshold) { return { failure: { gate: 'performance', expected: threshold, actual, message: `Performance score ${actual} is below threshold ${threshold}`, severity: 'medium' }, penalty: Math.ceil((threshold - actual) / 3) }; } return { penalty: 0 }; } } /** * Quality Gate Presets */ export class QualityGatePresets { static strict(): QualityGateConfig { return { codeCoverage: { threshold: 90, perFile: true }, duplicateCode: { threshold: 3, minTokens: 50 }, complexity: { cyclomatic: 5, cognitive: 10, maxMethodLength: 50, maxFileLength: 300 }, maintainability: { index: 30, technicalDebt: 0, codeSmells: 0 }, security: { vulnerabilities: { critical: 0, high: 0, medium: 0, low: 5 }, hotspots: 0 }, performance: { buildTime: 300, bundleSize: 500000, loadTime: 3000, memoryUsage: 512 }, testing: { minTests: 100, testCoverage: 90, mutationScore: 80, flakyTestThreshold: 0 }, documentation: { coverage: 100, apiDocs: true, readme: true, changelog: true } }; } static standard(): QualityGateConfig { return { codeCoverage: { threshold: 80 }, duplicateCode: { threshold: 5 }, complexity: { cyclomatic: 10, maxMethodLength: 100, maxFileLength: 500 }, maintainability: { index: 20 }, security: { vulnerabilities: { critical: 0, high: 0, medium: 5, low: 10 } }, testing: { minTests: 50, testCoverage: 80 } }; } static relaxed(): QualityGateConfig { return { codeCoverage: { threshold: 60 }, duplicateCode: { threshold: 10 }, complexity: { cyclomatic: 15 }, security: { vulnerabilities: { critical: 0, high: 3, medium: 10, low: 20 } } }; } static minimal(): QualityGateConfig { return { codeCoverage: { threshold: 40 }, security: { vulnerabilities: { critical: 0, high: 5, medium: 20, low: 50 } } }; } } /** * Quality Gate Reporter */ export class QualityGateReporter { generateReport(result: QualityGateResult): string { const status = result.passed ? ' PASSED' : ' FAILED'; const scoreColor = result.score >= 80 ? 'ðŸŸ¢' : result.score >= 60 ? 'ðŸŸ¡' : ''; let report = `# Quality Gate Report ## Status: ${status} ## Score: ${scoreColor} ${result.score}/100 ### Metrics `; if (result.metrics.codeCoverage !== undefined) { report += `- **Code Coverage**: ${result.metrics.codeCoverage}%\n`; } if (result.metrics.duplicatePercentage !== undefined) { report += `- **Duplicate Code**: ${result.metrics.duplicatePercentage}%\n`; } if (result.metrics.cyclomaticComplexity !== undefined) { report += `- **Cyclomatic Complexity**: ${result.metrics.cyclomaticComplexity}\n`; } if (result.metrics.maintainabilityIndex !== undefined) { report += `- **Maintainability Index**: ${result.metrics.maintainabilityIndex}\n`; } if (result.metrics.securityScore !== undefined) { report += `- **Security Score**: ${result.metrics.securityScore}/100\n`; } if (result.metrics.performanceScore !== undefined) { report += `- **Performance Score**: ${result.metrics.performanceScore}/100\n`; } if (result.failures.length > 0) { report += ` ### Failures `; for (const failure of result.failures) { report += `- **${failure.gate}** [${failure.severity}]: ${failure.message}\n`; report += ` - Expected: ${failure.expected}\n`; report += ` - Actual: ${failure.actual}\n`; } } if (result.warnings.length > 0) { report += ` ### Warnings `; for (const warning of result.warnings) { report += `- **${warning.gate}**: ${warning.message}\n`; if (warning.suggestion) { report += ` - Suggestion: ${warning.suggestion}\n`; } } } report += ` ### Recommendations `; if (!result.passed) { report += ` 1. Address all critical failures before proceeding 2. Review high severity issues and create action items 3. Consider adjusting thresholds if they are too strict for your project `; } else if (result.score < 80) { report += ` 1. Focus on improving areas with warnings 2. Gradually increase quality thresholds 3. Add more comprehensive testing `; } else { report += ` 1. Maintain current quality standards 2. Consider adopting stricter quality gates 3. Continue monitoring trends over time `; } return report; } generateJSON(result: QualityGateResult): string { return JSON.stringify(result, null, 2); } generateJUnit(result: QualityGateResult): string { const testCases = [ ...result.failures.map(f => ({ name: f.gate, classname: 'QualityGates', time: 0, failure: { message: f.message, type: f.severity } })), ...result.warnings.map(w => ({ name: w.gate, classname: 'QualityGates', time: 0, skipped: { message: w.message } })) ]; return `<?xml version="1.0" encoding="UTF-8"?> <testsuites name="Quality Gates" tests="${testCases.length}" failures="${result.failures.length}" skipped="${result.warnings.length}"> <testsuite name="Quality Gate Checks" tests="${testCases.length}" failures="${result.failures.length}" skipped="${result.warnings.length}"> ${testCases.map(tc => ` <testcase name="${tc.name}" classname="${tc.classname}" time="${tc.time}"> ${tc.failure ? `<failure message="${tc.failure.message}" type="${tc.failure.type}"/>` : ''} ${tc.skipped ? `<skipped message="${tc.skipped.message}"/>` : ''} </testcase>`).join('')} </testsuite> </testsuites>`; } }